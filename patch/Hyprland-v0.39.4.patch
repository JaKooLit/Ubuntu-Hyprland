warning: refname 'v0.39.4' is ambiguous.
commit d69a39d69a7937a6608abf9d29ea4200785a073f
Author: Thomas Lindae <56131826+Treeniks@users.noreply.github.com>
Date:   Wed Apr 17 18:44:46 2024 +0200

    hyprctl: fix activewindow request not showing workspace name (#5623)

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index 00bea61e..9fc227c7 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -216,7 +216,7 @@ static std::string getWindowData(CWindow* w, eHyprCtlOutputFormat format) {
                            "{}\n\tfullscreen: {}\n\tfullscreenmode: {}\n\tfakefullscreen: {}\n\tgrouped: {}\n\tswallowing: {:x}\n\tfocusHistoryID: {}\n\n",
                            (uintptr_t)w, w->m_szTitle, (int)w->m_bIsMapped, (int)w->isHidden(), (int)w->m_vRealPosition.goal().x, (int)w->m_vRealPosition.goal().y,
                            (int)w->m_vRealSize.goal().x, (int)w->m_vRealSize.goal().y, w->m_pWorkspace ? w->workspaceID() : WORKSPACE_INVALID,
-                           (!w->m_pWorkspace ? "" : std::to_string(w->workspaceID())), (int)w->m_bIsFloating, (int64_t)w->m_iMonitorID, g_pXWaylandManager->getAppIDClass(w),
+                           (!w->m_pWorkspace ? "" : w->m_pWorkspace->m_szName), (int)w->m_bIsFloating, (int64_t)w->m_iMonitorID, g_pXWaylandManager->getAppIDClass(w),
                            g_pXWaylandManager->getTitle(w), w->m_szInitialClass, w->m_szInitialTitle, w->getPID(), (int)w->m_bIsX11, (int)w->m_bPinned, (int)w->m_bIsFullscreen,
                            (w->m_bIsFullscreen ? (w->m_pWorkspace ? w->m_pWorkspace->m_efFullscreenMode : 0) : 0), (int)w->m_bFakeFullscreenState, getGroupedData(w, format),
                            (uintptr_t)w->m_pSwallowed, getFocusHistoryID(w));

commit f9dd63d57a59e98a0cc817d5e67159deed2721c7
Author: Epikastema <103605612+Epikastema@users.noreply.github.com>
Date:   Wed Apr 17 18:01:50 2024 +0000

    shaders: Use sin-less hash for noise (#5607)

diff --git a/src/render/shaders/Textures.hpp b/src/render/shaders/Textures.hpp
index 59c7304f..6ac33a0a 100644
--- a/src/render/shaders/Textures.hpp
+++ b/src/render/shaders/Textures.hpp
@@ -400,7 +400,9 @@ uniform float     noise;
 uniform float     brightness;
 
 float hash(vec2 p) {
-    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
+    vec3 p3 = fract(vec3(p.xyx) * 1689.1984);
+    p3 += dot(p3, p3.yzx + 33.33);
+    return fract((p3.x + p3.y) * p3.z);
 }
 
 void main() {

commit 4f1bd4e6a8cdd29d9dfc3a8e10e7d137d4668956
Author: Maarten de Vries <maarten@de-vri.es>
Date:   Wed Apr 17 13:04:16 2024 +0200

    keybindmgr: add optional `silent` suffix to `movewindow`. (#5597)
    
    With the `silent` suffix, the focus remains on the current position in
    the layout or the current monitor, instead of following the moved
    window. When combined with `movewindow mon:X`, this this allows you to
    get the same behavior as xmonad's `windowToScreen` command.

diff --git a/src/layout/DwindleLayout.cpp b/src/layout/DwindleLayout.cpp
index ea078349..711938e7 100644
--- a/src/layout/DwindleLayout.cpp
+++ b/src/layout/DwindleLayout.cpp
@@ -897,11 +897,13 @@ SWindowRenderLayoutHints CHyprDwindleLayout::requestRenderHints(CWindow* pWindow
     return hints;
 }
 
-void CHyprDwindleLayout::moveWindowTo(CWindow* pWindow, const std::string& dir) {
+void CHyprDwindleLayout::moveWindowTo(CWindow* pWindow, const std::string& dir, bool silent) {
     if (!isDirection(dir))
         return;
 
-    const auto PNODE = getNodeFromWindow(pWindow);
+    const auto     PNODE               = getNodeFromWindow(pWindow);
+    const int      originalWorkspaceID = pWindow->workspaceID();
+    const Vector2D originalPos         = pWindow->middle();
 
     if (!PNODE)
         return;
@@ -934,6 +936,13 @@ void CHyprDwindleLayout::moveWindowTo(CWindow* pWindow, const std::string& dir)
     onWindowCreatedTiling(pWindow);
 
     m_vOverrideFocalPoint.reset();
+
+    // restore focus to the previous position
+    if (silent) {
+        const auto PNODETOFOCUS = getClosestNodeOnWorkspace(originalWorkspaceID, originalPos);
+        if (PNODETOFOCUS && PNODETOFOCUS->pWindow)
+            g_pCompositor->focusWindow(PNODETOFOCUS->pWindow);
+    }
 }
 
 void CHyprDwindleLayout::switchWindows(CWindow* pWindow, CWindow* pWindow2) {
diff --git a/src/layout/DwindleLayout.hpp b/src/layout/DwindleLayout.hpp
index 718a47ca..11b927d1 100644
--- a/src/layout/DwindleLayout.hpp
+++ b/src/layout/DwindleLayout.hpp
@@ -56,7 +56,7 @@ class CHyprDwindleLayout : public IHyprLayout {
     virtual std::any                 layoutMessage(SLayoutMessageHeader, std::string);
     virtual SWindowRenderLayoutHints requestRenderHints(CWindow*);
     virtual void                     switchWindows(CWindow*, CWindow*);
-    virtual void                     moveWindowTo(CWindow*, const std::string& dir);
+    virtual void                     moveWindowTo(CWindow*, const std::string& dir, bool silent);
     virtual void                     alterSplitRatio(CWindow*, float, bool);
     virtual std::string              getLayoutName();
     virtual void                     replaceWindowDataWith(CWindow* from, CWindow* to);
diff --git a/src/layout/IHyprLayout.hpp b/src/layout/IHyprLayout.hpp
index d6c41d3b..e05580c4 100644
--- a/src/layout/IHyprLayout.hpp
+++ b/src/layout/IHyprLayout.hpp
@@ -136,7 +136,7 @@ class IHyprLayout {
         Called when the user requests a window move in a direction.
         The layout is free to ignore.
     */
-    virtual void moveWindowTo(CWindow*, const std::string& direction) = 0;
+    virtual void moveWindowTo(CWindow*, const std::string& direction, bool silent = false) = 0;
 
     /*
         Called when the user requests to change the splitratio by or to X
diff --git a/src/layout/MasterLayout.cpp b/src/layout/MasterLayout.cpp
index 0999303f..4ef68712 100644
--- a/src/layout/MasterLayout.cpp
+++ b/src/layout/MasterLayout.cpp
@@ -949,7 +949,7 @@ SWindowRenderLayoutHints CHyprMasterLayout::requestRenderHints(CWindow* pWindow)
     return hints; // master doesnt have any hints
 }
 
-void CHyprMasterLayout::moveWindowTo(CWindow* pWindow, const std::string& dir) {
+void CHyprMasterLayout::moveWindowTo(CWindow* pWindow, const std::string& dir, bool silent) {
     if (!isDirection(dir))
         return;
 
@@ -965,12 +965,16 @@ void CHyprMasterLayout::moveWindowTo(CWindow* pWindow, const std::string& dir) {
         onWindowRemovedTiling(pWindow);
         pWindow->moveToWorkspace(PWINDOW2->m_pWorkspace);
         pWindow->m_iMonitorID = PWINDOW2->m_iMonitorID;
-        const auto pMonitor   = g_pCompositor->getMonitorFromID(pWindow->m_iMonitorID);
-        g_pCompositor->setActiveMonitor(pMonitor);
+        if (!silent) {
+            const auto pMonitor = g_pCompositor->getMonitorFromID(pWindow->m_iMonitorID);
+            g_pCompositor->setActiveMonitor(pMonitor);
+        }
         onWindowCreatedTiling(pWindow);
     } else {
         // if same monitor, switch windows
         switchWindows(pWindow, PWINDOW2);
+        if (silent)
+            g_pCompositor->focusWindow(PWINDOW2);
     }
 }
 
diff --git a/src/layout/MasterLayout.hpp b/src/layout/MasterLayout.hpp
index de4a97a3..de4ac41d 100644
--- a/src/layout/MasterLayout.hpp
+++ b/src/layout/MasterLayout.hpp
@@ -62,7 +62,7 @@ class CHyprMasterLayout : public IHyprLayout {
     virtual std::any                 layoutMessage(SLayoutMessageHeader, std::string);
     virtual SWindowRenderLayoutHints requestRenderHints(CWindow*);
     virtual void                     switchWindows(CWindow*, CWindow*);
-    virtual void                     moveWindowTo(CWindow*, const std::string& dir);
+    virtual void                     moveWindowTo(CWindow*, const std::string& dir, bool silent);
     virtual void                     alterSplitRatio(CWindow*, float, bool);
     virtual std::string              getLayoutName();
     virtual void                     replaceWindowDataWith(CWindow* from, CWindow* to);
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 1a97c3da..e6d54ae1 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1216,15 +1216,20 @@ void CKeybindManager::swapActive(std::string args) {
 }
 
 void CKeybindManager::moveActiveTo(std::string args) {
-    char arg = args[0];
+    char arg    = args[0];
+    bool silent = args.ends_with(" silent");
+    if (silent)
+        args = args.substr(0, args.length() - 7);
 
     if (args.starts_with("mon:")) {
         const auto PNEWMONITOR = g_pCompositor->getMonitorFromString(args.substr(4));
         if (!PNEWMONITOR)
             return;
 
-        moveActiveToWorkspace(PNEWMONITOR->activeWorkspace->getConfigName());
-        return;
+        if (silent)
+            moveActiveToWorkspaceSilent(PNEWMONITOR->activeWorkspace->getConfigName());
+        else
+            moveActiveToWorkspace(PNEWMONITOR->activeWorkspace->getConfigName());
     }
 
     if (!isDirection(args)) {
@@ -1258,8 +1263,9 @@ void CKeybindManager::moveActiveTo(std::string args) {
     // If the window to change to is on the same workspace, switch them
     const auto PWINDOWTOCHANGETO = g_pCompositor->getWindowInDirection(PLASTWINDOW, arg);
     if (PWINDOWTOCHANGETO) {
-        g_pLayoutManager->getCurrentLayout()->moveWindowTo(PLASTWINDOW, args);
-        g_pCompositor->warpCursorTo(PLASTWINDOW->middle());
+        g_pLayoutManager->getCurrentLayout()->moveWindowTo(PLASTWINDOW, args, silent);
+        if (!silent)
+            g_pCompositor->warpCursorTo(PLASTWINDOW->middle());
         return;
     }
 
@@ -1269,8 +1275,10 @@ void CKeybindManager::moveActiveTo(std::string args) {
         return;
 
     const auto PWORKSPACE = PMONITORTOCHANGETO->activeWorkspace;
-
-    moveActiveToWorkspace(PWORKSPACE->getConfigName());
+    if (silent)
+        moveActiveToWorkspaceSilent(PWORKSPACE->getConfigName());
+    else
+        moveActiveToWorkspace(PWORKSPACE->getConfigName());
 }
 
 void CKeybindManager::toggleGroup(std::string args) {

commit 09d6dee091e6606a65b1e738ca34bf0d299cd308
Author: zakk4223 <zakk@rsdio.com>
Date:   Thu Apr 18 21:44:51 2024 -0400

    workspace: Add 'v' flag for workspace selector that counts only visible windows (#5628)
    
    * Add 'v' flag for workspace selector: counts only visible windows
    
    * extra commit because I'm dumb
    
    * guard

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 47679169..ae1c352c 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -1273,23 +1273,34 @@ void CCompositor::sanityCheckWorkspaces() {
     }
 }
 
-int CCompositor::getWindowsOnWorkspace(const int& id, std::optional<bool> onlyTiled) {
+int CCompositor::getWindowsOnWorkspace(const int& id, std::optional<bool> onlyTiled, std::optional<bool> onlyVisible) {
     int no = 0;
     for (auto& w : m_vWindows) {
-        if (w->workspaceID() == id && w->m_bIsMapped && !(onlyTiled.has_value() && !w->m_bIsFloating != onlyTiled.value()))
-            no++;
+        if (w->workspaceID() != id || !w->m_bIsMapped)
+            continue;
+        if (onlyTiled.has_value() && w->m_bIsFloating == onlyTiled.value())
+            continue;
+        if (onlyVisible.has_value() && w->isHidden() == onlyVisible.value())
+            continue;
+        no++;
     }
 
     return no;
 }
 
-int CCompositor::getGroupsOnWorkspace(const int& id, std::optional<bool> onlyTiled) {
+int CCompositor::getGroupsOnWorkspace(const int& id, std::optional<bool> onlyTiled, std::optional<bool> onlyVisible) {
     int no = 0;
     for (auto& w : m_vWindows) {
-        if (w->workspaceID() == id && w->m_bIsMapped && !(onlyTiled.has_value() && !w->m_bIsFloating != onlyTiled.value()) && w->m_sGroupData.head)
-            no++;
+        if (w->workspaceID() != id || !w->m_bIsMapped)
+            continue;
+        if (!w->m_sGroupData.head)
+            continue;
+        if (onlyTiled.has_value() && w->m_bIsFloating == onlyTiled.value())
+            continue;
+        if (onlyVisible.has_value() && w->isHidden() == onlyVisible.value())
+            continue;
+        no++;
     }
-
     return no;
 }
 
diff --git a/src/Compositor.hpp b/src/Compositor.hpp
index f2d39490..11c02814 100644
--- a/src/Compositor.hpp
+++ b/src/Compositor.hpp
@@ -151,8 +151,8 @@ class CCompositor {
     void           sanityCheckWorkspaces();
     void           updateWorkspaceWindowDecos(const int&);
     void           updateWorkspaceSpecialRenderData(const int&);
-    int            getWindowsOnWorkspace(const int& id, std::optional<bool> onlyTiled = {});
-    int            getGroupsOnWorkspace(const int& id, std::optional<bool> onlyTiled = {});
+    int            getWindowsOnWorkspace(const int& id, std::optional<bool> onlyTiled = {}, std::optional<bool> onlyVisible = {});
+    int            getGroupsOnWorkspace(const int& id, std::optional<bool> onlyTiled = {}, std::optional<bool> onlyVisible = {});
     CWindow*       getUrgentWindow();
     bool           hasUrgentWindowOnWorkspace(const int&);
     CWindow*       getFirstWindowOnWorkspace(const int&);
diff --git a/src/desktop/Workspace.cpp b/src/desktop/Workspace.cpp
index 5789e54f..25015c5a 100644
--- a/src/desktop/Workspace.cpp
+++ b/src/desktop/Workspace.cpp
@@ -251,6 +251,7 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
             // m - monitor: m[monitor_selector]
             // w - windowCount: w[1-4] or w[1], optional flag t or f for tiled or floating and
             //                  flag g to count groups instead of windows, e.g. w[t1-2], w[fg4]
+            //                  flag v will count only visible windows
 
             const auto  NEXTSPACE = selector.find_first_of(' ', i);
             std::string prop      = selector.substr(i, NEXTSPACE == std::string::npos ? std::string::npos : NEXTSPACE - i);
@@ -355,8 +356,9 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
 
                 prop = prop.substr(2, prop.length() - 3);
 
-                int  wantsOnlyTiled  = -1;
-                bool wantsCountGroup = false;
+                int  wantsOnlyTiled    = -1;
+                bool wantsCountGroup   = false;
+                bool wantsCountVisible = false;
 
                 int  flagCount = 0;
                 for (auto& flag : prop) {
@@ -369,6 +371,9 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
                     } else if (flag == 'g' && !wantsCountGroup) {
                         wantsCountGroup = true;
                         flagCount++;
+                    } else if (flag == 'v' && !wantsCountVisible) {
+                        wantsCountVisible = true;
+                        flagCount++;
                     } else {
                         break;
                     }
@@ -392,9 +397,11 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
 
                     int count;
                     if (wantsCountGroup)
-                        count = g_pCompositor->getGroupsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled));
+                        count = g_pCompositor->getGroupsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled),
+                                                                    wantsCountVisible ? std::optional<bool>(wantsCountVisible) : std::nullopt);
                     else
-                        count = g_pCompositor->getWindowsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled));
+                        count = g_pCompositor->getWindowsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled),
+                                                                     wantsCountVisible ? std::optional<bool>(wantsCountVisible) : std::nullopt);
 
                     if (count != from)
                         return false;
@@ -424,9 +431,11 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
 
                 int count;
                 if (wantsCountGroup)
-                    count = g_pCompositor->getGroupsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled));
+                    count = g_pCompositor->getGroupsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled),
+                                                                wantsCountVisible ? std::optional<bool>(wantsCountVisible) : std::nullopt);
                 else
-                    count = g_pCompositor->getWindowsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled));
+                    count = g_pCompositor->getWindowsOnWorkspace(m_iID, wantsOnlyTiled == -1 ? std::nullopt : std::optional<bool>((bool)wantsOnlyTiled),
+                                                                 wantsCountVisible ? std::optional<bool>(wantsCountVisible) : std::nullopt);
 
                 if (std::clamp(count, from, to) != count)
                     return false;

commit 137bf22bb46873db6aec29a69d566d799f34c3d2
Author: Sungyoon Cho <sungyoon@sungyooncho.dev>
Date:   Sat Apr 20 02:46:16 2024 +0900

    windows: recalculate monitor after updating windows (#5647)
    
    Recalculate monitor after updating windows, so layout render doesn't get
    overridden.

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index b81cb1a4..737d5ef7 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -392,8 +392,12 @@ void CWindow::moveToWorkspace(PHLWORKSPACE pWorkspace) {
 
     g_pCompositor->updateWorkspaceWindows(OLDWORKSPACE->m_iID);
     g_pCompositor->updateWorkspaceSpecialRenderData(OLDWORKSPACE->m_iID);
+    g_pLayoutManager->getCurrentLayout()->recalculateMonitor(OLDWORKSPACE->m_iMonitorID);
+
     g_pCompositor->updateWorkspaceWindows(workspaceID());
     g_pCompositor->updateWorkspaceSpecialRenderData(workspaceID());
+    g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m_iMonitorID);
+
     g_pCompositor->updateAllWindowsAnimatedDecorationValues();
 
     if (valid(pWorkspace)) {
@@ -486,6 +490,7 @@ void CWindow::onUnmap() {
 
     g_pCompositor->updateWorkspaceWindows(workspaceID());
     g_pCompositor->updateWorkspaceSpecialRenderData(workspaceID());
+    g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m_iMonitorID);
     g_pCompositor->updateAllWindowsAnimatedDecorationValues();
 
     m_pWorkspace.reset();
@@ -853,9 +858,9 @@ void CWindow::createGroup() {
 
         addWindowDeco(std::make_unique<CHyprGroupBarDecoration>(this));
 
-        g_pLayoutManager->getCurrentLayout()->recalculateWindow(this);
         g_pCompositor->updateWorkspaceWindows(workspaceID());
         g_pCompositor->updateWorkspaceSpecialRenderData(workspaceID());
+        g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m_iMonitorID);
         g_pCompositor->updateAllWindowsAnimatedDecorationValues();
     }
 }
@@ -871,6 +876,7 @@ void CWindow::destroyGroup() {
         updateWindowDecos();
         g_pCompositor->updateWorkspaceWindows(workspaceID());
         g_pCompositor->updateWorkspaceSpecialRenderData(workspaceID());
+        g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m_iMonitorID);
         g_pCompositor->updateAllWindowsAnimatedDecorationValues();
         return;
     }
@@ -901,6 +907,7 @@ void CWindow::destroyGroup() {
 
     g_pCompositor->updateWorkspaceWindows(workspaceID());
     g_pCompositor->updateWorkspaceSpecialRenderData(workspaceID());
+    g_pLayoutManager->getCurrentLayout()->recalculateMonitor(m_iMonitorID);
     g_pCompositor->updateAllWindowsAnimatedDecorationValues();
 }
 
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index e6d54ae1..1758f333 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -211,6 +211,7 @@ bool CKeybindManager::ensureMouseBindState() {
 
         g_pCompositor->updateWorkspaceWindows(lastDraggedWindow->workspaceID());
         g_pCompositor->updateWorkspaceSpecialRenderData(lastDraggedWindow->workspaceID());
+        g_pLayoutManager->getCurrentLayout()->recalculateMonitor(lastDraggedWindow->m_iMonitorID);
         g_pCompositor->updateAllWindowsAnimatedDecorationValues();
 
         return true;
@@ -872,6 +873,7 @@ static void toggleActiveFloatingCore(std::string args, std::optional<bool> float
     }
     g_pCompositor->updateWorkspaceWindows(PWINDOW->workspaceID());
     g_pCompositor->updateWorkspaceSpecialRenderData(PWINDOW->workspaceID());
+    g_pLayoutManager->getCurrentLayout()->recalculateMonitor(PWINDOW->m_iMonitorID);
     g_pCompositor->updateAllWindowsAnimatedDecorationValues();
 }
 

commit ebd5dc39c3af3911c3c170341b96f1130f5a3aed
Author: Yixun Lan <dlan@gentoo.org>
Date:   Fri Apr 19 13:39:55 2024 -0400

    misc: fix autocompletions for meson (hyprctl/hyprpm)
    
    Signed-off-by: Julien Roy <julien@jroy.ca>

diff --git a/hyprctl/meson.build b/hyprctl/meson.build
index 390baf66..94e98b4b 100644
--- a/hyprctl/meson.build
+++ b/hyprctl/meson.build
@@ -2,6 +2,6 @@ executable('hyprctl', 'main.cpp',
   install: true
 )
 
-install_data('hyprctl.bash', install_dir: join_paths(get_option('datadir'), 'bash-completion'), install_tag: 'runtime', rename: 'hyprctl')
+install_data('hyprctl.bash', install_dir: join_paths(get_option('datadir'), 'bash-completion/completions'), install_tag: 'runtime', rename: 'hyprctl')
 install_data('hyprctl.fish', install_dir: join_paths(get_option('datadir'), 'fish/vendor_completions.d'), install_tag: 'runtime')
 install_data('hyprctl.zsh', install_dir: join_paths(get_option('datadir'), 'zsh/site-functions'), install_tag: 'runtime', rename: '_hyprctl')
diff --git a/hyprpm/src/meson.build b/hyprpm/src/meson.build
index 9ecdaa0c..a8644169 100644
--- a/hyprpm/src/meson.build
+++ b/hyprpm/src/meson.build
@@ -9,6 +9,6 @@ executable('hyprpm', src,
   install : true
 )
 
-install_data('../hyprpm.bash', install_dir: join_paths(get_option('datadir'), 'bash-completion'), install_tag: 'runtime', rename: 'hyprpm')
+install_data('../hyprpm.bash', install_dir: join_paths(get_option('datadir'), 'bash-completion/completions'), install_tag: 'runtime', rename: 'hyprpm')
 install_data('../hyprpm.fish', install_dir: join_paths(get_option('datadir'), 'fish/vendor_completions.d'), install_tag: 'runtime')
 install_data('../hyprpm.zsh', install_dir: join_paths(get_option('datadir'), 'zsh/site-functions'), install_tag: 'runtime', rename: '_hyprpm')

commit e5356b174b56cc0f89a8ca02a09073d4d0e46446
Author: Vaxry <43317083+vaxerski@users.noreply.github.com>
Date:   Fri Apr 19 22:16:35 2024 +0100

    tearing-control: hyprland impl (#5655)
    
    * tearing: hl impl
    
    * format

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0c949928..b056402a 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -263,6 +263,7 @@ protocol("staging/fractional-scale/fractional-scale-v1.xml" "fractional-scale-v1
 protocol("staging/tearing-control/tearing-control-v1.xml" "tearing-control-v1" false)
 protocol("unstable/text-input/text-input-unstable-v1.xml" "text-input-unstable-v1" false)
 protocol("staging/cursor-shape/cursor-shape-v1.xml" "cursor-shape-v1" false)
+protocol("staging/tearing-control/tearing-control-v1.xml" "tearing-control-v1" false)
 
 # tools
 add_subdirectory(hyprctl)
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index ae1c352c..6e739c5f 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -253,8 +253,6 @@ void CCompositor::initServer() {
 
     m_sWLRCursorShapeMgr = wlr_cursor_shape_manager_v1_create(m_sWLDisplay, 1);
 
-    m_sWLRTearingControlMgr = wlr_tearing_control_manager_v1_create(m_sWLDisplay, 1);
-
     if (!m_sWLRHeadlessBackend) {
         Debug::log(CRIT, "Couldn't create the headless backend");
         throwError("wlr_headless_backend_create() failed!");
@@ -311,7 +309,6 @@ void CCompositor::initAllSignals() {
     addWLSignal(&m_sWLRSessionLockMgr->events.new_lock, &Events::listen_newSessionLock, m_sWLRSessionLockMgr, "SessionLockMgr");
     addWLSignal(&m_sWLRGammaCtrlMgr->events.set_gamma, &Events::listen_setGamma, m_sWLRGammaCtrlMgr, "GammaCtrlMgr");
     addWLSignal(&m_sWLRCursorShapeMgr->events.request_set_shape, &Events::listen_setCursorShape, m_sWLRCursorShapeMgr, "CursorShapeMgr");
-    addWLSignal(&m_sWLRTearingControlMgr->events.new_object, &Events::listen_newTearingHint, m_sWLRTearingControlMgr, "TearingControlMgr");
     addWLSignal(&m_sWLRKbShInhibitMgr->events.new_inhibitor, &Events::listen_newShortcutInhibitor, m_sWLRKbShInhibitMgr, "ShortcutInhibitMgr");
 
     if (m_sWRLDRMLeaseMgr)
@@ -365,7 +362,6 @@ void CCompositor::removeAllSignals() {
     removeWLSignal(&Events::listen_newSessionLock);
     removeWLSignal(&Events::listen_setGamma);
     removeWLSignal(&Events::listen_setCursorShape);
-    removeWLSignal(&Events::listen_newTearingHint);
     removeWLSignal(&Events::listen_newShortcutInhibitor);
 
     if (m_sWRLDRMLeaseMgr)
@@ -695,6 +691,8 @@ CMonitor* CCompositor::getMonitorFromVector(const Vector2D& point) {
 
 void CCompositor::removeWindowFromVectorSafe(CWindow* pWindow) {
     if (windowExists(pWindow) && !pWindow->m_bFadingOut) {
+        EMIT_HOOK_EVENT("destroyWindow", pWindow);
+
         std::erase_if(m_vWindows, [&](std::unique_ptr<CWindow>& el) { return el.get() == pWindow; });
         std::erase_if(m_vWindowsFadingOut, [&](CWindow* el) { return el == pWindow; });
     }
diff --git a/src/Compositor.hpp b/src/Compositor.hpp
index 11c02814..9244c673 100644
--- a/src/Compositor.hpp
+++ b/src/Compositor.hpp
@@ -82,7 +82,6 @@ class CCompositor {
     wlr_session_lock_manager_v1*               m_sWLRSessionLockMgr;
     wlr_gamma_control_manager_v1*              m_sWLRGammaCtrlMgr;
     wlr_cursor_shape_manager_v1*               m_sWLRCursorShapeMgr;
-    wlr_tearing_control_manager_v1*            m_sWLRTearingControlMgr;
     // ------------------------------------------------- //
 
     std::string                               m_szWLDisplaySocket   = "";
diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index 737d5ef7..35b4ff97 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -535,14 +535,6 @@ void CWindow::onMap() {
     m_vReportedSize = m_vPendingReportedSize;
     m_bAnimatingIn  = true;
 
-    for (const auto& ctrl : g_pHyprRenderer->m_vTearingControllers) {
-        if (ctrl->pWlrHint->surface != m_pWLSurface.wlr())
-            continue;
-
-        m_bTearingHint = ctrl->pWlrHint->current;
-        break;
-    }
-
     if (m_bIsX11)
         return;
 
diff --git a/src/events/Events.hpp b/src/events/Events.hpp
index 9dbd75df..4c4503ad 100644
--- a/src/events/Events.hpp
+++ b/src/events/Events.hpp
@@ -144,9 +144,6 @@ namespace Events {
     // Cursor shape
     LISTENER(setCursorShape);
 
-    // Tearing hints
-    LISTENER(newTearingHint);
-
     // Shortcut inhibitor
     LISTENER(newShortcutInhibitor);
 };
diff --git a/src/events/Misc.cpp b/src/events/Misc.cpp
index 8d0a9710..53bd6f9f 100644
--- a/src/events/Misc.cpp
+++ b/src/events/Misc.cpp
@@ -245,37 +245,6 @@ void Events::listener_setCursorShape(wl_listener* listener, void* data) {
     g_pInputManager->processMouseRequest(E);
 }
 
-void Events::listener_newTearingHint(wl_listener* listener, void* data) {
-    Debug::log(LOG, "New tearing hint at {:x}", (uintptr_t)data);
-
-    const auto NEWCTRL = g_pHyprRenderer->m_vTearingControllers.emplace_back(std::make_unique<STearingController>()).get();
-    NEWCTRL->pWlrHint  = (wlr_tearing_control_v1*)data;
-
-    NEWCTRL->hyprListener_destroy.initCallback(
-        &NEWCTRL->pWlrHint->events.destroy,
-        [&](void* owner, void* data) {
-            Debug::log(LOG, "Destroyed {:x} tearing hint", (uintptr_t)((STearingController*)owner)->pWlrHint);
-
-            std::erase_if(g_pHyprRenderer->m_vTearingControllers, [&](const auto& other) { return other.get() == owner; });
-        },
-        NEWCTRL, "TearingController");
-
-    NEWCTRL->hyprListener_set.initCallback(
-        &NEWCTRL->pWlrHint->events.set_hint,
-        [&](void* owner, void* data) {
-            const auto TEARINGHINT = (STearingController*)owner;
-
-            const auto PWINDOW = g_pCompositor->getWindowFromSurface(TEARINGHINT->pWlrHint->surface);
-
-            if (PWINDOW) {
-                PWINDOW->m_bTearingHint = (bool)TEARINGHINT->pWlrHint->current;
-
-                Debug::log(LOG, "Hint {:x} (window {}) set tearing hint to {}", (uintptr_t)TEARINGHINT->pWlrHint, PWINDOW, (uint32_t)TEARINGHINT->pWlrHint->current);
-            }
-        },
-        NEWCTRL, "TearingController");
-}
-
 void Events::listener_newShortcutInhibitor(wl_listener* listener, void* data) {
     const auto INHIBITOR = (wlr_keyboard_shortcuts_inhibitor_v1*)data;
 
diff --git a/src/helpers/WLClasses.hpp b/src/helpers/WLClasses.hpp
index 5d93b91d..b85517e8 100644
--- a/src/helpers/WLClasses.hpp
+++ b/src/helpers/WLClasses.hpp
@@ -329,17 +329,6 @@ struct SSwitchDevice {
     }
 };
 
-struct STearingController {
-    wlr_tearing_control_v1* pWlrHint = nullptr;
-
-    DYNLISTENER(set);
-    DYNLISTENER(destroy);
-
-    bool operator==(const STearingController& other) const {
-        return pWlrHint == other.pWlrHint;
-    }
-};
-
 struct SShortcutInhibitor {
     wlr_keyboard_shortcuts_inhibitor_v1* pWlrInhibitor = nullptr;
 
diff --git a/src/includes.hpp b/src/includes.hpp
index 6a1e5bc3..c43c2eaf 100644
--- a/src/includes.hpp
+++ b/src/includes.hpp
@@ -103,7 +103,6 @@ extern "C" {
 #include <wlr/types/wlr_single_pixel_buffer_v1.h>
 #include <wlr/types/wlr_idle_notify_v1.h>
 #include <wlr/types/wlr_cursor_shape_v1.h>
-#include <wlr/types/wlr_tearing_control_v1.h>
 #include <wlr/util/box.h>
 #include <wlr/util/transform.h>
 #include <wlr/render/swapchain.h>
diff --git a/src/managers/ProtocolManager.cpp b/src/managers/ProtocolManager.cpp
index bc3a4570..f6cb66df 100644
--- a/src/managers/ProtocolManager.cpp
+++ b/src/managers/ProtocolManager.cpp
@@ -1,6 +1,9 @@
 #include "ProtocolManager.hpp"
 
+#include "../protocols/TearingControl.hpp"
+
 #include "xdg-output-unstable-v1-protocol.h"
+#include "tearing-control-v1-protocol.h"
 
 CProtocolManager::CProtocolManager() {
     m_pToplevelExportProtocolManager  = std::make_unique<CToplevelExportProtocolManager>();
@@ -10,4 +13,5 @@ CProtocolManager::CProtocolManager() {
     m_pScreencopyProtocolManager      = std::make_unique<CScreencopyProtocolManager>();
 
     m_pXDGOutputProtocol = std::make_unique<CXDGOutputProtocol>(&zxdg_output_manager_v1_interface, 3, "XDGOutput");
+    PROTO::tearing       = std::make_unique<CTearingControlProtocol>(&wp_tearing_control_manager_v1_interface, 1, "TearingControl");
 }
diff --git a/src/protocols/TearingControl.cpp b/src/protocols/TearingControl.cpp
new file mode 100644
index 00000000..0ed495bd
--- /dev/null
+++ b/src/protocols/TearingControl.cpp
@@ -0,0 +1,106 @@
+#include "TearingControl.hpp"
+#include "tearing-control-v1-protocol.h"
+#include "../managers/ProtocolManager.hpp"
+#include "../desktop/Window.hpp"
+#include "../Compositor.hpp"
+
+static void destroyManager(wl_client* client, wl_resource* resource) {
+    RESOURCE_OR_BAIL(PRESOURCE);
+    reinterpret_cast<CTearingControlProtocol*>(PRESOURCE->data())->onManagerResourceDestroy(resource);
+}
+
+static void getTearingControl(wl_client* client, wl_resource* resource, uint32_t id, wl_resource* surface) {
+    RESOURCE_OR_BAIL(PRESOURCE);
+    reinterpret_cast<CTearingControlProtocol*>(PRESOURCE->data())->onGetController(client, resource, id, wlr_surface_from_resource(surface));
+}
+
+//
+
+CTearingControlProtocol::CTearingControlProtocol(const wl_interface* iface, const int& ver, const std::string& name) : IWaylandProtocol(iface, ver, name) {
+    g_pHookSystem->hookDynamic("destroyWindow", [this](void* self, SCallbackInfo& info, std::any param) { this->onWindowDestroy(std::any_cast<CWindow*>(param)); });
+}
+
+static const struct wp_tearing_control_manager_v1_interface MANAGER_IMPL = {
+    .destroy             = ::destroyManager,
+    .get_tearing_control = ::getTearingControl,
+};
+
+void CTearingControlProtocol::bindManager(wl_client* client, void* data, uint32_t ver, uint32_t id) {
+    const auto RESOURCE = m_vManagers.emplace_back(std::make_unique<CWaylandResource>(client, &wp_tearing_control_manager_v1_interface, ver, id)).get();
+
+    if (!RESOURCE->good()) {
+        Debug::log(LOG, "Couldn't bind TearingControlMgr");
+        return;
+    }
+
+    RESOURCE->setImplementation(&MANAGER_IMPL, nullptr);
+    RESOURCE->setData(this);
+}
+
+void CTearingControlProtocol::onManagerResourceDestroy(wl_resource* res) {
+    std::erase_if(m_vManagers, [&](const auto& other) { return other->resource() == res; });
+}
+
+void CTearingControlProtocol::onGetController(wl_client* client, wl_resource* resource, uint32_t id, wlr_surface* surf) {
+    const auto CONTROLLER = m_vTearingControllers
+                                .emplace_back(std::make_unique<CTearingControl>(
+                                    std::make_shared<CWaylandResource>(client, &wp_tearing_control_v1_interface, wl_resource_get_version(resource), id), surf))
+                                .get();
+
+    if (!CONTROLLER->good()) {
+        m_vTearingControllers.pop_back();
+        return;
+    }
+}
+
+void CTearingControlProtocol::onControllerDestroy(CTearingControl* control) {
+    std::erase_if(m_vTearingControllers, [control](const auto& other) { return other.get() == control; });
+}
+
+void CTearingControlProtocol::onWindowDestroy(CWindow* pWindow) {
+    for (auto& c : m_vTearingControllers) {
+        if (c->pWindow == pWindow)
+            c->pWindow = nullptr;
+    }
+}
+
+//
+
+static void destroyController(wl_client* client, wl_resource* resource) {
+    RESOURCE_OR_BAIL(PRESOURCE);
+    PROTO::tearing->onControllerDestroy(reinterpret_cast<CTearingControl*>(PRESOURCE->data()));
+}
+
+static void setPresentationHint(wl_client* client, wl_resource* resource, uint32_t hint) {
+    RESOURCE_OR_BAIL(PRESOURCE);
+    reinterpret_cast<CTearingControl*>(PRESOURCE->data())->onHint(hint);
+}
+
+static const struct wp_tearing_control_v1_interface CONTROLLER_IMPL = {
+    .set_presentation_hint = ::setPresentationHint,
+    .destroy               = ::destroyController,
+};
+
+CTearingControl::CTearingControl(SP<CWaylandResource> resource_, wlr_surface* surf_) : resource(resource_) {
+    resource->setImplementation(&CONTROLLER_IMPL, nullptr);
+    resource->setData(this);
+    resource->setOnDestroyHandler([](CWaylandResource* res) { PROTO::tearing->onControllerDestroy(reinterpret_cast<CTearingControl*>(res->data())); });
+
+    pWindow = g_pCompositor->getWindowFromSurface(surf_);
+}
+
+void CTearingControl::onHint(uint32_t hint_) {
+    hint = hint_ == WP_TEARING_CONTROL_V1_PRESENTATION_HINT_VSYNC ? TEARING_VSYNC : TEARING_ASYNC;
+    updateWindow();
+}
+
+void CTearingControl::updateWindow() {
+    if (!pWindow)
+        return;
+
+    pWindow->m_bTearingHint = hint == TEARING_ASYNC;
+}
+
+bool CTearingControl::good() {
+    return resource->good();
+}
diff --git a/src/protocols/TearingControl.hpp b/src/protocols/TearingControl.hpp
new file mode 100644
index 00000000..f0dd8bfa
--- /dev/null
+++ b/src/protocols/TearingControl.hpp
@@ -0,0 +1,60 @@
+#pragma once
+
+#include <memory>
+#include "WaylandProtocol.hpp"
+
+class CWindow;
+
+enum eTearingPresentationHint {
+    TEARING_VSYNC = 0,
+    TEARING_ASYNC,
+};
+
+class CTearingControlProtocol;
+
+class CTearingControl {
+  public:
+    CTearingControl(SP<CWaylandResource> resource_, wlr_surface* surf_);
+
+    void onHint(uint32_t hint_);
+
+    bool good();
+
+    bool operator==(const wl_resource* other) const {
+        return other == resource->resource();
+    }
+
+    bool operator==(const CTearingControl* other) const {
+        return other->resource == resource;
+    }
+
+  private:
+    void                     updateWindow();
+
+    SP<CWaylandResource>     resource;
+    CWindow*                 pWindow = nullptr;
+    eTearingPresentationHint hint    = TEARING_VSYNC;
+
+    friend class CTearingControlProtocol;
+};
+
+class CTearingControlProtocol : public IWaylandProtocol {
+  public:
+    CTearingControlProtocol(const wl_interface* iface, const int& ver, const std::string& name);
+
+    virtual void bindManager(wl_client* client, void* data, uint32_t ver, uint32_t id);
+
+    void         onManagerResourceDestroy(wl_resource* res);
+    void         onControllerDestroy(CTearingControl* control);
+    void         onGetController(wl_client* client, wl_resource* resource, uint32_t id, wlr_surface* surf);
+
+  private:
+    void                              onWindowDestroy(CWindow* pWindow);
+
+    std::vector<UP<CWaylandResource>> m_vManagers;
+    std::vector<UP<CTearingControl>>  m_vTearingControllers;
+};
+
+namespace PROTO {
+    inline UP<CTearingControlProtocol> tearing;
+};
\ No newline at end of file
diff --git a/src/protocols/WaylandProtocol.cpp b/src/protocols/WaylandProtocol.cpp
index 4600126c..76f5eba0 100644
--- a/src/protocols/WaylandProtocol.cpp
+++ b/src/protocols/WaylandProtocol.cpp
@@ -31,7 +31,14 @@ void CWaylandResource::markDefunct() {
 
     Debug::log(TRACE, "[wl res {:x}] now defunct", (uintptr_t)m_pWLResource);
     m_bDefunct = true;
+
     wl_resource_set_user_data(m_pWLResource, nullptr);
+
+    // we call it here because we need defunct to be set to true.
+    // if this function destroys us, we can't call wl_resource_set_user_data or
+    // destroy the resource.
+    if (m_fOnDestroyHandler)
+        m_fOnDestroyHandler(this);
 }
 
 CWaylandResource::~CWaylandResource() {
@@ -80,6 +87,10 @@ void* CWaylandResource::data() {
     return m_pData;
 }
 
+void CWaylandResource::setOnDestroyHandler(std::function<void(CWaylandResource* res)> fn) {
+    m_fOnDestroyHandler = fn;
+}
+
 static void bindManagerInternal(wl_client* client, void* data, uint32_t ver, uint32_t id) {
     ((IWaylandProtocol*)data)->bindManager(client, data, ver, id);
 }
diff --git a/src/protocols/WaylandProtocol.hpp b/src/protocols/WaylandProtocol.hpp
index a87bd519..cc8a0e53 100644
--- a/src/protocols/WaylandProtocol.hpp
+++ b/src/protocols/WaylandProtocol.hpp
@@ -2,11 +2,18 @@
 
 #include "../defines.hpp"
 
+#include <functional>
+
 #define RESOURCE_OR_BAIL(resname)                                                                                                                                                  \
     const auto resname = (CWaylandResource*)wl_resource_get_user_data(resource);                                                                                                   \
     if (!resname)                                                                                                                                                                  \
         return;
 
+#define SP std::shared_ptr
+#define UP std::unique_ptr
+
+#define PROTO NProtocols
+
 class CWaylandResource {
   public:
     CWaylandResource(wl_client* client, const wl_interface* wlInterface, uint32_t version, uint32_t id);
@@ -24,12 +31,15 @@ class CWaylandResource {
     void*        data();
     void         setData(void* data);
 
+    void         setOnDestroyHandler(std::function<void(CWaylandResource* res)> fn);
+
   private:
-    bool         m_bImplementationSet = false;
-    bool         m_bDefunct           = false; // m_liResourceDestroy fired
-    wl_client*   m_pWLClient          = nullptr;
-    wl_resource* m_pWLResource        = nullptr;
-    void*        m_pData              = nullptr;
+    bool                                       m_bImplementationSet = false;
+    bool                                       m_bDefunct           = false; // m_liResourceDestroy fired
+    wl_client*                                 m_pWLClient          = nullptr;
+    wl_resource*                               m_pWLResource        = nullptr;
+    void*                                      m_pData              = nullptr;
+    std::function<void(CWaylandResource* res)> m_fOnDestroyHandler;
 };
 
 class IWaylandProtocol {
diff --git a/src/render/Renderer.hpp b/src/render/Renderer.hpp
index bc5ff43c..2e2b8b92 100644
--- a/src/render/Renderer.hpp
+++ b/src/render/Renderer.hpp
@@ -89,18 +89,16 @@ class CHyprRenderer {
     DAMAGETRACKINGMODES
     damageTrackingModeFromStr(const std::string&);
 
-    bool                                             attemptDirectScanout(CMonitor*);
-    void                                             setWindowScanoutMode(CWindow*);
-    void                                             initiateManualCrash();
+    bool             attemptDirectScanout(CMonitor*);
+    void             setWindowScanoutMode(CWindow*);
+    void             initiateManualCrash();
 
-    bool                                             m_bCrashingInProgress = false;
-    float                                            m_fCrashingDistort    = 0.5f;
-    wl_event_source*                                 m_pCrashingLoop       = nullptr;
-    wl_event_source*                                 m_pCursorTicker       = nullptr;
+    bool             m_bCrashingInProgress = false;
+    float            m_fCrashingDistort    = 0.5f;
+    wl_event_source* m_pCrashingLoop       = nullptr;
+    wl_event_source* m_pCursorTicker       = nullptr;
 
-    std::vector<std::unique_ptr<STearingController>> m_vTearingControllers;
-
-    CTimer                                           m_tRenderTimer;
+    CTimer           m_tRenderTimer;
 
     struct {
         int                         hotspotX;

commit cfec50c9e94915a9acc02f8da6b5a2e7c7ee2415
Author: Vaxry <vaxry@vaxry.net>
Date:   Sat Apr 20 00:08:49 2024 +0100

    tearing-control: search through all valid windows
    
    ref #5655

diff --git a/src/protocols/TearingControl.cpp b/src/protocols/TearingControl.cpp
index 0ed495bd..f3c17bfb 100644
--- a/src/protocols/TearingControl.cpp
+++ b/src/protocols/TearingControl.cpp
@@ -86,7 +86,12 @@ CTearingControl::CTearingControl(SP<CWaylandResource> resource_, wlr_surface* su
     resource->setData(this);
     resource->setOnDestroyHandler([](CWaylandResource* res) { PROTO::tearing->onControllerDestroy(reinterpret_cast<CTearingControl*>(res->data())); });
 
-    pWindow = g_pCompositor->getWindowFromSurface(surf_);
+    for (auto& w : g_pCompositor->m_vWindows) {
+        if (w->m_pWLSurface.wlr() == surf_) {
+            pWindow = w.get();
+            break;
+        }
+    }
 }
 
 void CTearingControl::onHint(uint32_t hint_) {

commit e6fad8ef1780bda1df87c9c467e12a7fd3edef4e
Author: thejch <66577496+thejch@users.noreply.github.com>
Date:   Fri Apr 19 18:20:16 2024 -0700

    config: merge all rules set for the same workspace selection (#5656)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index b2d82348..f959e3a0 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -970,39 +970,45 @@ SWorkspaceRule CConfigManager::getWorkspaceRuleFor(PHLWORKSPACE pWorkspace) {
         if (!pWorkspace->matchesStaticSelector(rule.workspaceString))
             continue;
 
-        if (rule.isDefault)
-            mergedRule.isDefault = true;
-        if (rule.isPersistent)
-            mergedRule.isPersistent = true;
-        if (rule.gapsIn.has_value())
-            mergedRule.gapsIn = rule.gapsIn;
-        if (rule.gapsOut.has_value())
-            mergedRule.gapsOut = rule.gapsOut;
-        if (rule.borderSize.has_value())
-            mergedRule.borderSize = rule.borderSize;
-        if (rule.border.has_value())
-            mergedRule.border = rule.border;
-        if (rule.rounding.has_value())
-            mergedRule.rounding = rule.rounding;
-        if (rule.decorate.has_value())
-            mergedRule.decorate = rule.decorate;
-        if (rule.shadow.has_value())
-            mergedRule.shadow = rule.shadow;
-        if (rule.onCreatedEmptyRunCmd.has_value())
-            mergedRule.onCreatedEmptyRunCmd = rule.onCreatedEmptyRunCmd;
-        if (rule.defaultName.has_value())
-            mergedRule.defaultName = rule.defaultName;
-
-        if (!rule.layoutopts.empty()) {
-            for (const auto& layoutopt : rule.layoutopts) {
-                mergedRule.layoutopts[layoutopt.first] = layoutopt.second;
-            }
-        }
+        mergedRule = mergeWorkspaceRules(mergedRule, rule);
     }
 
     return mergedRule;
 }
 
+SWorkspaceRule CConfigManager::mergeWorkspaceRules(const SWorkspaceRule& rule1, const SWorkspaceRule& rule2) {
+    SWorkspaceRule mergedRule = rule1;
+
+    if (rule2.isDefault)
+        mergedRule.isDefault = true;
+    if (rule2.isPersistent)
+        mergedRule.isPersistent = true;
+    if (rule2.gapsIn.has_value())
+        mergedRule.gapsIn = rule2.gapsIn;
+    if (rule2.gapsOut.has_value())
+        mergedRule.gapsOut = rule2.gapsOut;
+    if (rule2.borderSize.has_value())
+        mergedRule.borderSize = rule2.borderSize;
+    if (rule2.border.has_value())
+        mergedRule.border = rule2.border;
+    if (rule2.rounding.has_value())
+        mergedRule.rounding = rule2.rounding;
+    if (rule2.decorate.has_value())
+        mergedRule.decorate = rule2.decorate;
+    if (rule2.shadow.has_value())
+        mergedRule.shadow = rule2.shadow;
+    if (rule2.onCreatedEmptyRunCmd.has_value())
+        mergedRule.onCreatedEmptyRunCmd = rule2.onCreatedEmptyRunCmd;
+    if (rule2.defaultName.has_value())
+        mergedRule.defaultName = rule2.defaultName;
+    if (!rule2.layoutopts.empty()) {
+        for (const auto& layoutopt : rule2.layoutopts) {
+            mergedRule.layoutopts[layoutopt.first] = layoutopt.second;
+        }
+    }
+    return mergedRule;
+}
+
 std::vector<SWindowRule> CConfigManager::getMatchingRules(CWindow* pWindow, bool dynamic, bool shadowExec) {
     if (!g_pCompositor->windowExists(pWindow))
         return std::vector<SWindowRule>();
@@ -2307,7 +2313,7 @@ std::optional<std::string> CConfigManager::handleWorkspaceRules(const std::strin
     if (IT == m_dWorkspaceRules.end())
         m_dWorkspaceRules.emplace_back(wsRule);
     else
-        *IT = wsRule;
+        *IT = mergeWorkspaceRules(*IT, wsRule);
 
     return {};
 }
diff --git a/src/config/ConfigManager.hpp b/src/config/ConfigManager.hpp
index afd8fa94..bdfd14d0 100644
--- a/src/config/ConfigManager.hpp
+++ b/src/config/ConfigManager.hpp
@@ -205,6 +205,7 @@ class CConfigManager {
     std::optional<std::string> verifyConfigExists();
     void                       postConfigReload(const Hyprlang::CParseResult& result);
     void                       reload();
+    SWorkspaceRule             mergeWorkspaceRules(const SWorkspaceRule&, const SWorkspaceRule&);
 };
 
 inline std::unique_ptr<CConfigManager> g_pConfigManager;

commit 3117efb592d38931800c845901837bc12ade1969
Author: Gabriel Ford <gabe@fordltc.net>
Date:   Sat Apr 20 11:26:48 2024 +0000

    config: Allow more sensible input options for enabling animations. (#5659)
    
    * Add check for on/off and true/false.
    
    * Cleanup feature and comment it out.
    
    * Use already created helper function for this.
    
    * Fix comparing int to char* ptr

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index f959e3a0..05694832 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -1786,12 +1786,15 @@ std::optional<std::string> CConfigManager::handleAnimation(const std::string& co
     PANIM->second.overridden = true;
     PANIM->second.pValues    = &PANIM->second;
 
-    // on/off
-    PANIM->second.internalEnabled = ARGS[1] == "1";
+    // This helper casts strings like "1", "true", "off", "yes"... to int.
+    int64_t enabledInt = configStringToInt(ARGS[1]) == 1;
 
-    if (ARGS[1] != "0" && ARGS[1] != "1")
+    // Checking that the int is 1 or 0 because the helper can return integers out of range.
+    if (enabledInt != 0 && enabledInt != 1)
         return "invalid animation on/off state";
 
+    PANIM->second.internalEnabled = configStringToInt(ARGS[1]) == 1;
+
     if (PANIM->second.internalEnabled) {
         // speed
         if (isNumber(ARGS[2], true)) {

commit 364f271cf63a9d40f624976d1ba4487e04ef6541
Author: Yaroslav <ilelkin@icloud.com>
Date:   Sat Apr 20 22:50:07 2024 +0500

    core: remove libsystemd dependency (#5660)
    
    * remove libsystemd dependency
    
    as per Lennart Poettering's advice:
    https://github.com/systemd/systemd/issues/32028#issuecomment-2031366922
    
    * fix naming for systemd helper functions
    
    * rename vars according to code style
    
    * Nix: update meson patch
    
    ---------
    
    Co-authored-by: Mihai Fufezan <mihai@fufexan.net>

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b056402a..000bcd3d 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -191,20 +191,8 @@ endif()
 if(NO_SYSTEMD)
     message(STATUS "SYSTEMD support is disabled...")
 else()
-    message(STATUS "SYSTEMD support is requested (NO_SYSTEMD not defined) checking deps...")
-    check_include_file("systemd/sd-daemon.h" SYSTEMDH)
-    if(SYSTEMDH)
-        pkg_check_modules(LIBSYSTEMD libsystemd)
-        if (LIBSYSTEMD_FOUND)
-            add_compile_definitions(USES_SYSTEMD)
-            target_link_libraries(Hyprland "${LIBSYSTEMD_LIBRARIES}")
-            message(STATUS "Systemd found")
-        else()
-            message(WARNING "Systemd support requested but systemd libraries were not found")
-        endif()
-    else()
-        message(WARNING "Systemd support requested but systemd headers were not found")
-    endif()
+    message(STATUS "SYSTEMD support is requested (NO_SYSTEMD not defined)...")
+    add_compile_definitions(USES_SYSTEMD)
 endif()
 
 set(CPACK_PROJECT_NAME ${PROJECT_NAME})
diff --git a/meson.build b/meson.build
index dd73cb92..40883073 100644
--- a/meson.build
+++ b/meson.build
@@ -52,14 +52,9 @@ endif
 
 backtrace_dep = cpp_compiler.find_library('execinfo', required: false)
 epoll_dep = dependency('epoll-shim', required: false) # timerfd on BSDs
-systemd_dep = dependency('libsystemd', required: get_option('systemd'))
 
 if get_option('systemd').enabled()
-  if systemd_dep.found()
-    add_project_arguments('-DUSES_SYSTEMD', language: 'cpp')
-  else
-  	error('Cannot enable systemd in Hyprland: libsystemd was not found')
-  endif
+  add_project_arguments('-DUSES_SYSTEMD', language: 'cpp')
 endif
 
 if get_option('legacy_renderer').enabled()
diff --git a/nix/patches/meson-build.patch b/nix/patches/meson-build.patch
index 5827e5c3..eb1d3f9a 100644
--- a/nix/patches/meson-build.patch
+++ b/nix/patches/meson-build.patch
@@ -1,5 +1,5 @@
 diff --git a/meson.build b/meson.build
-index 1d2c7f9f..c5ef4e67 100644
+index 40883073..d8f2e536 100644
 --- a/meson.build
 +++ b/meson.build
 @@ -33,20 +33,7 @@ if cpp_compiler.check_header('execinfo.h')
@@ -24,7 +24,7 @@ index 1d2c7f9f..c5ef4e67 100644
    add_project_arguments('-DNO_XWAYLAND', language: 'cpp')
  endif
  
-@@ -69,8 +56,6 @@ if get_option('buildtype') == 'debug'
+@@ -65,8 +52,6 @@ if get_option('buildtype') == 'debug'
    add_project_arguments('-DHYPRLAND_DEBUG', language: 'cpp')
  endif
  
@@ -34,7 +34,7 @@ index 1d2c7f9f..c5ef4e67 100644
  headers = globber.stdout().strip().split('\n')
  foreach file : headers
 diff --git a/src/meson.build b/src/meson.build
-index 45701f5f..3505cefe 100644
+index 15c69552..327aa4fb 100644
 --- a/src/meson.build
 +++ b/src/meson.build
 @@ -9,7 +9,7 @@ executable('Hyprland', src,
@@ -46,7 +46,7 @@ index 45701f5f..3505cefe 100644
      dependency('cairo'),
      dependency('hyprcursor'),
      dependency('hyprlang', version: '>= 0.3.2'),
-@@ -17,11 +17,11 @@ executable('Hyprland', src,
+@@ -17,10 +17,10 @@ executable('Hyprland', src,
      dependency('egl'),
      dependency('xkbcommon'),
      dependency('libinput'),
@@ -54,7 +54,6 @@ index 45701f5f..3505cefe 100644
 +    dependency('xcb', required: get_option('xwayland')),
      backtrace_dep,
      epoll_dep,
-     systemd_dep,
 -    udis86,
 +    dependency('udis86'),
  
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 6e739c5f..26a22299 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -8,7 +8,7 @@
 #include "debug/HyprCtl.hpp"
 #include "debug/CrashReporter.hpp"
 #ifdef USES_SYSTEMD
-#include <systemd/sd-daemon.h> // for sd_notify
+#include <helpers/SdDaemon.hpp> // for SdNotify
 #endif
 #include <ranges>
 #include "helpers/VarList.hpp"
@@ -384,8 +384,8 @@ void CCompositor::cleanup() {
     Debug::shuttingDown = true;
 
 #ifdef USES_SYSTEMD
-    if (sd_booted() > 0 && !envEnabled("HYPRLAND_NO_SD_NOTIFY"))
-        sd_notify(0, "STOPPING=1");
+    if (Systemd::SdBooted() > 0 && !envEnabled("HYPRLAND_NO_SD_NOTIFY"))
+        Systemd::SdNotify(0, "STOPPING=1");
 #endif
 
     // unload all remaining plugins while the compositor is
@@ -614,10 +614,10 @@ void CCompositor::startCompositor() {
     g_pHyprRenderer->setCursorFromName("left_ptr");
 
 #ifdef USES_SYSTEMD
-    if (sd_booted() > 0) {
+    if (Systemd::SdBooted() > 0) {
         // tell systemd that we are ready so it can start other bond, following, related units
         if (!envEnabled("HYPRLAND_NO_SD_NOTIFY"))
-            sd_notify(0, "READY=1");
+            Systemd::SdNotify(0, "READY=1");
     } else
         Debug::log(LOG, "systemd integration is baked in but system itself is not booted à la systemd!");
 #endif
diff --git a/src/helpers/SdDaemon.cpp b/src/helpers/SdDaemon.cpp
new file mode 100644
index 00000000..0835637a
--- /dev/null
+++ b/src/helpers/SdDaemon.cpp
@@ -0,0 +1,58 @@
+#include "SdDaemon.hpp"
+
+#include <memory>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+namespace Systemd {
+    int SdBooted(void) {
+        if (!faccessat(AT_FDCWD, "/run/systemd/system/", F_OK, AT_SYMLINK_NOFOLLOW))
+            return true;
+
+        if (errno == ENOENT)
+            return false;
+
+        return -errno;
+    }
+
+    int SdNotify(int unsetEnvironment, const char* state) {
+        int fd = socket(AF_UNIX, SOCK_DGRAM, 0);
+        if (fd == -1)
+            return -errno;
+
+        constexpr char envVar[] = "NOTIFY_SOCKET";
+
+        auto           cleanup = [unsetEnvironment, envVar](int* fd) {
+            if (unsetEnvironment)
+                unsetenv(envVar);
+            close(*fd);
+        };
+        std::unique_ptr<int, decltype(cleanup)> fdCleaup(&fd, cleanup);
+
+        const char*                             addr = getenv(envVar);
+        if (!addr)
+            return 0;
+
+        // address length must be at most this; see man 7 unix
+        size_t             addrLen = strnlen(addr, 107);
+
+        struct sockaddr_un unixAddr;
+        unixAddr.sun_family = AF_UNIX;
+        strncpy(unixAddr.sun_path, addr, addrLen);
+        if (unixAddr.sun_path[0] == '@')
+            unixAddr.sun_path[0] = '\0';
+
+        if (!connect(fd, (const sockaddr*)&unixAddr, sizeof(struct sockaddr_un)))
+            return 1;
+
+        // arbitrary value which seems to be enough for s-d messages
+        size_t stateLen = strnlen(state, 128);
+        if (write(fd, state, stateLen) >= 0)
+            return 1;
+
+        return -errno;
+    }
+}
diff --git a/src/helpers/SdDaemon.hpp b/src/helpers/SdDaemon.hpp
new file mode 100644
index 00000000..7b2b5de1
--- /dev/null
+++ b/src/helpers/SdDaemon.hpp
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace Systemd {
+    int SdBooted(void);
+    int SdNotify(int unset_environment, const char* state);
+}
diff --git a/src/meson.build b/src/meson.build
index d490cddb..15c69552 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -20,7 +20,6 @@ executable('Hyprland', src,
     xcb_dep,
     backtrace_dep,
     epoll_dep,
-    systemd_dep,
     udis86,
 
     dependency('pixman-1'),

commit 0eef4ad9918e59162b4b7a5a2298f750a5893427
Author: Vaxry <vaxry@vaxry.net>
Date:   Sat Apr 20 20:16:42 2024 +0100

    HookSystem: improve callback safety

diff --git a/src/debug/HyprNotificationOverlay.cpp b/src/debug/HyprNotificationOverlay.cpp
index dffa6889..2f00d978 100644
--- a/src/debug/HyprNotificationOverlay.cpp
+++ b/src/debug/HyprNotificationOverlay.cpp
@@ -3,7 +3,7 @@
 #include <pango/pangocairo.h>
 
 CHyprNotificationOverlay::CHyprNotificationOverlay() {
-    g_pHookSystem->hookDynamic("focusedMon", [&](void* self, SCallbackInfo& info, std::any param) {
+    static auto P = g_pHookSystem->hookDynamic("focusedMon", [&](void* self, SCallbackInfo& info, std::any param) {
         if (m_dNotifications.size() == 0)
             return;
 
diff --git a/src/desktop/Workspace.hpp b/src/desktop/Workspace.hpp
index db2fe25e..0008699b 100644
--- a/src/desktop/Workspace.hpp
+++ b/src/desktop/Workspace.hpp
@@ -78,11 +78,11 @@ class CWorkspace {
     void        markInert();
 
   private:
-    void                      init(PHLWORKSPACE self);
+    void                              init(PHLWORKSPACE self);
 
-    HOOK_CALLBACK_FN*         m_pFocusedWindowHook = nullptr;
-    bool                      m_bInert             = true;
-    std::weak_ptr<CWorkspace> m_pSelf;
+    std::shared_ptr<HOOK_CALLBACK_FN> m_pFocusedWindowHook;
+    bool                              m_bInert = true;
+    std::weak_ptr<CWorkspace>         m_pSelf;
 };
 
 inline bool valid(const PHLWORKSPACE& ref) {
diff --git a/src/helpers/WLClasses.hpp b/src/helpers/WLClasses.hpp
index b85517e8..89af21c3 100644
--- a/src/helpers/WLClasses.hpp
+++ b/src/helpers/WLClasses.hpp
@@ -270,9 +270,9 @@ struct STabletPad {
 };
 
 struct SIdleInhibitor {
-    wlr_idle_inhibitor_v1* pWlrInhibitor   = nullptr;
-    CWindow*               pWindow         = nullptr;
-    HOOK_CALLBACK_FN*      onWindowDestroy = nullptr;
+    wlr_idle_inhibitor_v1*            pWlrInhibitor = nullptr;
+    CWindow*                          pWindow       = nullptr;
+    std::shared_ptr<HOOK_CALLBACK_FN> onWindowDestroy;
 
     DYNLISTENER(Destroy);
 
diff --git a/src/hyprerror/HyprError.cpp b/src/hyprerror/HyprError.cpp
index de386097..7a9e9e87 100644
--- a/src/hyprerror/HyprError.cpp
+++ b/src/hyprerror/HyprError.cpp
@@ -6,7 +6,7 @@ CHyprError::CHyprError() {
     m_fFadeOpacity.create(AVARTYPE_FLOAT, g_pConfigManager->getAnimationPropertyConfig("fadeIn"), AVARDAMAGE_NONE);
     m_fFadeOpacity.registerVar();
 
-    g_pHookSystem->hookDynamic("focusedMon", [&](void* self, SCallbackInfo& info, std::any param) {
+    static auto P = g_pHookSystem->hookDynamic("focusedMon", [&](void* self, SCallbackInfo& info, std::any param) {
         if (!m_bIsCreated)
             return;
 
@@ -14,7 +14,7 @@ CHyprError::CHyprError() {
         m_bMonitorChanged = true;
     });
 
-    g_pHookSystem->hookDynamic("preRender", [&](void* self, SCallbackInfo& info, std::any param) {
+    static auto P2 = g_pHookSystem->hookDynamic("preRender", [&](void* self, SCallbackInfo& info, std::any param) {
         if (!m_bIsCreated)
             return;
 
diff --git a/src/managers/CursorManager.cpp b/src/managers/CursorManager.cpp
index 627ca5e1..68f020c2 100644
--- a/src/managers/CursorManager.cpp
+++ b/src/managers/CursorManager.cpp
@@ -50,7 +50,7 @@ CCursorManager::CCursorManager() {
 
     updateTheme();
 
-    g_pHookSystem->hookDynamic("monitorLayoutChanged", [this](void* self, SCallbackInfo& info, std::any param) { this->updateTheme(); });
+    static auto P = g_pHookSystem->hookDynamic("monitorLayoutChanged", [this](void* self, SCallbackInfo& info, std::any param) { this->updateTheme(); });
 }
 
 void CCursorManager::dropBufferRef(CCursorManager::CCursorBuffer* ref) {
diff --git a/src/managers/HookSystemManager.cpp b/src/managers/HookSystemManager.cpp
index 48c300cb..11007f1a 100644
--- a/src/managers/HookSystemManager.cpp
+++ b/src/managers/HookSystemManager.cpp
@@ -7,30 +7,28 @@ CHookSystemManager::CHookSystemManager() {
 }
 
 // returns the pointer to the function
-HOOK_CALLBACK_FN* CHookSystemManager::hookDynamic(const std::string& event, HOOK_CALLBACK_FN fn, HANDLE handle) {
-    const auto PVEC = getVecForEvent(event);
-    const auto PFN  = &m_lCallbackFunctions.emplace_back(fn);
-    PVEC->emplace_back(SCallbackFNPtr{PFN, handle});
-    return PFN;
+std::shared_ptr<HOOK_CALLBACK_FN> CHookSystemManager::hookDynamic(const std::string& event, HOOK_CALLBACK_FN fn, HANDLE handle) {
+    std::shared_ptr<HOOK_CALLBACK_FN> hookFN = std::make_shared<HOOK_CALLBACK_FN>(fn);
+    m_mRegisteredHooks[event].emplace_back(SCallbackFNPtr{.fn = hookFN, .handle = handle});
+    return hookFN;
 }
 
-void CHookSystemManager::hookStatic(const std::string& event, HOOK_CALLBACK_FN* fn, HANDLE handle) {
-    const auto PVEC = getVecForEvent(event);
-    PVEC->emplace_back(SCallbackFNPtr{fn, handle});
-}
+void CHookSystemManager::unhook(std::shared_ptr<HOOK_CALLBACK_FN> fn) {
+    for (auto& [k, v] : m_mRegisteredHooks) {
+        std::erase_if(v, [&](const auto& other) {
+            std::shared_ptr<HOOK_CALLBACK_FN> fn_ = other.fn.lock();
 
-void CHookSystemManager::unhook(HOOK_CALLBACK_FN* fn) {
-    std::erase_if(m_lCallbackFunctions, [&](const auto& other) { return &other == fn; });
-    for (auto& [k, v] : m_lpRegisteredHooks) {
-        std::erase_if(v, [&](const auto& other) { return other.fn == fn; });
+            return fn_.get() == fn.get();
+        });
     }
 }
 
-void CHookSystemManager::emit(const std::vector<SCallbackFNPtr>* callbacks, SCallbackInfo& info, std::any data) {
+void CHookSystemManager::emit(std::vector<SCallbackFNPtr>* const callbacks, SCallbackInfo& info, std::any data) {
     if (callbacks->empty())
         return;
 
     std::vector<HANDLE> faultyHandles;
+    bool                needsDeadCleanup = false;
 
     for (auto& cb : *callbacks) {
 
@@ -38,7 +36,11 @@ void CHookSystemManager::emit(const std::vector<SCallbackFNPtr>* callbacks, SCal
 
         if (!cb.handle) {
             // we don't guard hl hooks
-            (*cb.fn)(cb.fn, info, data);
+
+            if (std::shared_ptr<HOOK_CALLBACK_FN> fn = cb.fn.lock())
+                (*fn)(fn.get(), info, data);
+            else
+                needsDeadCleanup = true;
             continue;
         }
 
@@ -48,9 +50,12 @@ void CHookSystemManager::emit(const std::vector<SCallbackFNPtr>* callbacks, SCal
             continue;
 
         try {
-            if (!setjmp(m_jbHookFaultJumpBuf))
-                (*cb.fn)(cb.fn, info, data);
-            else {
+            if (!setjmp(m_jbHookFaultJumpBuf)) {
+                if (std::shared_ptr<HOOK_CALLBACK_FN> fn = cb.fn.lock())
+                    (*fn)(fn.get(), info, data);
+                else
+                    needsDeadCleanup = true;
+            } else {
                 // this module crashed.
                 throw std::exception();
             }
@@ -61,6 +66,9 @@ void CHookSystemManager::emit(const std::vector<SCallbackFNPtr>* callbacks, SCal
         }
     }
 
+    if (needsDeadCleanup)
+        std::erase_if(*callbacks, [](const auto& fn) { return !fn.fn.lock(); });
+
     if (!faultyHandles.empty()) {
         for (auto& h : faultyHandles)
             g_pPluginSystem->unloadPlugin(g_pPluginSystem->getPluginByHandle(h), true);
@@ -68,12 +76,8 @@ void CHookSystemManager::emit(const std::vector<SCallbackFNPtr>* callbacks, SCal
 }
 
 std::vector<SCallbackFNPtr>* CHookSystemManager::getVecForEvent(const std::string& event) {
-    auto IT = std::find_if(m_lpRegisteredHooks.begin(), m_lpRegisteredHooks.end(), [&](const auto& other) { return other.first == event; });
-
-    if (IT != m_lpRegisteredHooks.end())
-        return &IT->second;
-
-    Debug::log(LOG, "[hookSystem] New hook event registered: {}", event);
+    if (!m_mRegisteredHooks.contains(event))
+        Debug::log(LOG, "[hookSystem] New hook event registered: {}", event);
 
-    return &m_lpRegisteredHooks.emplace_back(std::make_pair<>(event, std::vector<SCallbackFNPtr>{})).second;
+    return &m_mRegisteredHooks[event];
 }
\ No newline at end of file
diff --git a/src/managers/HookSystemManager.hpp b/src/managers/HookSystemManager.hpp
index ca8e9006..4b27fadf 100644
--- a/src/managers/HookSystemManager.hpp
+++ b/src/managers/HookSystemManager.hpp
@@ -16,8 +16,8 @@
 typedef std::function<void(void*, SCallbackInfo& info, std::any data)> HOOK_CALLBACK_FN;
 
 struct SCallbackFNPtr {
-    HOOK_CALLBACK_FN* fn     = nullptr;
-    HANDLE            handle = nullptr;
+    std::weak_ptr<HOOK_CALLBACK_FN> fn;
+    HANDLE                          handle = nullptr;
 };
 
 #define EMIT_HOOK_EVENT(name, param)                                                                                                                                               \
@@ -40,21 +40,21 @@ class CHookSystemManager {
   public:
     CHookSystemManager();
 
-    // returns the pointer to the function
-    HOOK_CALLBACK_FN*            hookDynamic(const std::string& event, HOOK_CALLBACK_FN fn, HANDLE handle = nullptr);
-    void                         hookStatic(const std::string& event, HOOK_CALLBACK_FN* fn, HANDLE handle = nullptr);
-    void                         unhook(HOOK_CALLBACK_FN* fn);
+    // returns the pointer to the function.
+    // losing this pointer (letting it get destroyed)
+    // will equal to unregistering the callback.
+    [[nodiscard("Losing this pointer instantly unregisters the callback")]] std::shared_ptr<HOOK_CALLBACK_FN> hookDynamic(const std::string& event, HOOK_CALLBACK_FN fn,
+                                                                                                                          HANDLE handle = nullptr);
+    void                                                                                                      unhook(std::shared_ptr<HOOK_CALLBACK_FN> fn);
 
-    void                         emit(const std::vector<SCallbackFNPtr>* callbacks, SCallbackInfo& info, std::any data = 0);
+    void                         emit(std::vector<SCallbackFNPtr>* const callbacks, SCallbackInfo& info, std::any data = 0);
     std::vector<SCallbackFNPtr>* getVecForEvent(const std::string& event);
 
     bool                         m_bCurrentEventPlugin = false;
     jmp_buf                      m_jbHookFaultJumpBuf;
 
   private:
-    // todo: this is slow. Maybe static ptrs should be somehow allowed. unique ptr for vec?
-    std::list<std::pair<std::string, std::vector<SCallbackFNPtr>>> m_lpRegisteredHooks;
-    std::list<HOOK_CALLBACK_FN>                                    m_lCallbackFunctions;
+    std::unordered_map<std::string, std::vector<SCallbackFNPtr>> m_mRegisteredHooks;
 };
 
 inline std::unique_ptr<CHookSystemManager> g_pHookSystem;
\ No newline at end of file
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 1758f333..39ede5d4 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -85,7 +85,7 @@ CKeybindManager::CKeybindManager() {
 
     m_tScrollTimer.reset();
 
-    g_pHookSystem->hookDynamic("configReloaded", [this](void* hk, SCallbackInfo& info, std::any param) {
+    static auto P = g_pHookSystem->hookDynamic("configReloaded", [this](void* hk, SCallbackInfo& info, std::any param) {
         // clear cuz realloc'd
         m_pActiveKeybind = nullptr;
         m_vPressedSpecialBinds.clear();
diff --git a/src/managers/input/InputMethodRelay.cpp b/src/managers/input/InputMethodRelay.cpp
index a2d75f20..17da87ea 100644
--- a/src/managers/input/InputMethodRelay.cpp
+++ b/src/managers/input/InputMethodRelay.cpp
@@ -3,7 +3,7 @@
 #include "../../Compositor.hpp"
 
 CInputMethodRelay::CInputMethodRelay() {
-    g_pHookSystem->hookDynamic("keyboardFocus", [&](void* self, SCallbackInfo& info, std::any param) { onKeyboardFocus(std::any_cast<wlr_surface*>(param)); });
+    static auto P = g_pHookSystem->hookDynamic("keyboardFocus", [&](void* self, SCallbackInfo& info, std::any param) { onKeyboardFocus(std::any_cast<wlr_surface*>(param)); });
 }
 
 void CInputMethodRelay::onNewIME(wlr_input_method_v2* pIME) {
diff --git a/src/plugins/PluginAPI.cpp b/src/plugins/PluginAPI.cpp
index 78870666..c89918f5 100644
--- a/src/plugins/PluginAPI.cpp
+++ b/src/plugins/PluginAPI.cpp
@@ -13,30 +13,18 @@ APICALL const char* __hyprland_api_get_hash() {
     return GIT_COMMIT_HASH;
 }
 
-APICALL bool HyprlandAPI::registerCallbackStatic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN* fn) {
-    auto* const PLUGIN = g_pPluginSystem->getPluginByHandle(handle);
-
-    if (!PLUGIN)
-        return false;
-
-    g_pHookSystem->hookStatic(event, fn, handle);
-    PLUGIN->registeredCallbacks.emplace_back(std::make_pair<>(event, fn));
-
-    return true;
-}
-
-APICALL HOOK_CALLBACK_FN* HyprlandAPI::registerCallbackDynamic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN fn) {
+APICALL std::shared_ptr<HOOK_CALLBACK_FN> HyprlandAPI::registerCallbackDynamic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN fn) {
     auto* const PLUGIN = g_pPluginSystem->getPluginByHandle(handle);
 
     if (!PLUGIN)
         return nullptr;
 
-    auto* const PFN = g_pHookSystem->hookDynamic(event, fn, handle);
+    auto PFN = g_pHookSystem->hookDynamic(event, fn, handle);
     PLUGIN->registeredCallbacks.emplace_back(std::make_pair<>(event, PFN));
     return PFN;
 }
 
-APICALL bool HyprlandAPI::unregisterCallback(HANDLE handle, HOOK_CALLBACK_FN* fn) {
+APICALL bool HyprlandAPI::unregisterCallback(HANDLE handle, std::shared_ptr<HOOK_CALLBACK_FN> fn) {
     auto* const PLUGIN = g_pPluginSystem->getPluginByHandle(handle);
 
     if (!PLUGIN)
diff --git a/src/plugins/PluginAPI.hpp b/src/plugins/PluginAPI.hpp
index 75dca24e..62db8e3b 100644
--- a/src/plugins/PluginAPI.hpp
+++ b/src/plugins/PluginAPI.hpp
@@ -132,28 +132,20 @@ namespace HyprlandAPI {
     */
     APICALL Hyprlang::CConfigValue* getConfigValue(HANDLE handle, const std::string& name);
 
-    /*
-        Register a static (pointer) callback to a selected event.
-        Pointer must be kept valid until unregisterCallback() is called.
-
-        returns: true on success, false on fail
-    */
-    APICALL bool registerCallbackStatic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN* fn);
-
     /*
         Register a dynamic (function) callback to a selected event.
         Pointer will be free'd by Hyprland on unregisterCallback().
 
         returns: a pointer to the newly allocated function. nullptr on fail.
     */
-    APICALL HOOK_CALLBACK_FN* registerCallbackDynamic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN fn);
+    APICALL std::shared_ptr<HOOK_CALLBACK_FN> registerCallbackDynamic(HANDLE handle, const std::string& event, HOOK_CALLBACK_FN fn);
 
     /*
         Unregisters a callback. If the callback was dynamic, frees the memory.
 
         returns: true on success, false on fail
     */
-    APICALL bool unregisterCallback(HANDLE handle, HOOK_CALLBACK_FN* fn);
+    APICALL bool unregisterCallback(HANDLE handle, std::shared_ptr<HOOK_CALLBACK_FN> fn);
 
     /*
         Calls a hyprctl command.
diff --git a/src/plugins/PluginSystem.hpp b/src/plugins/PluginSystem.hpp
index ce2c2bb2..c618489a 100644
--- a/src/plugins/PluginSystem.hpp
+++ b/src/plugins/PluginSystem.hpp
@@ -8,22 +8,22 @@ class IHyprWindowDecoration;
 
 class CPlugin {
   public:
-    std::string                                            name        = "";
-    std::string                                            description = "";
-    std::string                                            author      = "";
-    std::string                                            version     = "";
+    std::string                                                            name        = "";
+    std::string                                                            description = "";
+    std::string                                                            author      = "";
+    std::string                                                            version     = "";
 
-    std::string                                            path = "";
+    std::string                                                            path = "";
 
-    bool                                                   m_bLoadedWithConfig = false;
+    bool                                                                   m_bLoadedWithConfig = false;
 
-    HANDLE                                                 m_pHandle = nullptr;
+    HANDLE                                                                 m_pHandle = nullptr;
 
-    std::vector<IHyprLayout*>                              registeredLayouts;
-    std::vector<IHyprWindowDecoration*>                    registeredDecorations;
-    std::vector<std::pair<std::string, HOOK_CALLBACK_FN*>> registeredCallbacks;
-    std::vector<std::string>                               registeredDispatchers;
-    std::vector<std::shared_ptr<SHyprCtlCommand>>          registeredHyprctlCommands;
+    std::vector<IHyprLayout*>                                              registeredLayouts;
+    std::vector<IHyprWindowDecoration*>                                    registeredDecorations;
+    std::vector<std::pair<std::string, std::shared_ptr<HOOK_CALLBACK_FN>>> registeredCallbacks;
+    std::vector<std::string>                                               registeredDispatchers;
+    std::vector<std::shared_ptr<SHyprCtlCommand>>                          registeredHyprctlCommands;
 };
 
 class CPluginSystem {
diff --git a/src/protocols/Screencopy.hpp b/src/protocols/Screencopy.hpp
index 0c709c7b..8facc53e 100644
--- a/src/protocols/Screencopy.hpp
+++ b/src/protocols/Screencopy.hpp
@@ -20,21 +20,21 @@ class CScreencopyClient {
     CScreencopyClient();
     ~CScreencopyClient();
 
-    int               ref      = 0;
-    wl_resource*      resource = nullptr;
+    int                               ref      = 0;
+    wl_resource*                      resource = nullptr;
 
-    eClientOwners     clientOwner = CLIENT_SCREENCOPY;
+    eClientOwners                     clientOwner = CLIENT_SCREENCOPY;
 
-    int               frameCounter           = 0;
-    int               framesInLastHalfSecond = 0;
-    CTimer            lastMeasure;
-    CTimer            lastFrame;
-    bool              sentScreencast = false;
+    int                               frameCounter           = 0;
+    int                               framesInLastHalfSecond = 0;
+    CTimer                            lastMeasure;
+    CTimer                            lastFrame;
+    bool                              sentScreencast = false;
 
-    void              onTick();
-    HOOK_CALLBACK_FN* tickCallback = nullptr;
+    void                              onTick();
+    std::shared_ptr<HOOK_CALLBACK_FN> tickCallback;
 
-    bool              operator==(const CScreencopyClient& other) const {
+    bool                              operator==(const CScreencopyClient& other) const {
         return resource == other.resource;
     }
 };
diff --git a/src/protocols/TearingControl.cpp b/src/protocols/TearingControl.cpp
index f3c17bfb..2a2606ff 100644
--- a/src/protocols/TearingControl.cpp
+++ b/src/protocols/TearingControl.cpp
@@ -17,7 +17,7 @@ static void getTearingControl(wl_client* client, wl_resource* resource, uint32_t
 //
 
 CTearingControlProtocol::CTearingControlProtocol(const wl_interface* iface, const int& ver, const std::string& name) : IWaylandProtocol(iface, ver, name) {
-    g_pHookSystem->hookDynamic("destroyWindow", [this](void* self, SCallbackInfo& info, std::any param) { this->onWindowDestroy(std::any_cast<CWindow*>(param)); });
+    static auto P = g_pHookSystem->hookDynamic("destroyWindow", [this](void* self, SCallbackInfo& info, std::any param) { this->onWindowDestroy(std::any_cast<CWindow*>(param)); });
 }
 
 static const struct wp_tearing_control_manager_v1_interface MANAGER_IMPL = {
diff --git a/src/protocols/XDGOutput.cpp b/src/protocols/XDGOutput.cpp
index c097b551..99e803cd 100644
--- a/src/protocols/XDGOutput.cpp
+++ b/src/protocols/XDGOutput.cpp
@@ -59,9 +59,9 @@ void CXDGOutputProtocol::bindManager(wl_client* client, void* data, uint32_t ver
 }
 
 CXDGOutputProtocol::CXDGOutputProtocol(const wl_interface* iface, const int& ver, const std::string& name) : IWaylandProtocol(iface, ver, name) {
-    g_pHookSystem->hookDynamic("monitorLayoutChanged", [this](void* self, SCallbackInfo& info, std::any param) { this->updateAllOutputs(); });
-    g_pHookSystem->hookDynamic("configReloaded", [this](void* self, SCallbackInfo& info, std::any param) { this->updateAllOutputs(); });
-    g_pHookSystem->hookDynamic("monitorRemoved", [this](void* self, SCallbackInfo& info, std::any param) {
+    static auto P  = g_pHookSystem->hookDynamic("monitorLayoutChanged", [this](void* self, SCallbackInfo& info, std::any param) { this->updateAllOutputs(); });
+    static auto P2 = g_pHookSystem->hookDynamic("configReloaded", [this](void* self, SCallbackInfo& info, std::any param) { this->updateAllOutputs(); });
+    static auto P3 = g_pHookSystem->hookDynamic("monitorRemoved", [this](void* self, SCallbackInfo& info, std::any param) {
         const auto PMONITOR = std::any_cast<CMonitor*>(param);
         std::erase_if(m_vXDGOutputs, [&](const auto& other) {
             const auto REMOVE = other->monitor == PMONITOR;
diff --git a/src/render/OpenGL.cpp b/src/render/OpenGL.cpp
index 9e3fb47b..981541b2 100644
--- a/src/render/OpenGL.cpp
+++ b/src/render/OpenGL.cpp
@@ -52,7 +52,7 @@ CHyprOpenGLImpl::CHyprOpenGLImpl() {
     Debug::log(WARN, "!RENDERER: Using the legacy GLES2 renderer!");
 #endif
 
-    g_pHookSystem->hookDynamic("preRender", [&](void* self, SCallbackInfo& info, std::any data) { preRender(std::any_cast<CMonitor*>(data)); });
+    static auto P = g_pHookSystem->hookDynamic("preRender", [&](void* self, SCallbackInfo& info, std::any data) { preRender(std::any_cast<CMonitor*>(data)); });
 
     RASSERT(eglMakeCurrent(wlr_egl_get_display(g_pCompositor->m_sWLREGL), EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT), "Couldn't unset current EGL!");
 
diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 672adb1d..a51901b4 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -60,7 +60,7 @@ CHyprRenderer::CHyprRenderer() {
 
     // cursor hiding stuff
 
-    g_pHookSystem->hookDynamic("keyPress", [&](void* self, SCallbackInfo& info, std::any param) {
+    static auto P = g_pHookSystem->hookDynamic("keyPress", [&](void* self, SCallbackInfo& info, std::any param) {
         if (m_sCursorHiddenConditions.hiddenOnKeyboard)
             return;
 
@@ -68,7 +68,7 @@ CHyprRenderer::CHyprRenderer() {
         ensureCursorRenderingMode();
     });
 
-    g_pHookSystem->hookDynamic("mouseMove", [&](void* self, SCallbackInfo& info, std::any param) {
+    static auto P2 = g_pHookSystem->hookDynamic("mouseMove", [&](void* self, SCallbackInfo& info, std::any param) {
         if (!m_sCursorHiddenConditions.hiddenOnKeyboard && m_sCursorHiddenConditions.hiddenOnTouch == g_pInputManager->m_bLastInputTouch &&
             !m_sCursorHiddenConditions.hiddenOnTimeout)
             return;
diff --git a/src/render/decorations/DecorationPositioner.cpp b/src/render/decorations/DecorationPositioner.cpp
index 145a697b..4837382a 100644
--- a/src/render/decorations/DecorationPositioner.cpp
+++ b/src/render/decorations/DecorationPositioner.cpp
@@ -2,12 +2,12 @@
 #include "../../Compositor.hpp"
 
 CDecorationPositioner::CDecorationPositioner() {
-    g_pHookSystem->hookDynamic("closeWindow", [this](void* call, SCallbackInfo& info, std::any data) {
+    static auto P = g_pHookSystem->hookDynamic("closeWindow", [this](void* call, SCallbackInfo& info, std::any data) {
         auto* const PWINDOW = std::any_cast<CWindow*>(data);
         this->onWindowUnmap(PWINDOW);
     });
 
-    g_pHookSystem->hookDynamic("openWindow", [this](void* call, SCallbackInfo& info, std::any data) {
+    static auto P2 = g_pHookSystem->hookDynamic("openWindow", [this](void* call, SCallbackInfo& info, std::any data) {
         auto* const PWINDOW = std::any_cast<CWindow*>(data);
         this->onWindowMap(PWINDOW);
     });

commit 7b42f4175b96702d9b2e0117242dd96b57edfd36
Author: thejch <66577496+thejch@users.noreply.github.com>
Date:   Sat Apr 20 17:50:08 2024 -0700

    workspace: Add fullscreen workspace selector (#5640)
    
    * add fullscreen selector
    
    * use stoi

diff --git a/src/desktop/Workspace.cpp b/src/desktop/Workspace.cpp
index 25015c5a..7ab75fd5 100644
--- a/src/desktop/Workspace.cpp
+++ b/src/desktop/Workspace.cpp
@@ -252,6 +252,8 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
             // w - windowCount: w[1-4] or w[1], optional flag t or f for tiled or floating and
             //                  flag g to count groups instead of windows, e.g. w[t1-2], w[fg4]
             //                  flag v will count only visible windows
+            // f - fullscreen state : f[-1], f[0], f[1], or f[2] for different fullscreen states
+            //                        -1: no fullscreen, 0: fullscreen, 1: maximized, 2: fullscreen without sending fs state to window
 
             const auto  NEXTSPACE = selector.find_first_of(' ', i);
             std::string prop      = selector.substr(i, NEXTSPACE == std::string::npos ? std::string::npos : NEXTSPACE - i);
@@ -442,6 +444,44 @@ bool CWorkspace::matchesStaticSelector(const std::string& selector_) {
                 continue;
             }
 
+            if (cur == 'f') {
+                if (!prop.starts_with("f[") || !prop.ends_with("]")) {
+                    Debug::log(LOG, "Invalid selector {}", selector);
+                    return false;
+                }
+
+                prop        = prop.substr(2, prop.length() - 3);
+                int FSSTATE = -1;
+                try {
+                    FSSTATE = std::stoi(prop);
+                } catch (std::exception& e) {
+                    Debug::log(LOG, "Invalid selector {}", selector);
+                    return false;
+                }
+
+                switch (FSSTATE) {
+                    case -1: // no fullscreen
+                        if (m_bHasFullscreenWindow)
+                            return false;
+                        break;
+                    case 0: // fullscreen full
+                        if (!m_bHasFullscreenWindow || m_efFullscreenMode != FULLSCREEN_FULL)
+                            return false;
+                        break;
+                    case 1: // maximized
+                        if (!m_bHasFullscreenWindow || m_efFullscreenMode != FULLSCREEN_MAXIMIZED)
+                            return false;
+                        break;
+                    case 2: // fullscreen without sending fullscreen state to window
+                        if (!m_bHasFullscreenWindow || m_efFullscreenMode != FULLSCREEN_FULL || !g_pCompositor->getFullscreenWindowOnWorkspace(m_iID) ||
+                            !g_pCompositor->getFullscreenWindowOnWorkspace(m_iID)->m_bDontSendFullscreen)
+                            return false;
+                        break;
+                    default: break;
+                }
+                continue;
+            }
+
             Debug::log(LOG, "Invalid selector {}", selector);
             return false;
         }

commit 3e19489262c67ebf015e5aebf1b85c3e0b84baf0
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 21 12:50:31 2024 +0100

    keybinds: clear repeat source on mouse inputs
    
    fixes #5671

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 39ede5d4..34e2f85b 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -335,14 +335,14 @@ bool CKeybindManager::onKeyEvent(wlr_keyboard_key_event* e, SKeyboard* pKeyboard
         .submapAtPress      = m_szCurrentSelectedSubmap,
     };
 
+    if (m_pActiveKeybindEventSource) {
+        wl_event_source_remove(m_pActiveKeybindEventSource);
+        m_pActiveKeybindEventSource = nullptr;
+        m_pActiveKeybind            = nullptr;
+    }
+
     bool suppressEvent = false;
     if (e->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
-        // clean repeat
-        if (m_pActiveKeybindEventSource) {
-            wl_event_source_remove(m_pActiveKeybindEventSource);
-            m_pActiveKeybindEventSource = nullptr;
-            m_pActiveKeybind            = nullptr;
-        }
 
         m_dPressedKeys.push_back(KEY);
 
@@ -353,12 +353,6 @@ bool CKeybindManager::onKeyEvent(wlr_keyboard_key_event* e, SKeyboard* pKeyboard
 
         m_dPressedKeys.back().sent = !suppressEvent;
     } else { // key release
-        // clean repeat
-        if (m_pActiveKeybindEventSource) {
-            wl_event_source_remove(m_pActiveKeybindEventSource);
-            m_pActiveKeybindEventSource = nullptr;
-            m_pActiveKeybind            = nullptr;
-        }
 
         bool foundInPressedKeys = false;
         for (auto it = m_dPressedKeys.begin(); it != m_dPressedKeys.end();) {
@@ -396,6 +390,12 @@ bool CKeybindManager::onAxisEvent(wlr_pointer_axis_event* e) {
 
     m_tScrollTimer.reset();
 
+    if (m_pActiveKeybindEventSource) {
+        wl_event_source_remove(m_pActiveKeybindEventSource);
+        m_pActiveKeybindEventSource = nullptr;
+        m_pActiveKeybind            = nullptr;
+    }
+
     bool found = false;
     if (e->source == WL_POINTER_AXIS_SOURCE_WHEEL && e->orientation == WL_POINTER_AXIS_VERTICAL_SCROLL) {
         if (e->delta < 0)
@@ -433,6 +433,12 @@ bool CKeybindManager::onMouseEvent(wlr_pointer_button_event* e) {
         .modmaskAtPressTime = MODS,
     };
 
+    if (m_pActiveKeybindEventSource) {
+        wl_event_source_remove(m_pActiveKeybindEventSource);
+        m_pActiveKeybindEventSource = nullptr;
+        m_pActiveKeybind            = nullptr;
+    }
+
     if (e->state == WL_POINTER_BUTTON_STATE_PRESSED) {
         m_dPressedKeys.push_back(KEY);
 

commit 8900f0d68efb955733e96d05da543ce18695d38a
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon Apr 22 15:46:43 2024 +0100

    pluginsystem: unload entire plugin before calling dlclose()
    
    fixes #5689

diff --git a/src/plugins/PluginSystem.cpp b/src/plugins/PluginSystem.cpp
index 44b4de1f..ae87aedb 100644
--- a/src/plugins/PluginSystem.cpp
+++ b/src/plugins/PluginSystem.cpp
@@ -119,11 +119,16 @@ void CPluginSystem::unloadPlugin(const CPlugin* plugin, bool eject) {
 
     g_pConfigManager->removePluginConfig(plugin->m_pHandle);
 
-    dlclose(plugin->m_pHandle);
+    // save these two for dlclose and a log,
+    // as erase_if will kill the pointer
+    const auto PLNAME = plugin->name;
+    const auto PLHANDLE = plugin->m_pHandle;
 
-    Debug::log(LOG, " [PluginSystem] Plugin {} unloaded.", plugin->name);
+    std::erase_if(m_vLoadedPlugins, [&](const auto& other) { return other->m_pHandle == PLHANDLE; });
 
-    std::erase_if(m_vLoadedPlugins, [&](const auto& other) { return other->m_pHandle == plugin->m_pHandle; });
+    dlclose(PLHANDLE);
+
+    Debug::log(LOG, " [PluginSystem] Plugin {} unloaded.", PLNAME);
 
     // reload config to fix some stuf like e.g. unloadedPluginVars
     g_pConfigManager->m_bForceReload = true;

commit fbec687dde23c7116531e3308051d68207f822c5
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 01:27:08 2024 +0100

    managers: Add a TokenManager

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 000bcd3d..6117e3eb 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -233,6 +233,7 @@ target_link_libraries(Hyprland
         OpenGL::GL
         Threads::Threads
         libudis86
+        uuid
 )
 
 protocol("protocols/idle.xml" "idle" true)
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 26a22299..48311c1d 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -2,6 +2,7 @@
 #include "helpers/Splashes.hpp"
 #include "config/ConfigValue.hpp"
 #include "managers/CursorManager.hpp"
+#include "managers/TokenManager.hpp"
 #include "managers/eventLoop/EventLoopManager.hpp"
 #include <random>
 #include <unordered_set>
@@ -469,6 +470,9 @@ void CCompositor::initManagers(eManagersInitStage stage) {
             Debug::log(LOG, "Creating the LayoutManager!");
             g_pLayoutManager = std::make_unique<CLayoutManager>();
 
+            Debug::log(LOG, "Creating the TokenManager!");
+            g_pTokenManager = std::make_unique<CTokenManager>();
+
             g_pConfigManager->init();
             g_pWatchdog = std::make_unique<CWatchdog>(); // requires config
         } break;
diff --git a/src/managers/TokenManager.cpp b/src/managers/TokenManager.cpp
new file mode 100644
index 00000000..e48addd0
--- /dev/null
+++ b/src/managers/TokenManager.cpp
@@ -0,0 +1,43 @@
+#include "TokenManager.hpp"
+#include <uuid/uuid.h>
+#include <algorithm>
+
+CUUIDToken::CUUIDToken(const std::string& uuid_, std::any data_, std::chrono::system_clock::duration expires) : data(data_), uuid(uuid_) {
+    expiresAt = std::chrono::system_clock::now() + expires;
+}
+
+std::string CUUIDToken::getUUID() {
+    return uuid;
+}
+
+std::string CTokenManager::registerNewToken(std::any data, std::chrono::system_clock::duration expires) {
+    std::string uuid;
+    do {
+        uuid_t uuid_;
+        uuid_generate_random(uuid_);
+        uuid = std::format("{:02x}{:02x}{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}", (uint16_t)uuid_[0], (uint16_t)uuid_[1], (uint16_t)uuid_[2],
+                           (uint16_t)uuid_[3], (uint16_t)uuid_[4], (uint16_t)uuid_[5], (uint16_t)uuid_[6], (uint16_t)uuid_[7], (uint16_t)uuid_[8], (uint16_t)uuid_[9],
+                           (uint16_t)uuid_[10], (uint16_t)uuid_[11], (uint16_t)uuid_[12], (uint16_t)uuid_[13], (uint16_t)uuid_[14], (uint16_t)uuid_[15]);
+    } while (m_mTokens.contains(uuid));
+
+    m_mTokens[uuid] = std::make_shared<CUUIDToken>(uuid, data, expires);
+    return uuid;
+}
+
+std::shared_ptr<CUUIDToken> CTokenManager::getToken(const std::string& uuid) {
+
+    // cleanup expired tokens
+    const auto NOW = std::chrono::system_clock::now();
+    std::erase_if(m_mTokens, [this, &NOW](const auto& el) { return el.second->expiresAt < NOW; });
+
+    if (!m_mTokens.contains(uuid))
+        return {};
+
+    return m_mTokens.at(uuid);
+}
+
+void CTokenManager::removeToken(std::shared_ptr<CUUIDToken> token) {
+    if (!token)
+        return;
+    m_mTokens.erase(token->uuid);
+}
\ No newline at end of file
diff --git a/src/managers/TokenManager.hpp b/src/managers/TokenManager.hpp
new file mode 100644
index 00000000..45b0679a
--- /dev/null
+++ b/src/managers/TokenManager.hpp
@@ -0,0 +1,36 @@
+#pragma once
+
+#include <memory>
+#include <chrono>
+#include <any>
+#include <unordered_map>
+#include <string>
+
+class CUUIDToken {
+  public:
+    CUUIDToken(const std::string& uuid_, std::any data_, std::chrono::system_clock::duration expires);
+
+    std::string getUUID();
+
+    std::any    data;
+
+  private:
+    std::string                           uuid;
+
+    std::chrono::system_clock::time_point expiresAt;
+
+    friend class CTokenManager;
+};
+
+class CTokenManager {
+  public:
+    std::string                 registerNewToken(std::any data, std::chrono::system_clock::duration expires);
+
+    std::shared_ptr<CUUIDToken> getToken(const std::string& uuid);
+    void                        removeToken(std::shared_ptr<CUUIDToken> token);
+
+  private:
+    std::unordered_map<std::string, std::shared_ptr<CUUIDToken>> m_mTokens;
+};
+
+inline std::unique_ptr<CTokenManager> g_pTokenManager;
\ No newline at end of file

commit e926d6ebe03334ce398754e2c1947081b3770a07
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 01:28:20 2024 +0100

    windows: add misc:initial_workspace_tracking
    
    By default enabled, will track the initial opened workspace of a window spawned for 2 minutes or until it's moved to a different workspace.
    
    For example: you run a launcher and open an app on workspace 1, but quickly switch to workspace 2. The app will now open on workspace 1 regardless of your switch.

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 05694832..eaaed1f7 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -350,6 +350,7 @@ CConfigManager::CConfigManager() {
     m_pConfig->addConfigValue("misc:new_window_takes_over_fullscreen", Hyprlang::INT{0});
     m_pConfig->addConfigValue("misc:enable_hyprcursor", Hyprlang::INT{1});
     m_pConfig->addConfigValue("misc:hide_cursor_on_key_press", Hyprlang::INT{0});
+    m_pConfig->addConfigValue("misc:initial_workspace_tracking", Hyprlang::INT{1});
 
     m_pConfig->addConfigValue("group:insert_after_current", Hyprlang::INT{1});
     m_pConfig->addConfigValue("group:focus_removed_window", Hyprlang::INT{1});
diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index 35b4ff97..0db739a0 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -5,6 +5,7 @@
 #include "../render/decorations/CHyprBorderDecoration.hpp"
 #include "../config/ConfigValue.hpp"
 #include <any>
+#include "../managers/TokenManager.hpp"
 
 CWindow::CWindow() {
     m_vRealPosition.create(g_pConfigManager->getAnimationPropertyConfig("windowsIn"), this, AVARDAMAGE_ENTIRE);
@@ -382,6 +383,11 @@ void CWindow::moveToWorkspace(PHLWORKSPACE pWorkspace) {
     if (m_pWorkspace == pWorkspace)
         return;
 
+    if (!m_szInitialWorkspaceToken.empty()) {
+        g_pTokenManager->removeToken(g_pTokenManager->getToken(m_szInitialWorkspaceToken));
+        m_szInitialWorkspaceToken = "";
+    }
+
     static auto PCLOSEONLASTSPECIAL = CConfigValue<Hyprlang::INT>("misc:close_special_on_empty");
 
     const auto  OLDWORKSPACE = m_pWorkspace;
@@ -1239,3 +1245,42 @@ int CWindow::workspaceID() {
 bool CWindow::onSpecialWorkspace() {
     return m_pWorkspace ? m_pWorkspace->m_bIsSpecialWorkspace : g_pCompositor->isWorkspaceSpecial(m_iLastWorkspace);
 }
+
+std::unordered_map<std::string, std::string> CWindow::getEnv() {
+
+    const auto PID = getPID();
+
+    if (PID <= 1)
+        return {};
+
+    std::unordered_map<std::string, std::string> results;
+
+    //
+    std::string       environFile = "/proc/" + std::to_string(PID) + "/environ";
+    std::ifstream     ifs(environFile, std::ios::binary);
+
+    if (!ifs.good())
+        return {};
+
+    std::vector<char> buffer;
+    size_t            needle = 0;
+    buffer.resize(512, '\0');
+    while (ifs.read(buffer.data() + needle, 512)) {
+        buffer.resize(buffer.size() + 512, '\0');
+        needle += 512;
+    }
+
+    std::replace(buffer.begin(), buffer.end() - 1, '\0', '\n');
+
+    CVarList envs(std::string{buffer.data(), needle - 1}, 0, '\n', true);
+
+    for (auto& e : envs) {
+        if (!e.contains('='))
+            continue;
+
+        const auto EQ            = e.find_first_of('=');
+        results[e.substr(0, EQ)] = e.substr(EQ + 1);
+    }
+
+    return results;
+}
diff --git a/src/desktop/Window.hpp b/src/desktop/Window.hpp
index 8a368ea6..bacb14ab 100644
--- a/src/desktop/Window.hpp
+++ b/src/desktop/Window.hpp
@@ -352,6 +352,9 @@ class CWindow {
     // for idle inhibiting windows
     eIdleInhibitMode m_eIdleInhibitMode = IDLEINHIBIT_NONE;
 
+    // initial token. Will be unregistered on workspace change or timeout of 2 minutes
+    std::string m_szInitialWorkspaceToken = "";
+
     // for groups
     struct SGroupData {
         CWindow* pNextWindow = nullptr; // nullptr means no grouping. Self means single group.
@@ -432,6 +435,9 @@ class CWindow {
     void                     setAnimationsToMove();
     void                     onWorkspaceAnimUpdate();
 
+    //
+    std::unordered_map<std::string, std::string> getEnv();
+
   private:
     // For hidden windows and stuff
     bool m_bHidden        = false;
diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index b1db5286..76e0cae5 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -3,6 +3,7 @@
 #include "../Compositor.hpp"
 #include "../helpers/WLClasses.hpp"
 #include "../managers/input/InputManager.hpp"
+#include "../managers/TokenManager.hpp"
 #include "../render/Renderer.hpp"
 #include "../config/ConfigValue.hpp"
 
@@ -44,13 +45,14 @@ void setAnimToMove(void* data) {
 void Events::listener_mapWindow(void* owner, void* data) {
     CWindow*    PWINDOW = (CWindow*)owner;
 
-    static auto PINACTIVEALPHA  = CConfigValue<Hyprlang::FLOAT>("decoration:inactive_opacity");
-    static auto PACTIVEALPHA    = CConfigValue<Hyprlang::FLOAT>("decoration:active_opacity");
-    static auto PDIMSTRENGTH    = CConfigValue<Hyprlang::FLOAT>("decoration:dim_strength");
-    static auto PSWALLOW        = CConfigValue<Hyprlang::INT>("misc:enable_swallow");
-    static auto PSWALLOWREGEX   = CConfigValue<std::string>("misc:swallow_regex");
-    static auto PSWALLOWEXREGEX = CConfigValue<std::string>("misc:swallow_exception_regex");
-    static auto PNEWTAKESOVERFS = CConfigValue<Hyprlang::INT>("misc:new_window_takes_over_fullscreen");
+    static auto PINACTIVEALPHA     = CConfigValue<Hyprlang::FLOAT>("decoration:inactive_opacity");
+    static auto PACTIVEALPHA       = CConfigValue<Hyprlang::FLOAT>("decoration:active_opacity");
+    static auto PDIMSTRENGTH       = CConfigValue<Hyprlang::FLOAT>("decoration:dim_strength");
+    static auto PSWALLOW           = CConfigValue<Hyprlang::INT>("misc:enable_swallow");
+    static auto PSWALLOWREGEX      = CConfigValue<std::string>("misc:swallow_regex");
+    static auto PSWALLOWEXREGEX    = CConfigValue<std::string>("misc:swallow_exception_regex");
+    static auto PNEWTAKESOVERFS    = CConfigValue<Hyprlang::INT>("misc:new_window_takes_over_fullscreen");
+    static auto PINITIALWSTRACKING = CConfigValue<Hyprlang::INT>("misc:initial_workspace_tracking");
 
     auto        PMONITOR = g_pCompositor->m_pLastMonitor;
     if (!g_pCompositor->m_pLastMonitor) {
@@ -67,6 +69,28 @@ void Events::listener_mapWindow(void* owner, void* data) {
     PWINDOW->m_iX11Type       = PWINDOW->m_bIsX11 ? (PWINDOW->m_uSurface.xwayland->override_redirect ? 2 : 1) : 1;
     PWINDOW->m_bFirstMap      = true;
 
+    // check for token
+    std::string requestedWorkspace = "";
+    bool        workspaceSilent    = false;
+
+    if (*PINITIALWSTRACKING) {
+        const auto WINDOWENV = PWINDOW->getEnv();
+        if (WINDOWENV.contains("HL_INITIAL_WORKSPACE_TOKEN")) {
+            const auto SZTOKEN = WINDOWENV.at("HL_INITIAL_WORKSPACE_TOKEN");
+            Debug::log(LOG, "New window contains HL_INITIAL_WORKSPACE_TOKEN: {}", SZTOKEN);
+            const auto TOKEN = g_pTokenManager->getToken(SZTOKEN);
+            if (TOKEN) {
+                // find workspace and use it
+                std::string WS = std::any_cast<std::string>(TOKEN->data);
+
+                Debug::log(LOG, "HL_INITIAL_WORKSPACE_TOKEN {} -> {}", SZTOKEN, WS);
+
+                requestedWorkspace = WS;
+                workspaceSilent    = true;
+            }
+        }
+    }
+
     if (g_pInputManager->m_bLastFocusOnLS) // waybar fix
         g_pInputManager->releaseAllMouseButtons();
 
@@ -108,10 +132,8 @@ void Events::listener_mapWindow(void* owner, void* data) {
     }
 
     // window rules
-    const auto  WINDOWRULES        = g_pConfigManager->getMatchingRules(PWINDOW, false);
-    std::string requestedWorkspace = "";
-    bool        workspaceSilent    = false;
-    bool        requestsFullscreen = PWINDOW->m_bWantsInitialFullscreen ||
+    const auto WINDOWRULES        = g_pConfigManager->getMatchingRules(PWINDOW, false);
+    bool       requestsFullscreen = PWINDOW->m_bWantsInitialFullscreen ||
         (!PWINDOW->m_bIsX11 && PWINDOW->m_uSurface.xdg->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL && PWINDOW->m_uSurface.xdg->toplevel->requested.fullscreen) ||
         (PWINDOW->m_bIsX11 && PWINDOW->m_uSurface.xwayland->fullscreen);
     bool requestsFakeFullscreen = false;
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 34e2f85b..040ae245 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -3,8 +3,10 @@
 #include "debug/Log.hpp"
 #include "helpers/VarList.hpp"
 #include "../config/ConfigValue.hpp"
+#include "TokenManager.hpp"
 
 #include <regex>
+#include <tuple>
 
 #include <sys/ioctl.h>
 #include <fcntl.h>
@@ -17,6 +19,23 @@
 #include <sys/consio.h>
 #endif
 
+static std::vector<std::pair<std::string, std::string>> getHyprlandLaunchEnv() {
+    static auto PINITIALWSTRACKING = CConfigValue<Hyprlang::INT>("misc:initial_workspace_tracking");
+
+    if (!*PINITIALWSTRACKING)
+        return {};
+
+    const auto PMONITOR = g_pCompositor->m_pLastMonitor;
+    if (!PMONITOR || !PMONITOR->activeWorkspace)
+        return {};
+
+    std::vector<std::pair<std::string, std::string>> result;
+
+    result.push_back(std::make_pair<>("HL_INITIAL_WORKSPACE_TOKEN", g_pTokenManager->registerNewToken(PMONITOR->activeWorkspace->getConfigName(), std::chrono::minutes(2))));
+
+    return result;
+}
+
 CKeybindManager::CKeybindManager() {
     // initialize all dispatchers
 
@@ -774,7 +793,9 @@ void CKeybindManager::spawn(std::string args) {
 uint64_t CKeybindManager::spawnRaw(std::string args) {
     Debug::log(LOG, "Executing {}", args);
 
-    int socket[2];
+    const auto HLENV = getHyprlandLaunchEnv();
+
+    int        socket[2];
     if (pipe(socket) != 0) {
         Debug::log(LOG, "Unable to create pipe for fork");
     }
@@ -797,6 +818,9 @@ uint64_t CKeybindManager::spawnRaw(std::string args) {
         grandchild = fork();
         if (grandchild == 0) {
             // run in grandchild
+            for (auto& e : HLENV) {
+                setenv(e.first.c_str(), e.second.c_str(), 1);
+            }
             close(socket[0]);
             close(socket[1]);
             execl("/bin/sh", "/bin/sh", "-c", args.c_str(), nullptr);

commit 5b6bb4b8684f933b79d7f7951386a8f2bc86edfc
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 11:37:12 2024 +0100

    windows: don't force workspace change on same tracked workspace

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index 76e0cae5..95045821 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -85,8 +85,10 @@ void Events::listener_mapWindow(void* owner, void* data) {
 
                 Debug::log(LOG, "HL_INITIAL_WORKSPACE_TOKEN {} -> {}", SZTOKEN, WS);
 
-                requestedWorkspace = WS;
-                workspaceSilent    = true;
+                if (g_pCompositor->getWorkspaceByString(WS) != PWINDOW->m_pWorkspace) {
+                    requestedWorkspace = WS;
+                    workspaceSilent    = true;
+                }
             }
         }
     }

commit c01710beaa658f4328b9465736fd29d9a36f5e39
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 12:29:01 2024 +0100

    renderer: avoid rendering frame if finalDamage is empty

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index a51901b4..b1189d8d 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -1302,43 +1302,45 @@ void CHyprRenderer::renderMonitor(CMonitor* pMonitor) {
 
     bool renderCursor = true;
 
-    if (!pMonitor->solitaryClient) {
-        if (pMonitor->isMirror()) {
-            g_pHyprOpenGL->blend(false);
-            g_pHyprOpenGL->renderMirrored();
-            g_pHyprOpenGL->blend(true);
-            EMIT_HOOK_EVENT("render", RENDER_POST_MIRROR);
-            renderCursor = false;
-        } else {
-            CBox renderBox = {0, 0, (int)pMonitor->vecPixelSize.x, (int)pMonitor->vecPixelSize.y};
-            renderWorkspace(pMonitor, pMonitor->activeWorkspace, &now, renderBox);
+    if (!finalDamage.empty()) {
+        if (!pMonitor->solitaryClient) {
+            if (pMonitor->isMirror()) {
+                g_pHyprOpenGL->blend(false);
+                g_pHyprOpenGL->renderMirrored();
+                g_pHyprOpenGL->blend(true);
+                EMIT_HOOK_EVENT("render", RENDER_POST_MIRROR);
+                renderCursor = false;
+            } else {
+                CBox renderBox = {0, 0, (int)pMonitor->vecPixelSize.x, (int)pMonitor->vecPixelSize.y};
+                renderWorkspace(pMonitor, pMonitor->activeWorkspace, &now, renderBox);
 
-            renderLockscreen(pMonitor, &now, renderBox);
+                renderLockscreen(pMonitor, &now, renderBox);
 
-            if (pMonitor == g_pCompositor->m_pLastMonitor) {
-                g_pHyprNotificationOverlay->draw(pMonitor);
-                g_pHyprError->draw();
-            }
+                if (pMonitor == g_pCompositor->m_pLastMonitor) {
+                    g_pHyprNotificationOverlay->draw(pMonitor);
+                    g_pHyprError->draw();
+                }
 
-            // for drawing the debug overlay
-            if (pMonitor == g_pCompositor->m_vMonitors.front().get() && *PDEBUGOVERLAY == 1) {
-                renderStartOverlay = std::chrono::high_resolution_clock::now();
-                g_pDebugOverlay->draw();
-                endRenderOverlay = std::chrono::high_resolution_clock::now();
-            }
+                // for drawing the debug overlay
+                if (pMonitor == g_pCompositor->m_vMonitors.front().get() && *PDEBUGOVERLAY == 1) {
+                    renderStartOverlay = std::chrono::high_resolution_clock::now();
+                    g_pDebugOverlay->draw();
+                    endRenderOverlay = std::chrono::high_resolution_clock::now();
+                }
 
-            if (*PDAMAGEBLINK && damageBlinkCleanup == 0) {
-                CBox monrect = {0, 0, pMonitor->vecTransformedSize.x, pMonitor->vecTransformedSize.y};
-                g_pHyprOpenGL->renderRect(&monrect, CColor(1.0, 0.0, 1.0, 100.0 / 255.0), 0);
-                damageBlinkCleanup = 1;
-            } else if (*PDAMAGEBLINK) {
-                damageBlinkCleanup++;
-                if (damageBlinkCleanup > 3)
-                    damageBlinkCleanup = 0;
+                if (*PDAMAGEBLINK && damageBlinkCleanup == 0) {
+                    CBox monrect = {0, 0, pMonitor->vecTransformedSize.x, pMonitor->vecTransformedSize.y};
+                    g_pHyprOpenGL->renderRect(&monrect, CColor(1.0, 0.0, 1.0, 100.0 / 255.0), 0);
+                    damageBlinkCleanup = 1;
+                } else if (*PDAMAGEBLINK) {
+                    damageBlinkCleanup++;
+                    if (damageBlinkCleanup > 3)
+                        damageBlinkCleanup = 0;
+                }
             }
+        } else {
+            g_pHyprRenderer->renderWindow(pMonitor->solitaryClient, pMonitor, &now, false, RENDER_PASS_MAIN /* solitary = no popups */);
         }
-    } else {
-        g_pHyprRenderer->renderWindow(pMonitor->solitaryClient, pMonitor, &now, false, RENDER_PASS_MAIN /* solitary = no popups */);
     }
 
     renderCursor = renderCursor && shouldRenderCursor();

commit 924d8a83258d76a215d92731ca1595ee54e04c9e
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 16:08:54 2024 +0100

    renderer: send frame events to apps on empty damage renders
    
    fixes #5711

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index b1189d8d..0df5efa0 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -1338,9 +1338,12 @@ void CHyprRenderer::renderMonitor(CMonitor* pMonitor) {
                         damageBlinkCleanup = 0;
                 }
             }
-        } else {
+        } else
             g_pHyprRenderer->renderWindow(pMonitor->solitaryClient, pMonitor, &now, false, RENDER_PASS_MAIN /* solitary = no popups */);
-        }
+    } else {
+        sendFrameEventsToWorkspace(pMonitor, pMonitor->activeWorkspace, &now);
+        if (pMonitor->activeSpecialWorkspace)
+            sendFrameEventsToWorkspace(pMonitor, pMonitor->activeSpecialWorkspace, &now);
     }
 
     renderCursor = renderCursor && shouldRenderCursor();
@@ -1436,6 +1439,26 @@ void CHyprRenderer::renderWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace,
     g_pHyprOpenGL->m_RenderData.pWorkspace = nullptr;
 }
 
+void CHyprRenderer::sendFrameEventsToWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace, timespec* now) {
+    for (auto& w : g_pCompositor->m_vWindows) {
+        if (w->isHidden() && !w->m_bIsMapped && !w->m_bFadingOut)
+            continue;
+
+        if (!shouldRenderWindow(w.get(), pMonitor))
+            continue;
+
+        wlr_surface_for_each_surface(
+            w->m_pWLSurface.wlr(), [](wlr_surface* s, int x, int y, void* data) { wlr_surface_send_frame_done(s, (timespec*)data); }, now);
+    }
+
+    for (auto& lsl : pMonitor->m_aLayerSurfaceLayers) {
+        for (auto& ls : lsl) {
+            wlr_surface_for_each_surface(
+                ls->surface.wlr(), [](wlr_surface* s, int x, int y, void* data) { wlr_surface_send_frame_done(s, (timespec*)data); }, now);
+        }
+    }
+}
+
 void CHyprRenderer::setWindowScanoutMode(CWindow* pWindow) {
     if (!g_pCompositor->m_sWLRLinuxDMABuf || g_pSessionLockManager->isSessionLocked())
         return;
diff --git a/src/render/Renderer.hpp b/src/render/Renderer.hpp
index 2e2b8b92..0a0ae5c9 100644
--- a/src/render/Renderer.hpp
+++ b/src/render/Renderer.hpp
@@ -117,6 +117,7 @@ class CHyprRenderer {
     void           renderDragIcon(CMonitor*, timespec*);
     void           renderIMEPopup(CInputPopup*, CMonitor*, timespec*);
     void           renderWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace, timespec* now, const CBox& geometry);
+    void           sendFrameEventsToWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace, timespec* now); // sends frame displayed events but doesn't actually render anything
     void           renderAllClientsForWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace, timespec* now, const Vector2D& translate = {0, 0}, const float& scale = 1.f);
 
     bool           m_bCursorHidden        = false;

commit 3a27f5f06073396a7b1d4c323ba02fc2fd694321
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 16:38:12 2024 +0100

    compositor: properly update workspace in moveWindowToWorkspaceSafe
    
    fixes #5714

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 48311c1d..6f3ddae3 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -2693,11 +2693,9 @@ void CCompositor::moveWindowToWorkspaceSafe(CWindow* pWindow, PHLWORKSPACE pWork
     if (FULLSCREEN)
         setWindowFullscreen(pWindow, false, FULLSCREEN_FULL);
 
-    pWindow->moveToWorkspace(pWorkspace);
-
     if (!pWindow->m_bIsFloating) {
         g_pLayoutManager->getCurrentLayout()->onWindowRemovedTiling(pWindow);
-        pWindow->m_pWorkspace = pWorkspace;
+        pWindow->moveToWorkspace(pWorkspace);
         pWindow->m_iMonitorID = pWorkspace->m_iMonitorID;
         g_pLayoutManager->getCurrentLayout()->onWindowCreatedTiling(pWindow);
     } else {
@@ -2706,7 +2704,7 @@ void CCompositor::moveWindowToWorkspaceSafe(CWindow* pWindow, PHLWORKSPACE pWork
 
         const auto PWORKSPACEMONITOR = g_pCompositor->getMonitorFromID(pWorkspace->m_iMonitorID);
 
-        pWindow->m_pWorkspace = pWorkspace;
+        pWindow->moveToWorkspace(pWorkspace);
         pWindow->m_iMonitorID = pWorkspace->m_iMonitorID;
 
         pWindow->m_vRealPosition = POSTOMON + PWORKSPACEMONITOR->vecPosition;

commit 5e2c707a38f04ff0eff1b598ab89de58c693d8d0
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 23 21:15:37 2024 +0100

    renderer: fix safety around sendFrameEventsToWorkspace
    
    ref #5718

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 0df5efa0..551c7264 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -1441,7 +1441,7 @@ void CHyprRenderer::renderWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace,
 
 void CHyprRenderer::sendFrameEventsToWorkspace(CMonitor* pMonitor, PHLWORKSPACE pWorkspace, timespec* now) {
     for (auto& w : g_pCompositor->m_vWindows) {
-        if (w->isHidden() && !w->m_bIsMapped && !w->m_bFadingOut)
+        if (w->isHidden() || !w->m_bIsMapped || w->m_bFadingOut || !w->m_pWLSurface.wlr())
             continue;
 
         if (!shouldRenderWindow(w.get(), pMonitor))
@@ -1453,6 +1453,9 @@ void CHyprRenderer::sendFrameEventsToWorkspace(CMonitor* pMonitor, PHLWORKSPACE
 
     for (auto& lsl : pMonitor->m_aLayerSurfaceLayers) {
         for (auto& ls : lsl) {
+            if (ls->fadingOut || !ls->surface.wlr())
+                continue;
+
             wlr_surface_for_each_surface(
                 ls->surface.wlr(), [](wlr_surface* s, int x, int y, void* data) { wlr_surface_send_frame_done(s, (timespec*)data); }, now);
         }

commit f0a8613ca41eead87f553c2f43dc9b472a3f1ef9
Author: drendog <53359960+drendog@users.noreply.github.com>
Date:   Wed Apr 24 00:30:35 2024 +0200

    input: fix active keyboard for seat after destroying one (#5725)
    
    * fix: manage active keyboard for seat after destroying one
    
    * chore: clang-format

diff --git a/src/managers/input/InputManager.cpp b/src/managers/input/InputManager.cpp
index 60e4270d..e69197f2 100644
--- a/src/managers/input/InputManager.cpp
+++ b/src/managers/input/InputManager.cpp
@@ -1141,17 +1141,16 @@ void CInputManager::destroyKeyboard(SKeyboard* pKeyboard) {
 
     xkb_state_unref(pKeyboard->xkbTranslationState);
 
-    if (pKeyboard->active) {
-        m_lKeyboards.remove(*pKeyboard);
+    m_lKeyboards.remove(*pKeyboard);
 
-        if (m_lKeyboards.size() > 0) {
-            m_pActiveKeyboard         = &m_lKeyboards.back();
-            m_pActiveKeyboard->active = true;
-        } else {
-            m_pActiveKeyboard = nullptr;
-        }
-    } else
-        m_lKeyboards.remove(*pKeyboard);
+    if (m_lKeyboards.size() > 0) {
+        m_pActiveKeyboard         = &m_lKeyboards.back();
+        m_pActiveKeyboard->active = true;
+        wlr_seat_set_keyboard(g_pCompositor->m_sSeat.seat, wlr_keyboard_from_input_device(m_pActiveKeyboard->keyboard));
+    } else {
+        m_pActiveKeyboard = nullptr;
+        wlr_seat_set_keyboard(g_pCompositor->m_sSeat.seat, nullptr);
+    }
 }
 
 void CInputManager::destroyMouse(wlr_input_device* mouse) {

commit dac47860a20b7525deb6e2427637084f353c959f
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Apr 24 02:05:56 2024 +0100

    tokens: fix initial workspace token ignoring special
    
    ref #5726

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 040ae245..5a9fef8b 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -31,7 +31,10 @@ static std::vector<std::pair<std::string, std::string>> getHyprlandLaunchEnv() {
 
     std::vector<std::pair<std::string, std::string>> result;
 
-    result.push_back(std::make_pair<>("HL_INITIAL_WORKSPACE_TOKEN", g_pTokenManager->registerNewToken(PMONITOR->activeWorkspace->getConfigName(), std::chrono::minutes(2))));
+    result.push_back(std::make_pair<>(
+        "HL_INITIAL_WORKSPACE_TOKEN",
+        g_pTokenManager->registerNewToken(PMONITOR->activeSpecialWorkspace ? PMONITOR->activeSpecialWorkspace->getConfigName() : PMONITOR->activeWorkspace->getConfigName(),
+                                          std::chrono::minutes(2))));
 
     return result;
 }

commit 4be8fcf711b40be72f973cf4ca581fb18a7d17e4
Author: Agent00Ming <107314235+Agent00Ming@users.noreply.github.com>
Date:   Wed Apr 24 11:07:22 2024 -0400

    workspace: Fix duplication of "special:" in special workspace name (#5729)
    
    * Fix duplication of "special:" in special workspace name
            modified:   src/desktop/Workspace.cpp
    
    * Track default special workspace name as special:special
    This is to fix the edge cases with the previous commit without breaking
    user configs.
    
            modified:   src/helpers/MiscFunctions.cpp
    
    ---------
    
    Co-authored-by: Agent_00Ming <agent00ming9366@gmail.com>

diff --git a/src/desktop/Workspace.cpp b/src/desktop/Workspace.cpp
index 7ab75fd5..e9b155a4 100644
--- a/src/desktop/Workspace.cpp
+++ b/src/desktop/Workspace.cpp
@@ -207,7 +207,7 @@ void CWorkspace::rememberPrevWorkspace(const PHLWORKSPACE& prev) {
 
 std::string CWorkspace::getConfigName() {
     if (m_bIsSpecialWorkspace) {
-        return "special:" + m_szName;
+        return m_szName;
     }
 
     if (m_iID > 0)
diff --git a/src/helpers/MiscFunctions.cpp b/src/helpers/MiscFunctions.cpp
index 779b45b1..b8061bef 100644
--- a/src/helpers/MiscFunctions.cpp
+++ b/src/helpers/MiscFunctions.cpp
@@ -256,7 +256,7 @@ bool isDirection(const char& arg) {
 int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
     int result = WORKSPACE_INVALID;
     if (in.starts_with("special")) {
-        outName = "special";
+        outName = "special:special";
 
         if (in.length() > 8) {
             const auto NAME = in.substr(8);
@@ -833,4 +833,4 @@ bool envEnabled(const std::string& env) {
     if (!ENV)
         return false;
     return std::string(ENV) == "1";
-}
\ No newline at end of file
+}

commit 8b04e57effbb37ef3e8f86ce544843fa7c8d853e
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Apr 24 16:16:46 2024 +0100

    tokens: add more modes to initial_workspace_tracking
    
    1 is single-shot, 2 is persistent
    
    fixes #5732

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index 0db739a0..bda6c60c 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -383,9 +383,20 @@ void CWindow::moveToWorkspace(PHLWORKSPACE pWorkspace) {
     if (m_pWorkspace == pWorkspace)
         return;
 
+    static auto PINITIALWSTRACKING = CConfigValue<Hyprlang::INT>("misc:initial_workspace_tracking");
+
     if (!m_szInitialWorkspaceToken.empty()) {
-        g_pTokenManager->removeToken(g_pTokenManager->getToken(m_szInitialWorkspaceToken));
-        m_szInitialWorkspaceToken = "";
+        const auto TOKEN = g_pTokenManager->getToken(m_szInitialWorkspaceToken);
+        if (TOKEN) {
+            if (*PINITIALWSTRACKING == 2) {
+                // persistent
+                SInitialWorkspaceToken token = std::any_cast<SInitialWorkspaceToken>(TOKEN->data);
+                if (token.primaryOwner == this) {
+                    token.workspace = pWorkspace->getConfigName();
+                    TOKEN->data     = token;
+                }
+            }
+        }
     }
 
     static auto PCLOSEONLASTSPECIAL = CConfigValue<Hyprlang::INT>("misc:close_special_on_empty");
@@ -466,6 +477,20 @@ void CWindow::onUnmap() {
     if (g_pInputManager->currentlyDraggedWindow == this)
         g_pInputManager->currentlyDraggedWindow = nullptr;
 
+    static auto PINITIALWSTRACKING = CConfigValue<Hyprlang::INT>("misc:initial_workspace_tracking");
+
+    if (!m_szInitialWorkspaceToken.empty()) {
+        const auto TOKEN = g_pTokenManager->getToken(m_szInitialWorkspaceToken);
+        if (TOKEN) {
+            if (*PINITIALWSTRACKING == 2) {
+                // persistent token, but the first window got removed so the token is gone
+                SInitialWorkspaceToken token = std::any_cast<SInitialWorkspaceToken>(TOKEN->data);
+                if (token.primaryOwner == this)
+                    g_pTokenManager->removeToken(TOKEN);
+            }
+        }
+    }
+
     m_iLastWorkspace = m_pWorkspace->m_iID;
 
     m_vRealPosition.setCallbackOnEnd(unregisterVar);
diff --git a/src/desktop/Window.hpp b/src/desktop/Window.hpp
index bacb14ab..5c2808ae 100644
--- a/src/desktop/Window.hpp
+++ b/src/desktop/Window.hpp
@@ -13,6 +13,8 @@
 #include "../managers/XWaylandManager.hpp"
 #include "DesktopTypes.hpp"
 
+class CWindow;
+
 enum eIdleInhibitMode {
     IDLEINHIBIT_NONE = 0,
     IDLEINHIBIT_ALWAYS,
@@ -187,6 +189,11 @@ struct SWindowRule {
     std::string szWorkspace   = ""; // empty means any
 };
 
+struct SInitialWorkspaceToken {
+    CWindow* primaryOwner = nullptr;
+    std::string workspace;
+};
+
 class CWindow {
   public:
     CWindow();
diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index 95045821..e74a4d53 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -81,14 +81,25 @@ void Events::listener_mapWindow(void* owner, void* data) {
             const auto TOKEN = g_pTokenManager->getToken(SZTOKEN);
             if (TOKEN) {
                 // find workspace and use it
-                std::string WS = std::any_cast<std::string>(TOKEN->data);
+                SInitialWorkspaceToken WS = std::any_cast<SInitialWorkspaceToken>(TOKEN->data);
 
-                Debug::log(LOG, "HL_INITIAL_WORKSPACE_TOKEN {} -> {}", SZTOKEN, WS);
+                Debug::log(LOG, "HL_INITIAL_WORKSPACE_TOKEN {} -> {}", SZTOKEN, WS.workspace);
 
-                if (g_pCompositor->getWorkspaceByString(WS) != PWINDOW->m_pWorkspace) {
-                    requestedWorkspace = WS;
+                if (g_pCompositor->getWorkspaceByString(WS.workspace) != PWINDOW->m_pWorkspace) {
+                    requestedWorkspace = WS.workspace;
                     workspaceSilent    = true;
                 }
+
+                if (*PINITIALWSTRACKING == 1) // one-shot token
+                    g_pTokenManager->removeToken(TOKEN);
+                else if (*PINITIALWSTRACKING == 2) { // persistent
+                    if (!WS.primaryOwner) {
+                        WS.primaryOwner = PWINDOW;
+                        TOKEN->data = WS;
+                    }
+
+                    PWINDOW->m_szInitialWorkspaceToken = SZTOKEN;
+                }
             }
         }
     }
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 5a9fef8b..ad863274 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -33,8 +33,9 @@ static std::vector<std::pair<std::string, std::string>> getHyprlandLaunchEnv() {
 
     result.push_back(std::make_pair<>(
         "HL_INITIAL_WORKSPACE_TOKEN",
-        g_pTokenManager->registerNewToken(PMONITOR->activeSpecialWorkspace ? PMONITOR->activeSpecialWorkspace->getConfigName() : PMONITOR->activeWorkspace->getConfigName(),
-                                          std::chrono::minutes(2))));
+        g_pTokenManager->registerNewToken(
+            SInitialWorkspaceToken{nullptr, PMONITOR->activeSpecialWorkspace ? PMONITOR->activeSpecialWorkspace->getConfigName() : PMONITOR->activeWorkspace->getConfigName()},
+            std::chrono::months(1337))));
 
     return result;
 }

commit f6094e7331e7c49b60428bcd10753a306546b929
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Apr 24 16:18:38 2024 +0100

    cursormgr: fix misscaled cursors on fractional

diff --git a/src/managers/CursorManager.cpp b/src/managers/CursorManager.cpp
index 68f020c2..51f012b4 100644
--- a/src/managers/CursorManager.cpp
+++ b/src/managers/CursorManager.cpp
@@ -210,13 +210,15 @@ void CCursorManager::updateTheme() {
             highestScale = m->scale;
     }
 
-    if (highestScale * m_iSize == m_sCurrentStyleInfo.size)
+    highestScale = std::ceil(highestScale);
+
+    if (std::round(highestScale * m_iSize) == m_sCurrentStyleInfo.size)
         return;
 
     if (m_sCurrentStyleInfo.size && m_pHyprcursor->valid())
         m_pHyprcursor->cursorSurfaceStyleDone(m_sCurrentStyleInfo);
 
-    m_sCurrentStyleInfo.size = m_iSize * highestScale;
+    m_sCurrentStyleInfo.size = std::round(m_iSize * highestScale);
     m_fCursorScale           = highestScale;
 
     if (m_pHyprcursor->valid())

commit 278a1f818af12bc41e1e2cb40fd42f46e20db4dc
Author: Virt <41426325+VirtCode@users.noreply.github.com>
Date:   Wed Apr 24 17:29:41 2024 +0200

    renderer: Fix mirrored displays when transformed and preserve aspect ratio (#5697)
    
    * renderer: transform mirror buffer and preserve mirror aspect ratio
    
    * renderer: render mirrors directly from offloadFB
    
    * renderer: fix formatting
    
    * renderer: use monitorMirrorFB again, but properly damage mirrors
    
    * renderer: clean mirrors after reload and support cursor zoom mirroring

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index eaaed1f7..56142857 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -826,6 +826,10 @@ void CConfigManager::postConfigReload(const Hyprlang::CParseResult& result) {
 
         // Force the compositor to fully re-render all monitors
         m->forceFullFrames = 2;
+
+        // also force mirrors, as the aspect ratio could've changed
+        for (auto& mirror : m->mirrors)
+            mirror->forceFullFrames = 3;
     }
 
     // Reset no monitor reload
diff --git a/src/render/OpenGL.cpp b/src/render/OpenGL.cpp
index 981541b2..c4884245 100644
--- a/src/render/OpenGL.cpp
+++ b/src/render/OpenGL.cpp
@@ -152,6 +152,12 @@ bool CHyprOpenGLImpl::passRequiresIntrospection(CMonitor* pMonitor) {
     if (m_RenderData.mouseZoomFactor != 1.0 || g_pHyprRenderer->m_bCrashingInProgress)
         return true;
 
+    // mirrors should not be offloaded (as we then would basically copy the same data twice)
+    // yes, this breaks mirrors of mirrors
+    if (pMonitor->isMirror())
+        return false;
+
+    // monitors that are mirrored however must be offloaded because we cannot copy from output FBs
     if (!pMonitor->mirrors.empty())
         return true;
 
@@ -336,14 +342,10 @@ void CHyprOpenGLImpl::end() {
 
     TRACY_GPU_ZONE("RenderEnd");
 
-    if (!m_RenderData.pMonitor->mirrors.empty() && !m_bFakeFrame)
-        saveBufferForMirror(); // save with original damage region
-
     // end the render, copy the data to the WLR framebuffer
     if (m_bOffloadedFramebuffer) {
         m_RenderData.damage = m_RenderData.finalDamage;
-
-        m_RenderData.outFB->bind();
+        m_bEndFrame         = true;
 
         CBox monbox = {0, 0, m_RenderData.pMonitor->vecTransformedSize.x, m_RenderData.pMonitor->vecTransformedSize.y};
 
@@ -364,11 +366,16 @@ void CHyprOpenGLImpl::end() {
                 monbox.y = m_RenderData.pMonitor->vecTransformedSize.y - monbox.height;
         }
 
-        m_bEndFrame         = true;
         m_bApplyFinalShader = !m_RenderData.blockScreenShader;
         if (m_RenderData.mouseZoomUseMouse)
             m_RenderData.useNearestNeighbor = true;
 
+        // copy the damaged areas into the mirror buffer
+        // we can't use the offloadFB for mirroring, as it contains artifacts from blurring
+        if (!m_RenderData.pMonitor->mirrors.empty() && !m_bFakeFrame)
+            saveBufferForMirror(&monbox);
+
+        m_RenderData.outFB->bind();
         blend(false);
 
         if (m_sFinalScreenShader.program < 1 && !g_pHyprRenderer->m_bCrashingInProgress)
@@ -1971,18 +1978,16 @@ void CHyprOpenGLImpl::renderRoundedShadow(CBox* box, int round, int range, const
     glDisableVertexAttribArray(m_RenderData.pCurrentMonData->m_shSHADOW.texAttrib);
 }
 
-void CHyprOpenGLImpl::saveBufferForMirror() {
+void CHyprOpenGLImpl::saveBufferForMirror(CBox* box) {
 
     if (!m_RenderData.pCurrentMonData->monitorMirrorFB.isAllocated())
         m_RenderData.pCurrentMonData->monitorMirrorFB.alloc(m_RenderData.pMonitor->vecPixelSize.x, m_RenderData.pMonitor->vecPixelSize.y, m_RenderData.pMonitor->drmFormat);
 
     m_RenderData.pCurrentMonData->monitorMirrorFB.bind();
 
-    CBox monbox = {0, 0, m_RenderData.pMonitor->vecPixelSize.x, m_RenderData.pMonitor->vecPixelSize.y};
-
     blend(false);
 
-    renderTexture(m_RenderData.currentFB->m_cTex, &monbox, 1.f, 0, false, false);
+    renderTexture(m_RenderData.currentFB->m_cTex, box, 1.f, 0, false, false);
 
     blend(true);
 
@@ -1990,14 +1995,37 @@ void CHyprOpenGLImpl::saveBufferForMirror() {
 }
 
 void CHyprOpenGLImpl::renderMirrored() {
-    CBox       monbox = {0, 0, m_RenderData.pMonitor->vecPixelSize.x, m_RenderData.pMonitor->vecPixelSize.y};
 
-    const auto PFB = &m_mMonitorRenderResources[m_RenderData.pMonitor->pMirrorOf].monitorMirrorFB;
+    auto   monitor  = m_RenderData.pMonitor;
+    auto   mirrored = monitor->pMirrorOf;
+
+    double scale  = std::min(monitor->vecTransformedSize.x / mirrored->vecTransformedSize.x, monitor->vecTransformedSize.y / mirrored->vecTransformedSize.y);
+    CBox   monbox = {0, 0, mirrored->vecTransformedSize.x * scale, mirrored->vecTransformedSize.y * scale};
+
+    // transform box as it will be drawn on a transformed projection
+    monbox.transform(mirrored->transform, mirrored->vecTransformedSize.x * scale, mirrored->vecTransformedSize.y * scale);
+
+    monbox.x = (monitor->vecTransformedSize.x - monbox.w) / 2;
+    monbox.y = (monitor->vecTransformedSize.y - monbox.h) / 2;
 
+    const auto PFB = &m_mMonitorRenderResources[mirrored].monitorMirrorFB;
     if (!PFB->isAllocated() || PFB->m_cTex.m_iTexID <= 0)
         return;
 
+    // replace monitor projection to undo the mirrored monitor's projection
+    wlr_matrix_identity(monitor->projMatrix.data());
+    wlr_matrix_translate(monitor->projMatrix.data(), monitor->vecPixelSize.x / 2.0, monitor->vecPixelSize.y / 2.0);
+    wlr_matrix_transform(monitor->projMatrix.data(), monitor->transform);
+    wlr_matrix_transform(monitor->projMatrix.data(), wlr_output_transform_invert(mirrored->transform));
+    wlr_matrix_translate(monitor->projMatrix.data(), -monitor->vecTransformedSize.x / 2.0, -monitor->vecTransformedSize.y / 2.0);
+
+    // clear stuff outside of mirrored area (e.g. when changing to mirrored)
+    clear(CColor(0, 0, 0, 0));
+
     renderTexture(PFB->m_cTex, &monbox, 1.f, 0, false, false);
+
+    // reset matrix for further drawing
+    monitor->updateMatrix();
 }
 
 void CHyprOpenGLImpl::renderSplash(cairo_t* const CAIRO, cairo_surface_t* const CAIROSURFACE, double offsetY, const Vector2D& size) {
diff --git a/src/render/OpenGL.hpp b/src/render/OpenGL.hpp
index 08a1583d..32e2f1eb 100644
--- a/src/render/OpenGL.hpp
+++ b/src/render/OpenGL.hpp
@@ -67,7 +67,7 @@ struct SMonitorRenderData {
     CFramebuffer mirrorSwapFB; // etc
     CFramebuffer offMainFB;
 
-    CFramebuffer monitorMirrorFB; // used for mirroring outputs
+    CFramebuffer monitorMirrorFB; // used for mirroring outputs, does not contain artifacts like offloadFB
 
     CTexture     stencilTex;
 
@@ -172,7 +172,7 @@ class CHyprOpenGLImpl {
     bool                  preBlurQueued();
     void                  preRender(CMonitor*);
 
-    void                  saveBufferForMirror();
+    void                  saveBufferForMirror(CBox*);
     void                  renderMirrored();
 
     void                  applyScreenShader(const std::string& path);
diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 551c7264..9cba64c8 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -1262,9 +1262,7 @@ void CHyprRenderer::renderMonitor(CMonitor* pMonitor) {
     }
 
     // if we have no tracking or full tracking, invalidate the entire monitor
-    if (*PDAMAGETRACKINGMODE == DAMAGE_TRACKING_NONE || *PDAMAGETRACKINGMODE == DAMAGE_TRACKING_MONITOR || pMonitor->forceFullFrames > 0 || damageBlinkCleanup > 0 ||
-        pMonitor->isMirror() /* why??? */) {
-
+    if (*PDAMAGETRACKINGMODE == DAMAGE_TRACKING_NONE || *PDAMAGETRACKINGMODE == DAMAGE_TRACKING_MONITOR || pMonitor->forceFullFrames > 0 || damageBlinkCleanup > 0) {
         damage      = {0, 0, (int)pMonitor->vecTransformedSize.x * 10, (int)pMonitor->vecTransformedSize.y * 10};
         finalDamage = damage;
     } else {
@@ -1854,11 +1852,24 @@ void CHyprRenderer::damageRegion(const CRegion& rg) {
 
 void CHyprRenderer::damageMirrorsWith(CMonitor* pMonitor, const CRegion& pRegion) {
     for (auto& mirror : pMonitor->mirrors) {
-        Vector2D scale = {mirror->vecSize.x / pMonitor->vecSize.x, mirror->vecSize.y / pMonitor->vecSize.y};
 
-        CRegion  rg{pRegion};
-        wlr_region_scale_xy(rg.pixman(), rg.pixman(), scale.x, scale.y);
-        pMonitor->addDamage(&rg);
+        // transform the damage here, so it won't get clipped by the monitor damage ring
+        auto    monitor  = mirror;
+        auto    mirrored = pMonitor;
+
+        CRegion transformed{pRegion};
+
+        // we want to transform to the same box as in CHyprOpenGLImpl::renderMirrored
+        double scale  = std::min(monitor->vecTransformedSize.x / mirrored->vecTransformedSize.x, monitor->vecTransformedSize.y / mirrored->vecTransformedSize.y);
+        CBox   monbox = {0, 0, mirrored->vecTransformedSize.x * scale, mirrored->vecTransformedSize.y * scale};
+        monbox.x      = (monitor->vecTransformedSize.x - monbox.w) / 2;
+        monbox.y      = (monitor->vecTransformedSize.y - monbox.h) / 2;
+
+        wlr_region_scale(transformed.pixman(), transformed.pixman(), scale);
+        transformed.transform(mirrored->transform, mirrored->vecPixelSize.x * scale, mirrored->vecPixelSize.y * scale);
+        transformed.translate(Vector2D(monbox.x, monbox.y));
+
+        mirror->addDamage(&transformed);
 
         g_pCompositor->scheduleFrameForMonitor(mirror);
     }

commit eefeab5495067e7fcb1dfc52ccc904d7c3907dda
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Apr 24 16:45:54 2024 +0100

    style: fix clang-format

diff --git a/src/desktop/Window.hpp b/src/desktop/Window.hpp
index 5c2808ae..4eccba55 100644
--- a/src/desktop/Window.hpp
+++ b/src/desktop/Window.hpp
@@ -190,7 +190,7 @@ struct SWindowRule {
 };
 
 struct SInitialWorkspaceToken {
-    CWindow* primaryOwner = nullptr;
+    CWindow*    primaryOwner = nullptr;
     std::string workspace;
 };
 
diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index e74a4d53..173ecbaa 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -95,7 +95,7 @@ void Events::listener_mapWindow(void* owner, void* data) {
                 else if (*PINITIALWSTRACKING == 2) { // persistent
                     if (!WS.primaryOwner) {
                         WS.primaryOwner = PWINDOW;
-                        TOKEN->data = WS;
+                        TOKEN->data     = WS;
                     }
 
                     PWINDOW->m_szInitialWorkspaceToken = SZTOKEN;

commit d0966885f966eebdc465369a1e16845919c9cc97
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu Apr 25 16:57:11 2024 +0100

    events: set window initial* before searching for rules

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index 173ecbaa..b36cedda 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -68,6 +68,8 @@ void Events::listener_mapWindow(void* owner, void* data) {
     PWINDOW->m_szTitle        = g_pXWaylandManager->getTitle(PWINDOW);
     PWINDOW->m_iX11Type       = PWINDOW->m_bIsX11 ? (PWINDOW->m_uSurface.xwayland->override_redirect ? 2 : 1) : 1;
     PWINDOW->m_bFirstMap      = true;
+    PWINDOW->m_szInitialTitle = PWINDOW->m_szTitle;
+    PWINDOW->m_szInitialClass = g_pXWaylandManager->getAppIDClass(PWINDOW);
 
     // check for token
     std::string requestedWorkspace = "";
@@ -154,9 +156,6 @@ void Events::listener_mapWindow(void* owner, void* data) {
     bool overridingNoFullscreen = false;
     bool overridingNoMaximize   = false;
 
-    PWINDOW->m_szInitialTitle = g_pXWaylandManager->getTitle(PWINDOW);
-    PWINDOW->m_szInitialClass = g_pXWaylandManager->getAppIDClass(PWINDOW);
-
     for (auto& r : WINDOWRULES) {
         if (r.szRule.starts_with("monitor")) {
             try {

commit e649eadd40062ae35ca0c98d790d211f354305b4
Author: eriedaberrie <64395218+eriedaberrie@users.noreply.github.com>
Date:   Thu Apr 25 10:52:49 2024 -0700

    renderer: fix rounding of the size of fractionally scaled monitors (#5748)

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 9cba64c8..2bf6d290 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -2276,7 +2276,7 @@ bool CHyprRenderer::applyMonitorRule(CMonitor* pMonitor, SMonitorRule* pMonitorR
 
     int x, y;
     wlr_output_transformed_resolution(pMonitor->output, &x, &y);
-    pMonitor->vecSize            = (Vector2D(x, y) / pMonitor->scale).floor();
+    pMonitor->vecSize            = (Vector2D(x, y) / pMonitor->scale).round();
     pMonitor->vecTransformedSize = Vector2D(x, y);
 
     if (pMonitor->createdByUser) {

commit cf65bfc9663c8cd540d35d43c0f98350f2dff910
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri Apr 26 19:11:28 2024 +0100

    swipe: fix crashes with invalid distance
    
    fixes #5758

diff --git a/src/managers/input/Swipe.cpp b/src/managers/input/Swipe.cpp
index 55ef04a1..8c489af5 100644
--- a/src/managers/input/Swipe.cpp
+++ b/src/managers/input/Swipe.cpp
@@ -65,6 +65,7 @@ void CInputManager::endWorkspaceSwipe() {
     std::string wsname           = "";
     auto        workspaceIDLeft  = getWorkspaceIDFromString((*PSWIPEUSER ? "r-1" : "m-1"), wsname);
     auto        workspaceIDRight = getWorkspaceIDFromString((*PSWIPEUSER ? "r+1" : "m+1"), wsname);
+    const auto  SWIPEDISTANCE    = std::clamp(*PSWIPEDIST, (int64_t)1LL, (int64_t)UINT32_MAX);
 
     // If we've been swiping off the right end with PSWIPENEW enabled, there is
     // no workspace there yet, and we need to choose an ID for a new one now.
@@ -92,7 +93,7 @@ void CInputManager::endWorkspaceSwipe() {
 
     PHLWORKSPACE pSwitchedTo = nullptr;
 
-    if ((abs(m_sActiveSwipe.delta) < *PSWIPEDIST * *PSWIPEPERC && (*PSWIPEFORC == 0 || (*PSWIPEFORC != 0 && m_sActiveSwipe.avgSpeed < *PSWIPEFORC))) ||
+    if ((abs(m_sActiveSwipe.delta) < SWIPEDISTANCE * *PSWIPEPERC && (*PSWIPEFORC == 0 || (*PSWIPEFORC != 0 && m_sActiveSwipe.avgSpeed < *PSWIPEFORC))) ||
         abs(m_sActiveSwipe.delta) < 2) {
         // revert
         if (abs(m_sActiveSwipe.delta) < 2) {
@@ -219,9 +220,10 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
     static auto PSWIPEUSER             = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_use_r");
     static auto PWORKSPACEGAP          = CConfigValue<Hyprlang::INT>("general:gaps_workspaces");
 
-    const auto  XDISTANCE = m_sActiveSwipe.pMonitor->vecSize.x + *PWORKSPACEGAP;
-    const auto  YDISTANCE = m_sActiveSwipe.pMonitor->vecSize.y + *PWORKSPACEGAP;
-    const bool  VERTANIMS = m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle == "slidevert" ||
+    const auto  SWIPEDISTANCE = std::clamp(*PSWIPEDIST, (int64_t)1LL, (int64_t)UINT32_MAX);
+    const auto  XDISTANCE     = m_sActiveSwipe.pMonitor->vecSize.x + *PWORKSPACEGAP;
+    const auto  YDISTANCE     = m_sActiveSwipe.pMonitor->vecSize.y + *PWORKSPACEGAP;
+    const bool  VERTANIMS     = m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle == "slidevert" ||
         m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle.starts_with("slidefadevert");
     const double d       = m_sActiveSwipe.delta - delta;
     m_sActiveSwipe.delta = delta;
@@ -240,7 +242,7 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
 
     m_sActiveSwipe.pWorkspaceBegin->m_bForceRendering = true;
 
-    m_sActiveSwipe.delta = std::clamp(m_sActiveSwipe.delta, (double)-*PSWIPEDIST, (double)*PSWIPEDIST);
+    m_sActiveSwipe.delta = std::clamp(m_sActiveSwipe.delta, (double)-SWIPEDISTANCE, (double)SWIPEDISTANCE);
 
     if ((m_sActiveSwipe.pWorkspaceBegin->m_iID == workspaceIDLeft && *PSWIPENEW && (m_sActiveSwipe.delta < 0)) ||
         (m_sActiveSwipe.delta > 0 && g_pCompositor->getWindowsOnWorkspace(m_sActiveSwipe.pWorkspaceBegin->m_iID) == 0 &&
@@ -266,9 +268,9 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
                 g_pHyprRenderer->damageMonitor(m_sActiveSwipe.pMonitor);
 
                 if (VERTANIMS)
-                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE));
+                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE));
                 else
-                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE, 0));
+                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE, 0));
 
                 g_pCompositor->updateWorkspaceWindowDecos(m_sActiveSwipe.pWorkspaceBegin->m_iID);
                 return;
@@ -290,11 +292,11 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
         }
 
         if (VERTANIMS) {
-            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE - YDISTANCE));
-            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE));
+            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE - YDISTANCE));
+            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE));
         } else {
-            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE - XDISTANCE, 0));
-            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE, 0));
+            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE - XDISTANCE, 0));
+            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE, 0));
         }
 
         g_pCompositor->updateWorkspaceWindowDecos(workspaceIDLeft);
@@ -306,9 +308,9 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
                 g_pHyprRenderer->damageMonitor(m_sActiveSwipe.pMonitor);
 
                 if (VERTANIMS)
-                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE));
+                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE));
                 else
-                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE, 0));
+                    m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE, 0));
 
                 g_pCompositor->updateWorkspaceWindowDecos(m_sActiveSwipe.pWorkspaceBegin->m_iID);
                 return;
@@ -330,11 +332,11 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
         }
 
         if (VERTANIMS) {
-            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE + YDISTANCE));
-            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / *PSWIPEDIST) * YDISTANCE));
+            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE + YDISTANCE));
+            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(0, ((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * YDISTANCE));
         } else {
-            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE + XDISTANCE, 0));
-            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / *PSWIPEDIST) * XDISTANCE, 0));
+            PWORKSPACE->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE + XDISTANCE, 0));
+            m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.setValueAndWarp(Vector2D(((-m_sActiveSwipe.delta) / SWIPEDISTANCE) * XDISTANCE, 0));
         }
 
         g_pCompositor->updateWorkspaceWindowDecos(workspaceIDRight);
@@ -345,7 +347,7 @@ void CInputManager::updateWorkspaceSwipe(double delta) {
     g_pCompositor->updateWorkspaceWindowDecos(m_sActiveSwipe.pWorkspaceBegin->m_iID);
 
     if (*PSWIPEFOREVER) {
-        if (abs(m_sActiveSwipe.delta) >= *PSWIPEDIST) {
+        if (abs(m_sActiveSwipe.delta) >= SWIPEDISTANCE) {
             onSwipeEnd(nullptr);
             beginWorkspaceSwipe();
         }
diff --git a/src/managers/input/Touch.cpp b/src/managers/input/Touch.cpp
index 6fbda869..de369340 100644
--- a/src/managers/input/Touch.cpp
+++ b/src/managers/input/Touch.cpp
@@ -107,22 +107,23 @@ void CInputManager::onTouchMove(wlr_touch_motion_event* e) {
             return;
         const bool VERTANIMS = m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle == "slidevert" ||
             m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle.starts_with("slidefadevert");
-        static auto PSWIPEINVR = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_invert");
-        static auto PSWIPEDIST = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_distance");
+        static auto PSWIPEINVR    = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_invert");
+        static auto PSWIPEDIST    = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_distance");
+        const auto  SWIPEDISTANCE = std::clamp(*PSWIPEDIST, (int64_t)1LL, (int64_t)UINT32_MAX);
         // Handle the workspace swipe if there is one
         if (m_sActiveSwipe.initialDirection == -1) {
             if (*PSWIPEINVR)
-                // go from 0 to -PSWIPEDIST
-                updateWorkspaceSwipe(*PSWIPEDIST * ((VERTANIMS ? e->y : e->x) - 1));
+                // go from 0 to -SWIPEDISTANCE
+                updateWorkspaceSwipe(SWIPEDISTANCE * ((VERTANIMS ? e->y : e->x) - 1));
             else
-                // go from 0 to -PSWIPEDIST
-                updateWorkspaceSwipe(*PSWIPEDIST * (-1 * (VERTANIMS ? e->y : e->x)));
+                // go from 0 to -SWIPEDISTANCE
+                updateWorkspaceSwipe(SWIPEDISTANCE * (-1 * (VERTANIMS ? e->y : e->x)));
         } else if (*PSWIPEINVR)
-            // go from 0 to PSWIPEDIST
-            updateWorkspaceSwipe(*PSWIPEDIST * (VERTANIMS ? e->y : e->x));
+            // go from 0 to SWIPEDISTANCE
+            updateWorkspaceSwipe(SWIPEDISTANCE * (VERTANIMS ? e->y : e->x));
         else
-            // go from 0 to PSWIPEDIST
-            updateWorkspaceSwipe(*PSWIPEDIST * (1 - (VERTANIMS ? e->y : e->x)));
+            // go from 0 to SWIPEDISTANCE
+            updateWorkspaceSwipe(SWIPEDISTANCE * (1 - (VERTANIMS ? e->y : e->x)));
         return;
     }
     if (m_sTouchData.touchFocusWindow && g_pCompositor->windowValidMapped(m_sTouchData.touchFocusWindow)) {

commit a3987aced7a356ea15447321439c0aa1a1671770
Author: niki-on-github <63949202+niki-on-github@users.noreply.github.com>
Date:   Sat Apr 27 18:34:19 2024 +0200

    windowrules: add subtract window option to move rule (#5770)
    
    Co-authored-by: nix <nix@local>

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index b36cedda..72d57d59 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -390,10 +390,14 @@ void Events::listener_mapWindow(void* owner, void* data) {
                     int        posY = 0;
 
                     if (POSXSTR.starts_with("100%-")) {
-                        const auto POSXRAW = POSXSTR.substr(5);
+                        const bool subtractWindow = POSXSTR.starts_with("100%-w-");
+                        const auto POSXRAW        = (subtractWindow) ? POSXSTR.substr(7) : POSXSTR.substr(5);
                         posX =
                             PMONITOR->vecSize.x - (!POSXRAW.contains('%') ? std::stoi(POSXRAW) : std::stof(POSXRAW.substr(0, POSXRAW.length() - 1)) * 0.01 * PMONITOR->vecSize.x);
 
+                        if (subtractWindow)
+                            posX -= PWINDOW->m_vRealSize.goal().x;
+
                         if (CURSOR)
                             Debug::log(ERR, "Cursor is not compatible with 100%-, ignoring cursor!");
                     } else if (!CURSOR) {
@@ -409,10 +413,14 @@ void Events::listener_mapWindow(void* owner, void* data) {
                     }
 
                     if (POSYSTR.starts_with("100%-")) {
-                        const auto POSYRAW = POSYSTR.substr(5);
+                        const bool subtractWindow = POSYSTR.starts_with("100%-w-");
+                        const auto POSYRAW        = (subtractWindow) ? POSYSTR.substr(7) : POSYSTR.substr(5);
                         posY =
                             PMONITOR->vecSize.y - (!POSYRAW.contains('%') ? std::stoi(POSYRAW) : std::stof(POSYRAW.substr(0, POSYRAW.length() - 1)) * 0.01 * PMONITOR->vecSize.y);
 
+                        if (subtractWindow)
+                            posY -= PWINDOW->m_vRealSize.goal().y;
+
                         if (CURSOR)
                             Debug::log(ERR, "Cursor is not compatible with 100%-, ignoring cursor!");
                     } else if (!CURSOR) {

commit df878f5263f7a0940d6c08ab67f368451de95768
Author: virchau13 <virchau13@hexular.net>
Date:   Sun Apr 28 00:38:48 2024 +0800

    CrashReporter: fix deadlocks by making it mostly async-signal-safe (#5771)
    
    `CrashReporter::createAndSaveCrash()` is not async-signal-safe,
    resulting in random deadlocks/double-crashes during Hyprland crashes.
    This changes the function to be (mostly) async-signal-safe.

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 6f3ddae3..41759e3b 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -34,6 +34,14 @@ void handleUnrecoverableSignal(int sig) {
         return;
     }
 
+    // Kill the program if the crash-reporter is caught in a deadlock.
+    signal(SIGALRM, [](int _) {
+        char const* msg = "\nCrashReporter exceeded timeout, forcefully exiting\n";
+        write(2, msg, strlen(msg));
+        abort();
+    });
+    alarm(15);
+
     CrashReporter::createAndSaveCrash(sig);
 
     abort();
diff --git a/src/debug/CrashReporter.cpp b/src/debug/CrashReporter.cpp
index a4bdc761..ce1a92ba 100644
--- a/src/debug/CrashReporter.cpp
+++ b/src/debug/CrashReporter.cpp
@@ -1,59 +1,127 @@
 #include "CrashReporter.hpp"
-#include <random>
+#include <fcntl.h>
 #include <sys/utsname.h>
-#include <fstream>
-#include <signal.h>
 #include <link.h>
+#include <time.h>
+#include <errno.h>
+#include <sys/stat.h>
 
 #include "../plugins/PluginSystem.hpp"
+#include "../signal-safe.hpp"
 
 #if defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #include <sys/sysctl.h>
 #endif
 
-std::string getRandomMessage() {
-
-    const std::vector<std::string>  MESSAGES = {"Sorry, didn't mean to...",
-                                                "This was an accident, I swear!",
-                                                "Calm down, it was a misinput! MISINPUT!",
-                                                "Oops",
-                                                "Vaxry is going to be upset.",
-                                                "Who tried dividing by zero?!",
-                                                "Maybe you should try dusting your PC in the meantime?",
-                                                "I tried so hard, and got so far...",
-                                                "I don't feel so good...",
-                                                "*thud*",
-                                                "Well this is awkward.",
-                                                "\"stable\"",
-                                                "I hope you didn't have any unsaved progress.",
-                                                "All these computers..."};
-
-    std::random_device              dev;
-    std::mt19937                    engine(dev());
-    std::uniform_int_distribution<> distribution(0, MESSAGES.size() - 1);
-
-    return MESSAGES[distribution(engine)];
+static char const* const MESSAGES[] = {"Sorry, didn't mean to...",
+                                       "This was an accident, I swear!",
+                                       "Calm down, it was a misinput! MISINPUT!",
+                                       "Oops",
+                                       "Vaxry is going to be upset.",
+                                       "Who tried dividing by zero?!",
+                                       "Maybe you should try dusting your PC in the meantime?",
+                                       "I tried so hard, and got so far...",
+                                       "I don't feel so good...",
+                                       "*thud*",
+                                       "Well this is awkward.",
+                                       "\"stable\"",
+                                       "I hope you didn't have any unsaved progress.",
+                                       "All these computers..."};
+
+// <random> is not async-signal-safe, fake it with time(NULL) instead
+char const* getRandomMessage() {
+    return MESSAGES[time(NULL) % (sizeof(MESSAGES) / sizeof(MESSAGES[0]))];
+}
+
+[[noreturn]] inline void exit_with_error(char const* err) {
+    write(STDERR_FILENO, err, strlen(err));
+    // perror() is not signal-safe, but we use it here
+    // because if the crash-handler already crashed, it can't get any worse.
+    perror("");
+    abort();
 }
 
 void CrashReporter::createAndSaveCrash(int sig) {
+    int reportFd;
+
+    // We're in the signal handler, so we *only* have stack memory.
+    // To save as much stack memory as possible,
+    // destroy things as soon as possible.
+    {
+        MaxLengthCString<255> reportPath;
+
+        const auto            HOME       = sig_getenv("HOME");
+        const auto            CACHE_HOME = sig_getenv("XDG_CACHE_HOME");
+
+        if (CACHE_HOME && CACHE_HOME[0] != '\0') {
+            reportPath += CACHE_HOME;
+            reportPath += "/hyprland";
+        } else if (HOME && HOME[0] != '\0') {
+            reportPath += HOME;
+            reportPath += "/.cache/hyprland";
+        } else {
+            exit_with_error("$CACHE_HOME and $HOME not set, nowhere to report crash\n");
+            return;
+        }
 
-    // get the backtrace
-    const int   PID = getpid();
+        int ret = mkdir(reportPath.get_str(), S_IRWXU);
+        //__asm__("int $3");
+        if (ret < 0 && errno != EEXIST) {
+            exit_with_error("failed to mkdir() crash report directory\n");
+        }
+        reportPath += "/hyprlandCrashReport";
+        reportPath.write_num(getpid());
+        reportPath += ".txt";
+
+        {
+            BufFileWriter<64> stderr(2);
+            stderr += "Hyprland has crashed :( Consult the crash report at ";
+            if (!reportPath.boundsExceeded()) {
+                stderr += reportPath.get_str();
+            } else {
+                stderr += "[ERROR: Crash report path does not fit into memory! Check if your $CACHE_HOME/$HOME is too deeply nested. Max 255 characters.]";
+            }
+            stderr += " for more information.\n";
+            stderr.flush();
+        }
 
-    std::string finalCrashReport = "";
+        reportFd = open(reportPath.get_str(), O_WRONLY | O_CREAT, S_IRWXU);
+        if (reportFd < 0) {
+            exit_with_error("Failed to open crash report path for writing");
+        }
+    }
+    BufFileWriter<512> finalCrashReport(reportFd);
 
     finalCrashReport += "--------------------------------------------\n   Hyprland Crash Report\n--------------------------------------------\n";
-    finalCrashReport += getRandomMessage() + "\n\n";
-
-    finalCrashReport += std::format("Hyprland received signal {} ({})\n\n", sig, (const char*)strsignal(sig));
-
-    finalCrashReport += std::format("Version: {}\nTag: {}\n\n", GIT_COMMIT_HASH, GIT_TAG);
-
-    if (g_pPluginSystem && !g_pPluginSystem->getAllPlugins().empty()) {
+    finalCrashReport += getRandomMessage();
+    finalCrashReport += "\n\n";
+
+    finalCrashReport += "Hyprland received signal ";
+    finalCrashReport.writeNum(sig);
+    finalCrashReport += '(';
+    finalCrashReport += sig_strsignal(sig);
+    finalCrashReport += ")\nVersion: ";
+    finalCrashReport += GIT_COMMIT_HASH;
+    finalCrashReport += "\nTag: ";
+    finalCrashReport += GIT_TAG;
+    finalCrashReport += "\n\n";
+
+    if (g_pPluginSystem && g_pPluginSystem->pluginCount() > 0) {
         finalCrashReport += "Hyprland seems to be running with plugins. This crash might not be Hyprland's fault.\nPlugins:\n";
 
-        for (auto& p : g_pPluginSystem->getAllPlugins()) {
-            finalCrashReport += std::format("\t{} ({}) {}\n", p->name, p->author, p->version);
+        size_t   count = g_pPluginSystem->pluginCount();
+        CPlugin* plugins[count];
+        g_pPluginSystem->sig_getPlugins(plugins, count);
+
+        for (size_t i = 0; i < count; i++) {
+            auto p = plugins[i];
+            finalCrashReport += '\t';
+            finalCrashReport += p->name;
+            finalCrashReport += " (";
+            finalCrashReport += p->author;
+            finalCrashReport += ") ";
+            finalCrashReport += p->version;
+            finalCrashReport += '\n';
         }
 
         finalCrashReport += "\n\n";
@@ -61,21 +129,36 @@ void CrashReporter::createAndSaveCrash(int sig) {
 
     finalCrashReport += "System info:\n";
 
-    struct utsname unameInfo;
-    uname(&unameInfo);
-
-    finalCrashReport += std::format("\tSystem name: {}\n\tNode name: {}\n\tRelease: {}\n\tVersion: {}\n\n", std::string{unameInfo.sysname}, std::string{unameInfo.nodename},
-                                    std::string{unameInfo.release}, std::string{unameInfo.version});
+    {
+        struct utsname unameInfo;
+        uname(&unameInfo);
+
+        finalCrashReport += "\tSystem name: ";
+        finalCrashReport += unameInfo.sysname;
+        finalCrashReport += "\n\tNode name: ";
+        finalCrashReport += unameInfo.nodename;
+        finalCrashReport += "\n\tRelease: ";
+        finalCrashReport += unameInfo.release;
+        finalCrashReport += "\n\tVersion: ";
+        finalCrashReport += unameInfo.version;
+        finalCrashReport += "\n\n";
+    }
 
+    finalCrashReport += "GPU:\n\t";
 #if defined(__DragonFly__) || defined(__FreeBSD__)
-    const std::string GPUINFO = execAndGet("pciconf -lv | fgrep -A4 vga");
+    finalCrashReport.writeCmdOutput("pciconf -lv | fgrep -A4 vga");
 #else
-    const std::string GPUINFO = execAndGet("lspci -vnn | grep VGA");
+    finalCrashReport.writeCmdOutput("lspci -vnn | grep VGA");
 #endif
 
-    finalCrashReport += "GPU:\n\t" + GPUINFO;
+    finalCrashReport += "\n\nos-release:\n";
+    finalCrashReport.writeCmdOutput("cat /etc/os-release | sed 's/^/\t/'");
 
-    finalCrashReport += std::format("\n\nos-release:\n\t{}\n\n\n", replaceInString(execAndGet("cat /etc/os-release"), "\n", "\n\t"));
+    // dladdr1()/backtrace_symbols()/this entire section allocates, and hence is NOT async-signal-safe.
+    // Make sure that we save the current known crash report information,
+    // so that if we are caught in a deadlock during a call to malloc(),
+    // there is still something to debug from.
+    finalCrashReport.flush();
 
     finalCrashReport += "Backtrace:\n";
 
@@ -132,7 +215,10 @@ void CrashReporter::createAndSaveCrash(int sig) {
     std::stringstream ssin(ADDR2LINE);
 
     for (size_t i = 0; i < CALLSTACK.size(); ++i) {
-        finalCrashReport += std::format("\t#{} | {}", i, CALLSTACK[i].desc);
+        finalCrashReport += "\t#";
+        finalCrashReport.writeNum(i);
+        finalCrashReport += " | ";
+        finalCrashReport += CALLSTACK[i].desc;
         std::string functionInfo;
         std::string fileLineInfo;
         std::getline(ssin, functionInfo);
@@ -142,32 +228,5 @@ void CrashReporter::createAndSaveCrash(int sig) {
 
     finalCrashReport += "\n\nLog tail:\n";
 
-    finalCrashReport += Debug::rollingLog.substr(Debug::rollingLog.find("\n") + 1);
-
-    const auto HOME       = getenv("HOME");
-    const auto CACHE_HOME = getenv("XDG_CACHE_HOME");
-
-    if (!HOME)
-        return;
-
-    std::ofstream ofs;
-    std::string   reportDir;
-
-    if (!CACHE_HOME || std::string(CACHE_HOME).empty())
-        reportDir = std::string(HOME) + "/.cache/hyprland";
-    else
-        reportDir = std::string(CACHE_HOME) + "/hyprland";
-
-    if (!std::filesystem::exists(reportDir))
-        std::filesystem::create_directory(reportDir);
-    const auto path = reportDir + "/hyprlandCrashReport" + std::to_string(PID) + ".txt";
-
-    ofs.open(path, std::ios::trunc);
-
-    ofs << finalCrashReport;
-
-    ofs.close();
-
-    Debug::disableStdout = false;
-    Debug::log(CRIT, "Hyprland has crashed :( Consult the crash report at {} for more information.", path);
+    finalCrashReport += std::string_view(Debug::rollingLog).substr(Debug::rollingLog.find("\n") + 1);
 }
diff --git a/src/plugins/PluginSystem.cpp b/src/plugins/PluginSystem.cpp
index ae87aedb..d25d8c7b 100644
--- a/src/plugins/PluginSystem.cpp
+++ b/src/plugins/PluginSystem.cpp
@@ -192,3 +192,13 @@ std::vector<CPlugin*> CPluginSystem::getAllPlugins() {
         results[i] = m_vLoadedPlugins[i].get();
     return results;
 }
+
+size_t CPluginSystem::pluginCount() {
+    return m_vLoadedPlugins.size();
+}
+
+void CPluginSystem::sig_getPlugins(CPlugin** data, size_t len) {
+    for (size_t i = 0; i < std::min(m_vLoadedPlugins.size(), len); i++) {
+        data[i] = m_vLoadedPlugins[i].get();
+    }
+}
diff --git a/src/plugins/PluginSystem.hpp b/src/plugins/PluginSystem.hpp
index c618489a..57ec32bf 100644
--- a/src/plugins/PluginSystem.hpp
+++ b/src/plugins/PluginSystem.hpp
@@ -37,6 +37,8 @@ class CPluginSystem {
     CPlugin*                 getPluginByPath(const std::string& path);
     CPlugin*                 getPluginByHandle(HANDLE handle);
     std::vector<CPlugin*>    getAllPlugins();
+    size_t                   pluginCount();
+    void                     sig_getPlugins(CPlugin** data, size_t len);
 
     bool                     m_bAllowConfigVars = false;
     std::string              m_szLastError      = "";
diff --git a/src/signal-safe.cpp b/src/signal-safe.cpp
new file mode 100644
index 00000000..05ca9c65
--- /dev/null
+++ b/src/signal-safe.cpp
@@ -0,0 +1,30 @@
+#include "signal-safe.hpp"
+
+#ifndef __GLIBC__
+#include <signal.h>
+#endif
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+extern char** environ;
+
+char const*   sig_getenv(char const* name) {
+    int len = strlen(name);
+    for (char** var = environ; *var != NULL; var++) {
+        if (strncmp(*var, name, len) == 0 && (*var)[len] == '=') {
+            return (*var) + len + 1;
+        }
+    }
+    return NULL;
+}
+
+char const* sig_strsignal(int sig) {
+#ifdef __GLIBC__
+    return sigabbrev_np(sig);
+#elif defined(__DragonFly__) || defined(__FreeBSD__)
+    return sys_signame[sig];
+#else
+    return "unknown";
+#endif
+}
diff --git a/src/signal-safe.hpp b/src/signal-safe.hpp
new file mode 100644
index 00000000..22c825db
--- /dev/null
+++ b/src/signal-safe.hpp
@@ -0,0 +1,172 @@
+#pragma once
+
+#include "defines.hpp"
+
+template <uint16_t N>
+class MaxLengthCString {
+  public:
+    MaxLengthCString() : m_strPos(0), m_boundsExceeded(false) {
+        m_str[0] = '\0';
+    }
+    inline void operator+=(char const* rhs) {
+        write(rhs, strlen(rhs));
+    }
+    void write(char const* data, size_t len) {
+        if (m_boundsExceeded || m_strPos + len >= N) {
+            m_boundsExceeded = true;
+            return;
+        }
+        memcpy(m_str + m_strPos, data, len);
+        m_strPos += len;
+        m_str[m_strPos] = '\0';
+    }
+    void write(char c) {
+        if (m_boundsExceeded || m_strPos + 1 >= N) {
+            m_boundsExceeded = true;
+            return;
+        }
+        m_str[m_strPos] = c;
+        m_strPos++;
+    }
+    void write_num(size_t num) {
+        size_t d = 1;
+        while (num / 10 >= d)
+            d *= 10;
+        while (num > 0) {
+            char c = '0' + (num / d);
+            write(c);
+            num %= d;
+            d /= 10;
+        }
+    }
+    char const* get_str() {
+        return m_str;
+    };
+    bool boundsExceeded() {
+        return m_boundsExceeded;
+    };
+
+  private:
+    char   m_str[N];
+    size_t m_strPos;
+    bool   m_boundsExceeded;
+};
+
+template <uint16_t BUFSIZE>
+class BufFileWriter {
+  public:
+    inline BufFileWriter(int fd_) : m_writeBufPos(0), m_fd(fd_) {}
+    ~BufFileWriter() {
+        flush();
+    }
+    void write(char const* data, size_t len) {
+        while (len > 0) {
+            size_t to_add = std::min(len, (size_t)BUFSIZE - m_writeBufPos);
+            memcpy(m_writeBuf + m_writeBufPos, data, to_add);
+            data += to_add;
+            len -= to_add;
+            m_writeBufPos += to_add;
+            if (m_writeBufPos == BUFSIZE)
+                flush();
+        }
+    }
+    inline void write(char c) {
+        if (m_writeBufPos == BUFSIZE)
+            flush();
+        m_writeBuf[m_writeBufPos] = c;
+        m_writeBufPos++;
+    }
+    inline void operator+=(char const* str) {
+        write(str, strlen(str));
+    }
+    inline void operator+=(std::string_view str) {
+        write(str.data(), str.size());
+    }
+    inline void operator+=(char c) {
+        write(c);
+    }
+    void writeNum(size_t num) {
+        size_t d = 1;
+        while (num / 10 >= d)
+            d *= 10;
+        while (num > 0) {
+            char c = '0' + (num / d);
+            write(c);
+            num %= d;
+            d /= 10;
+        }
+    }
+    void writeCmdOutput(const char* cmd) {
+        int pipefd[2];
+        if (pipe(pipefd) < 0) {
+            *this += "<pipe(pipefd) failed with";
+            writeNum(errno);
+            *this += ">\n";
+            return;
+        }
+        // terminate child instead of waiting
+        {
+            struct sigaction act;
+            act.sa_handler = SIG_DFL;
+            sigemptyset(&act.sa_mask);
+            act.sa_flags    = SA_NOCLDWAIT;
+            act.sa_restorer = NULL;
+            sigaction(SIGCHLD, &act, NULL);
+        }
+        pid_t pid = fork();
+        if (pid < 0) {
+            *this += "<fork() failed with ";
+            writeNum(errno);
+            *this += ">\n";
+            return;
+        }
+        if (pid == 0) {
+            close(pipefd[0]);
+            dup2(pipefd[1], STDOUT_FILENO);
+            char const* const argv[] = {"/bin/sh", "-c", cmd};
+            execv("/bin/sh", (char* const*)argv);
+
+            BufFileWriter<64> failmsg(pipefd[1]);
+            failmsg += "<execv(";
+            failmsg += cmd;
+            failmsg += ") resulted in errno ";
+            failmsg.write(errno);
+            failmsg += ">\n";
+            close(pipefd[1]);
+            abort();
+        } else {
+            close(pipefd[1]);
+            int  len;
+            char readbuf[256];
+            while ((len = read(pipefd[0], readbuf, 256)) > 0) {
+                write(readbuf, len);
+            }
+            if (len < 0) {
+                *this += "<interrupted, read() resulted in errno ";
+                writeNum(errno);
+                *this += ">\n";
+            }
+            close(pipefd[0]);
+        }
+    }
+    void flush() {
+        size_t i = 0;
+        while (i < m_writeBufPos) {
+            int written = ::write(m_fd, m_writeBuf + i, m_writeBufPos - i);
+            if (written <= 0) {
+                return;
+            }
+            i += written;
+        }
+        m_writeBufPos = 0;
+    }
+
+  private:
+    char   m_writeBuf[BUFSIZE];
+    size_t m_writeBufPos;
+    int    m_fd;
+};
+
+char const* sig_getenv(char const* name);
+
+char const* sig_strsignal(int sig);

commit 720d532456d34f0fc189d77c6df0f01a2642e6e9
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 20:27:44 2024 +0100

    hyprpm: fix for multi-user + improve directory structure

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 6ac5445e..14b93d3e 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -12,6 +12,10 @@
 #include <algorithm>
 #include <format>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
 #include <toml++/toml.hpp>
 
 static std::string removeBeginEndSpacesTabs(std::string str) {
@@ -92,6 +96,22 @@ SHyprlandVersion CPluginManager::getHyprlandVersion() {
     return ver;
 }
 
+bool CPluginManager::createSafeDirectory(const std::string& path) {
+    if (path.empty() || !path.starts_with("/tmp"))
+        return false;
+
+    if (std::filesystem::exists(path))
+        std::filesystem::remove_all(path);
+
+    if (std::filesystem::exists(path))
+        return false;
+
+    if (mkdir(path.c_str(), S_IRWXU) < 0)
+        return false;
+
+    return true;
+}
+
 bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string& rev) {
     const auto HLVER = getHyprlandVersion();
 
@@ -137,24 +157,31 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
     if (!std::filesystem::exists("/tmp/hyprpm")) {
         std::filesystem::create_directory("/tmp/hyprpm");
         std::filesystem::permissions("/tmp/hyprpm", std::filesystem::perms::all, std::filesystem::perm_options::replace);
+    } else if (!std::filesystem::is_directory("/tmp/hyprpm")) {
+        std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not prepare working dir for hyprpm\n";
+        return false;
     }
 
-    if (std::filesystem::exists("/tmp/hyprpm/new")) {
-        progress.printMessageAbove(std::string{Colors::YELLOW} + "!" + Colors::RESET + " old plugin repo build files found in temp directory, removing.");
-        std::filesystem::remove_all("/tmp/hyprpm/new");
+    const std::string USERNAME = getpwuid(getuid())->pw_name;
+
+    m_szWorkingPluginDirectory = "/tmp/hyprpm/" + USERNAME;
+
+    if (!createSafeDirectory(m_szWorkingPluginDirectory)) {
+        std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not prepare working dir for repo\n";
+        return false;
     }
 
     progress.printMessageAbove(std::string{Colors::RESET} + " → Cloning " + url);
 
-    std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive " + url + " new");
+    std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive " + url + " " + USERNAME);
 
-    if (!std::filesystem::exists("/tmp/hyprpm/new")) {
+    if (!std::filesystem::exists(m_szWorkingPluginDirectory + "/.git")) {
         std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not clone the plugin repository. shell returned:\n" << ret << "\n";
         return false;
     }
 
     if (!rev.empty()) {
-        std::string ret = execAndGet("git -C /tmp/hyprpm/new reset --hard --recurse-submodules " + rev);
+        std::string ret = execAndGet("git -C " + m_szWorkingPluginDirectory + " reset --hard --recurse-submodules " + rev);
         if (ret.compare(0, 6, "fatal:") == 0) {
             std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not check out revision " << rev << ". shell returned:\n" << ret << "\n";
             return false;
@@ -168,12 +195,12 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
 
     std::unique_ptr<CManifest> pManifest;
 
-    if (std::filesystem::exists("/tmp/hyprpm/new/hyprpm.toml")) {
+    if (std::filesystem::exists(m_szWorkingPluginDirectory + "/hyprpm.toml")) {
         progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " found hyprpm manifest");
-        pManifest = std::make_unique<CManifest>(MANIFEST_HYPRPM, "/tmp/hyprpm/new/hyprpm.toml");
-    } else if (std::filesystem::exists("/tmp/hyprpm/new/hyprload.toml")) {
+        pManifest = std::make_unique<CManifest>(MANIFEST_HYPRPM, m_szWorkingPluginDirectory + "/hyprpm.toml");
+    } else if (std::filesystem::exists(m_szWorkingPluginDirectory + "/hyprload.toml")) {
         progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " found hyprload manifest");
-        pManifest = std::make_unique<CManifest>(MANIFEST_HYPRLOAD, "/tmp/hyprpm/new/hyprload.toml");
+        pManifest = std::make_unique<CManifest>(MANIFEST_HYPRLOAD, m_szWorkingPluginDirectory + "/hyprload.toml");
     }
 
     if (!pManifest) {
@@ -212,7 +239,7 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
 
             progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " commit pin " + plugin + " matched hl, resetting");
 
-            execAndGet("cd /tmp/hyprpm/new/ && git reset --hard --recurse-submodules " + plugin);
+            execAndGet("cd " + m_szWorkingPluginDirectory + " && git reset --hard --recurse-submodules " + plugin);
         }
     }
 
@@ -243,14 +270,14 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
         progress.printMessageAbove(std::string{Colors::RESET} + " → Building " + p.name);
 
         for (auto& bs : p.buildSteps) {
-            std::string cmd = std::format("cd /tmp/hyprpm/new && PKG_CONFIG_PATH=\"{}/share/pkgconfig\" {}", DataState::getHeadersPath(), bs);
+            std::string cmd = std::format("cd {} && PKG_CONFIG_PATH=\"{}/share/pkgconfig\" {}", m_szWorkingPluginDirectory, DataState::getHeadersPath(), bs);
             out += " -> " + cmd + "\n" + execAndGet(cmd) + "\n";
         }
 
         if (m_bVerbose)
             std::cout << Colors::BLUE << "[v] " << Colors::RESET << "shell returned: " << out << "\n";
 
-        if (!std::filesystem::exists("/tmp/hyprpm/new/" + p.output)) {
+        if (!std::filesystem::exists(m_szWorkingPluginDirectory + "/" + p.output)) {
             progress.printMessageAbove(std::string{Colors::RED} + "✖" + Colors::RESET + " Plugin " + p.name + " failed to build.\n" +
                                        "  This likely means that the plugin is either outdated, not yet available for your version, or broken.\n  If you are on -git, update "
                                        "first.\n  Try re-running with -v to see "
@@ -270,7 +297,7 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
 
     // add repo toml to DataState
     SPluginRepository repo;
-    std::string       repohash = execAndGet("cd /tmp/hyprpm/new/ && git rev-parse HEAD");
+    std::string       repohash = execAndGet("cd " + m_szWorkingPluginDirectory + " && git rev-parse HEAD");
     if (repohash.length() > 0)
         repohash.pop_back();
     repo.name = pManifest->m_sRepository.name.empty() ? url.substr(url.find_last_of('/') + 1) : pManifest->m_sRepository.name;
@@ -278,7 +305,7 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
     repo.rev  = rev;
     repo.hash = repohash;
     for (auto& p : pManifest->m_vPlugins) {
-        repo.plugins.push_back(SPlugin{p.name, "/tmp/hyprpm/new/" + p.output, false, p.failed});
+        repo.plugins.push_back(SPlugin{p.name, m_szWorkingPluginDirectory + "/" + p.output, false, p.failed});
     }
     DataState::addNewPluginRepo(repo);
 
@@ -291,7 +318,7 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
     std::cout << "\n";
 
     // remove build files
-    std::filesystem::remove_all("/tmp/hyprpm/new");
+    std::filesystem::remove_all(m_szWorkingPluginDirectory);
 
     return true;
 }
@@ -404,9 +431,12 @@ bool CPluginManager::updateHeaders(bool force) {
     progress.m_szCurrentMessage = "Cloning the hyprland repository";
     progress.print();
 
-    if (std::filesystem::exists("/tmp/hyprpm/hyprland")) {
-        progress.printMessageAbove(std::string{Colors::YELLOW} + "!" + Colors::RESET + " old hyprland source files found in temp directory, removing.");
-        std::filesystem::remove_all("/tmp/hyprpm/hyprland");
+    const std::string USERNAME   = getpwuid(getuid())->pw_name;
+    const auto        WORKINGDIR = "/tmp/hyprpm/hyprland-" + USERNAME;
+
+    if (!createSafeDirectory(WORKINGDIR)) {
+        std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not prepare working dir for hl\n";
+        return false;
     }
 
     progress.printMessageAbove(std::string{Colors::YELLOW} + "!" + Colors::RESET + " Cloning https://github.com/hyprwm/hyprland, this might take a moment.");
@@ -418,14 +448,14 @@ bool CPluginManager::updateHeaders(bool force) {
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "will shallow since: " + SHALLOW_DATE);
 
-    std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland --shallow-since='" + SHALLOW_DATE + "'");
+    std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland-" + USERNAME + " --shallow-since='" + SHALLOW_DATE + "'");
 
-    if (!std::filesystem::exists("/tmp/hyprpm/hyprland")) {
+    if (!std::filesystem::exists(WORKINGDIR)) {
         progress.printMessageAbove(std::string{Colors::RED} + "✖" + Colors::RESET + " Clone failed. Retrying without shallow.");
-        ret = execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland");
+        ret = execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland-" + USERNAME);
     }
 
-    if (!std::filesystem::exists("/tmp/hyprpm/hyprland")) {
+    if (!std::filesystem::exists(WORKINGDIR + "/.git")) {
         std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not clone the hyprland repository. shell returned:\n" << ret << "\n";
         return false;
     }
@@ -435,12 +465,12 @@ bool CPluginManager::updateHeaders(bool force) {
     progress.m_szCurrentMessage = "Checking out sources";
     progress.print();
 
-    ret = execAndGet("cd /tmp/hyprpm/hyprland && git checkout " + HLVER.branch + " 2>&1");
+    ret = execAndGet("cd " + WORKINGDIR + " && git checkout " + HLVER.branch + " 2>&1");
 
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "git returned (co): " + ret);
 
-    ret = execAndGet("cd /tmp/hyprpm/hyprland && git rm subprojects/tracy && git submodule update --init 2>&1 && git reset --hard --recurse-submodules " + HLVER.hash);
+    ret = execAndGet("cd " + WORKINGDIR + " && git rm subprojects/tracy && git submodule update --init 2>&1 && git reset --hard --recurse-submodules " + HLVER.hash);
 
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "git returned (rs): " + ret);
@@ -455,14 +485,13 @@ bool CPluginManager::updateHeaders(bool force) {
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "setting PREFIX for cmake to " + DataState::getHeadersPath());
 
-    ret = execAndGet(
-        std::format("cd /tmp/hyprpm/hyprland && cmake --no-warn-unused-cli -DCMAKE_BUILD_TYPE:STRING=Release -DCMAKE_INSTALL_PREFIX:STRING=\"{}\" -S . -B ./build -G Ninja",
-                    DataState::getHeadersPath()));
+    ret = execAndGet(std::format("cd {} && cmake --no-warn-unused-cli -DCMAKE_BUILD_TYPE:STRING=Release -DCMAKE_INSTALL_PREFIX:STRING=\"{}\" -S . -B ./build -G Ninja", WORKINGDIR,
+                                 DataState::getHeadersPath()));
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "cmake returned: " + ret);
 
     // le hack. Wlroots has to generate its build/include
-    ret = execAndGet("cd /tmp/hyprpm/hyprland/subprojects/wlroots-hyprland && meson setup -Drenderers=gles2 -Dexamples=false build");
+    ret = execAndGet("cd " + WORKINGDIR + "/subprojects/wlroots-hyprland && meson setup -Drenderers=gles2 -Dexamples=false build");
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "meson returned: " + ret);
 
@@ -471,8 +500,8 @@ bool CPluginManager::updateHeaders(bool force) {
     progress.m_szCurrentMessage = "Installing sources";
     progress.print();
 
-    std::string cmd = std::format("sed -i -e \"s#PREFIX = /usr/local#PREFIX = {}#\" /tmp/hyprpm/hyprland/Makefile && cd /tmp/hyprpm/hyprland && make installheaders",
-                                  DataState::getHeadersPath());
+    std::string cmd =
+        std::format("sed -i -e \"s#PREFIX = /usr/local#PREFIX = {}#\" {}/Makefile && cd {} && make installheaders", WORKINGDIR, WORKINGDIR, DataState::getHeadersPath());
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "installation will run: " + cmd);
 
@@ -482,7 +511,7 @@ bool CPluginManager::updateHeaders(bool force) {
         std::cout << Colors::BLUE << "[v] " << Colors::RESET << "installer returned: " << ret << "\n";
 
     // remove build files
-    std::filesystem::remove_all("/tmp/hyprpm/hyprland");
+    std::filesystem::remove_all(WORKINGDIR);
 
     auto HEADERSVALID = headersValid();
     if (HEADERSVALID == HEADERS_OK) {
@@ -529,6 +558,9 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
     progress.m_szCurrentMessage = "Updating repositories";
     progress.print();
 
+    const std::string USERNAME = getpwuid(getuid())->pw_name;
+    m_szWorkingPluginDirectory = "/tmp/hyprpm/" + USERNAME;
+
     for (auto& repo : REPOS) {
         bool update = forceUpdateAll;
 
@@ -538,16 +570,13 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
 
         progress.printMessageAbove(std::string{Colors::RESET} + " → checking for updates for " + repo.name);
 
-        if (std::filesystem::exists("/tmp/hyprpm/update")) {
-            progress.printMessageAbove(std::string{Colors::YELLOW} + "!" + Colors::RESET + " old update build files found in temp directory, removing.");
-            std::filesystem::remove_all("/tmp/hyprpm/update");
-        }
+        createSafeDirectory(m_szWorkingPluginDirectory);
 
         progress.printMessageAbove(std::string{Colors::RESET} + " → Cloning " + repo.url);
 
-        std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive " + repo.url + " update");
+        std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive " + repo.url + " " + USERNAME);
 
-        if (!std::filesystem::exists("/tmp/hyprpm/update")) {
+        if (!std::filesystem::exists(m_szWorkingPluginDirectory + "/.git")) {
             std::cout << "\n" << std::string{Colors::RED} + "✖" + Colors::RESET + " could not clone repo: shell returned:\n" + ret;
             return false;
         }
@@ -555,7 +584,7 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
         if (!repo.rev.empty()) {
             progress.printMessageAbove(std::string{Colors::RESET} + " → Plugin has revision set, resetting: " + repo.rev);
 
-            std::string ret = execAndGet("git -C /tmp/hyprpm/update reset --hard --recurse-submodules " + repo.rev);
+            std::string ret = execAndGet("git -C " + m_szWorkingPluginDirectory + " reset --hard --recurse-submodules " + repo.rev);
             if (ret.compare(0, 6, "fatal:") == 0) {
                 std::cout << "\n" << std::string{Colors::RED} + "✖" + Colors::RESET + " could not check out revision " + repo.rev + ": shell returned:\n" + ret;
                 return false;
@@ -564,7 +593,7 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
 
         if (!update) {
             // check if git has updates
-            std::string hash = execAndGet("cd /tmp/hyprpm/update && git rev-parse HEAD");
+            std::string hash = execAndGet("cd " + m_szWorkingPluginDirectory + " && git rev-parse HEAD");
             if (!hash.empty())
                 hash.pop_back();
 
@@ -572,7 +601,7 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
         }
 
         if (!update) {
-            std::filesystem::remove_all("/tmp/hyprpm/update");
+            std::filesystem::remove_all(m_szWorkingPluginDirectory);
             progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " repository " + repo.name + " is up-to-date.");
             progress.m_iSteps++;
             progress.print();
@@ -588,12 +617,12 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
 
         std::unique_ptr<CManifest> pManifest;
 
-        if (std::filesystem::exists("/tmp/hyprpm/update/hyprpm.toml")) {
+        if (std::filesystem::exists(m_szWorkingPluginDirectory + "/hyprpm.toml")) {
             progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " found hyprpm manifest");
-            pManifest = std::make_unique<CManifest>(MANIFEST_HYPRPM, "/tmp/hyprpm/update/hyprpm.toml");
-        } else if (std::filesystem::exists("/tmp/hyprpm/update/hyprload.toml")) {
+            pManifest = std::make_unique<CManifest>(MANIFEST_HYPRPM, m_szWorkingPluginDirectory + "/hyprpm.toml");
+        } else if (std::filesystem::exists(m_szWorkingPluginDirectory + "/hyprload.toml")) {
             progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " found hyprload manifest");
-            pManifest = std::make_unique<CManifest>(MANIFEST_HYPRLOAD, "/tmp/hyprpm/update/hyprload.toml");
+            pManifest = std::make_unique<CManifest>(MANIFEST_HYPRLOAD, m_szWorkingPluginDirectory + "/hyprload.toml");
         }
 
         if (!pManifest) {
@@ -617,7 +646,7 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
 
                 progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " commit pin " + plugin + " matched hl, resetting");
 
-                execAndGet("cd /tmp/hyprpm/update/ && git reset --hard --recurse-submodules " + plugin);
+                execAndGet("cd " + m_szWorkingPluginDirectory + " && git reset --hard --recurse-submodules " + plugin);
             }
         }
 
@@ -633,14 +662,14 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
             progress.printMessageAbove(std::string{Colors::RESET} + " → Building " + p.name);
 
             for (auto& bs : p.buildSteps) {
-                std::string cmd = std::format("cd /tmp/hyprpm/update && PKG_CONFIG_PATH=\"{}/share/pkgconfig\" {}", DataState::getHeadersPath(), bs);
+                std::string cmd = std::format("cd {} && PKG_CONFIG_PATH=\"{}/share/pkgconfig\" {}", m_szWorkingPluginDirectory, DataState::getHeadersPath(), bs);
                 out += " -> " + cmd + "\n" + execAndGet(cmd) + "\n";
             }
 
             if (m_bVerbose)
                 std::cout << Colors::BLUE << "[v] " << Colors::RESET << "shell returned: " << out << "\n";
 
-            if (!std::filesystem::exists("/tmp/hyprpm/update/" + p.output)) {
+            if (!std::filesystem::exists(m_szWorkingPluginDirectory + "/" + p.output)) {
                 std::cerr << "\n"
                           << Colors::RED << "✖" << Colors::RESET << " Plugin " << p.name << " failed to build.\n"
                           << "  This likely means that the plugin is either outdated, not yet available for your version, or broken.\n  If you are on -git, update first.\n  Try "
@@ -656,20 +685,20 @@ bool CPluginManager::updatePlugins(bool forceUpdateAll) {
         // add repo toml to DataState
         SPluginRepository newrepo = repo;
         newrepo.plugins.clear();
-        execAndGet(
-            "cd /tmp/hyprpm/update/ && git pull --recurse-submodules && git reset --hard --recurse-submodules"); // repo hash in the state.toml has to match head and not any pin
-        std::string repohash = execAndGet("cd /tmp/hyprpm/update && git rev-parse HEAD");
+        execAndGet("cd " + m_szWorkingPluginDirectory +
+                   " && git pull --recurse-submodules && git reset --hard --recurse-submodules"); // repo hash in the state.toml has to match head and not any pin
+        std::string repohash = execAndGet("cd " + m_szWorkingPluginDirectory + " && git rev-parse HEAD");
         if (repohash.length() > 0)
             repohash.pop_back();
         newrepo.hash = repohash;
         for (auto& p : pManifest->m_vPlugins) {
             const auto OLDPLUGINIT = std::find_if(repo.plugins.begin(), repo.plugins.end(), [&](const auto& other) { return other.name == p.name; });
-            newrepo.plugins.push_back(SPlugin{p.name, "/tmp/hyprpm/update/" + p.output, OLDPLUGINIT != repo.plugins.end() ? OLDPLUGINIT->enabled : false});
+            newrepo.plugins.push_back(SPlugin{p.name, m_szWorkingPluginDirectory + "/" + p.output, OLDPLUGINIT != repo.plugins.end() ? OLDPLUGINIT->enabled : false});
         }
         DataState::removePluginRepo(newrepo.name);
         DataState::addNewPluginRepo(newrepo);
 
-        std::filesystem::remove_all("/tmp/hyprpm/update");
+        std::filesystem::remove_all(m_szWorkingPluginDirectory);
 
         progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " updated " + repo.name);
     }
diff --git a/hyprpm/src/core/PluginManager.hpp b/hyprpm/src/core/PluginManager.hpp
index f934d34a..a87240e3 100644
--- a/hyprpm/src/core/PluginManager.hpp
+++ b/hyprpm/src/core/PluginManager.hpp
@@ -60,8 +60,13 @@ class CPluginManager {
 
     bool                   m_bVerbose = false;
 
+    // will delete recursively if exists!!
+    bool createSafeDirectory(const std::string& path);
+
   private:
     std::string headerError(const eHeadersErrors err);
+
+    std::string m_szWorkingPluginDirectory = "";
 };
 
 inline std::unique_ptr<CPluginManager> g_pPluginManager;

commit 2a569900a9de455021ca45e93d773affbdac301f
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 18:17:48 2024 +0100

    tokenmgr: separate getRandomUUID from registerNewToken

diff --git a/src/managers/TokenManager.cpp b/src/managers/TokenManager.cpp
index e48addd0..66f5d84e 100644
--- a/src/managers/TokenManager.cpp
+++ b/src/managers/TokenManager.cpp
@@ -10,7 +10,7 @@ std::string CUUIDToken::getUUID() {
     return uuid;
 }
 
-std::string CTokenManager::registerNewToken(std::any data, std::chrono::system_clock::duration expires) {
+std::string CTokenManager::getRandomUUID() {
     std::string uuid;
     do {
         uuid_t uuid_;
@@ -20,6 +20,12 @@ std::string CTokenManager::registerNewToken(std::any data, std::chrono::system_c
                            (uint16_t)uuid_[10], (uint16_t)uuid_[11], (uint16_t)uuid_[12], (uint16_t)uuid_[13], (uint16_t)uuid_[14], (uint16_t)uuid_[15]);
     } while (m_mTokens.contains(uuid));
 
+    return uuid;
+}
+
+std::string CTokenManager::registerNewToken(std::any data, std::chrono::system_clock::duration expires) {
+    std::string uuid = getRandomUUID();
+
     m_mTokens[uuid] = std::make_shared<CUUIDToken>(uuid, data, expires);
     return uuid;
 }
diff --git a/src/managers/TokenManager.hpp b/src/managers/TokenManager.hpp
index 45b0679a..ead02275 100644
--- a/src/managers/TokenManager.hpp
+++ b/src/managers/TokenManager.hpp
@@ -25,6 +25,7 @@ class CUUIDToken {
 class CTokenManager {
   public:
     std::string                 registerNewToken(std::any data, std::chrono::system_clock::duration expires);
+    std::string                 getRandomUUID();
 
     std::shared_ptr<CUUIDToken> getToken(const std::string& uuid);
     void                        removeToken(std::shared_ptr<CUUIDToken> token);

commit 9378225b02a227b36bd5ef6b4b68dcd51011462b
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 18:28:19 2024 +0100

    hooksystem: use a random 700 directory for assembler

diff --git a/src/plugins/HookSystem.cpp b/src/plugins/HookSystem.cpp
index 59654816..5082f54c 100644
--- a/src/plugins/HookSystem.cpp
+++ b/src/plugins/HookSystem.cpp
@@ -1,6 +1,7 @@
 #include "HookSystem.hpp"
 #include "../debug/Log.hpp"
 #include "../helpers/VarList.hpp"
+#include "../managers/TokenManager.hpp"
 
 #define register
 #include <udis86.h>
@@ -135,24 +136,30 @@ CFunctionHook::SAssembly CFunctionHook::fixInstructionProbeRIPCalls(const SInstr
         currentAddress += len;
     }
 
-    std::ofstream ofs("/tmp/hypr/.hookcode.asm", std::ios::trunc);
+    const auto RANDOMDIR = "/tmp/hypr/" + g_pTokenManager->getRandomUUID();
+
+    if (!std::filesystem::create_directory(RANDOMDIR))
+        return {};
+
+    std::filesystem::permissions(RANDOMDIR, std::filesystem::perms::owner_all, std::filesystem::perm_options::replace);
+
+    std::ofstream ofs(RANDOMDIR + "/.hookcode.asm", std::ios::trunc);
     ofs << assemblyBuilder;
     ofs.close();
-    std::string ret = execAndGet(
-        "cc -x assembler -c /tmp/hypr/.hookcode.asm -o /tmp/hypr/.hookbinary.o 2>&1 && objcopy -O binary -j .text /tmp/hypr/.hookbinary.o /tmp/hypr/.hookbinary2.o 2>&1");
+    std::string ret = execAndGet(std::string{"cc -x assembler -c " + RANDOMDIR + "/.hookcode.asm -o " + RANDOMDIR + "/.hookbinary.o 2>&1 && objcopy -O binary -j .text " +
+                                             RANDOMDIR + "/.hookbinary.o " + RANDOMDIR + "/.hookbinary2.o 2>&1"}
+                                     .c_str());
     Debug::log(LOG, "[functionhook] assembler returned:\n{}", ret);
-    if (!std::filesystem::exists("/tmp/hypr/.hookbinary2.o")) {
-        std::filesystem::remove("/tmp/hypr/.hookcode.asm");
-        std::filesystem::remove("/tmp/hypr/.hookbinary.asm");
+    if (!std::filesystem::exists(RANDOMDIR + "/.hookbinary2.o")) {
+        std::filesystem::remove(RANDOMDIR + "/.hookcode.asm");
+        std::filesystem::remove(RANDOMDIR + "/.hookbinary.asm");
         return {};
     }
 
-    std::ifstream ifs("/tmp/hypr/.hookbinary2.o", std::ios::binary);
+    std::ifstream ifs(RANDOMDIR + "/.hookbinary2.o", std::ios::binary);
     returns = {std::vector<char>(std::istreambuf_iterator<char>(ifs), {})};
     ifs.close();
-    std::filesystem::remove("/tmp/hypr/.hookcode.asm");
-    std::filesystem::remove("/tmp/hypr/.hookbinary.o");
-    std::filesystem::remove("/tmp/hypr/.hookbinary2.o");
+    std::filesystem::remove_all(RANDOMDIR);
 
     return returns;
 }

commit 6fba20b580b11d2f6afc1e7a27b07f5887be78e0
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 18:58:31 2024 +0100

    core: prefer mkdir over create_directory and permissions

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 41759e3b..55c861ab 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -14,6 +14,9 @@
 #include <ranges>
 #include "helpers/VarList.hpp"
 
+#include <sys/stat.h>
+#include <sys/types.h>
+
 int handleCritSignal(int signo, void* data) {
     Debug::log(LOG, "Hyprland received signal {}", signo);
 
@@ -61,15 +64,11 @@ CCompositor::CCompositor() {
 
     setenv("HYPRLAND_INSTANCE_SIGNATURE", m_szInstanceSignature.c_str(), true);
 
-    if (!std::filesystem::exists("/tmp/hypr")) {
-        std::filesystem::create_directory("/tmp/hypr");
-        std::filesystem::permissions("/tmp/hypr", std::filesystem::perms::all | std::filesystem::perms::sticky_bit, std::filesystem::perm_options::replace);
-    }
+    if (!std::filesystem::exists("/tmp/hypr"))
+        mkdir("/tmp/hypr", S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);
 
     const auto INSTANCEPATH = "/tmp/hypr/" + m_szInstanceSignature;
-    std::filesystem::create_directory(INSTANCEPATH);
-    std::filesystem::permissions(INSTANCEPATH, std::filesystem::perms::group_all, std::filesystem::perm_options::replace);
-    std::filesystem::permissions(INSTANCEPATH, std::filesystem::perms::owner_all, std::filesystem::perm_options::add);
+    mkdir(INSTANCEPATH.c_str(), S_IRWXU | S_IRWXG);
 
     Debug::init(m_szInstanceSignature);
 
diff --git a/src/plugins/HookSystem.cpp b/src/plugins/HookSystem.cpp
index 5082f54c..7ae71726 100644
--- a/src/plugins/HookSystem.cpp
+++ b/src/plugins/HookSystem.cpp
@@ -10,6 +10,8 @@
 #include <unistd.h>
 #include <cstring>
 #include <fstream>
+#include <sys/stat.h>
+#include <sys/types.h>
 
 CFunctionHook::CFunctionHook(HANDLE owner, void* source, void* destination) {
     m_pSource      = source;
@@ -138,10 +140,10 @@ CFunctionHook::SAssembly CFunctionHook::fixInstructionProbeRIPCalls(const SInstr
 
     const auto RANDOMDIR = "/tmp/hypr/" + g_pTokenManager->getRandomUUID();
 
-    if (!std::filesystem::create_directory(RANDOMDIR))
-        return {};
+    mkdir(RANDOMDIR.c_str(), S_IRWXU);
 
-    std::filesystem::permissions(RANDOMDIR, std::filesystem::perms::owner_all, std::filesystem::perm_options::replace);
+    if (!std::filesystem::exists(RANDOMDIR))
+        return {};
 
     std::ofstream ofs(RANDOMDIR + "/.hookcode.asm", std::ios::trunc);
     ofs << assemblyBuilder;

commit 7f27eb59510404e9b9d82599e08a97f637380d83
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 20:06:40 2024 +0100

    compositor: more fs safety around tmp directories
    
    HIS now includes a random bit, and hyprland will bail if /tmp/hypr is not a directory or if /tmp/hypr/his exists

diff --git a/hyprctl/main.cpp b/hyprctl/main.cpp
index 3337cbff..9b2c2fd2 100644
--- a/hyprctl/main.cpp
+++ b/hyprctl/main.cpp
@@ -51,7 +51,7 @@ std::vector<SInstanceData> instances() {
         data->id            = data->id.substr(data->id.find_last_of('/') + 1, data->id.find(".lock") - data->id.find_last_of('/') - 1);
 
         try {
-            data->time = std::stoull(data->id.substr(data->id.find_first_of('_') + 1));
+            data->time = std::stoull(data->id.substr(data->id.find_first_of('_') + 1, data->id.find_last_of('_') - (data->id.find_first_of('_') + 1)));
         } catch (std::exception& e) { continue; }
 
         // read file
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 55c861ab..53c9c1b1 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -60,15 +60,32 @@ void handleUserSignal(int sig) {
 CCompositor::CCompositor() {
     m_iHyprlandPID = getpid();
 
-    m_szInstanceSignature = GIT_COMMIT_HASH + std::string("_") + std::to_string(time(NULL));
+    std::random_device              dev;
+    std::mt19937                    engine(dev());
+    std::uniform_int_distribution<> distribution(0, INT32_MAX);
+
+    m_szInstanceSignature = GIT_COMMIT_HASH + std::string("_") + std::to_string(time(NULL)) + "_" + std::to_string(distribution(engine));
 
     setenv("HYPRLAND_INSTANCE_SIGNATURE", m_szInstanceSignature.c_str(), true);
 
     if (!std::filesystem::exists("/tmp/hypr"))
         mkdir("/tmp/hypr", S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);
+    else if (!std::filesystem::is_directory("/tmp/hypr")) {
+        std::cout << "Bailing out, /tmp/hypr is not a directory\n";
+        return;
+    }
 
     const auto INSTANCEPATH = "/tmp/hypr/" + m_szInstanceSignature;
-    mkdir(INSTANCEPATH.c_str(), S_IRWXU | S_IRWXG);
+
+    if (std::filesystem::exists(INSTANCEPATH)) {
+        std::cout << "Bailing out, /tmp/hypr/$HIS exists??\n";
+        return;
+    }
+
+    if (mkdir(INSTANCEPATH.c_str(), S_IRWXU) < 0) {
+        std::cout << "Bailing out, couldn't create /tmp/hypr/$HIS\n";
+        return;
+    }
 
     Debug::init(m_szInstanceSignature);
 

commit f75a92ee255fd8827fe7cd10a7453e0fadabe31a
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Apr 28 21:32:22 2024 +0100

    hyprpm: fix updating headers
    
    oopsie daisy

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 14b93d3e..72ec7861 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -501,7 +501,7 @@ bool CPluginManager::updateHeaders(bool force) {
     progress.print();
 
     std::string cmd =
-        std::format("sed -i -e \"s#PREFIX = /usr/local#PREFIX = {}#\" {}/Makefile && cd {} && make installheaders", WORKINGDIR, WORKINGDIR, DataState::getHeadersPath());
+        std::format("sed -i -e \"s#PREFIX = /usr/local#PREFIX = {}#\" {}/Makefile && cd {} && make installheaders", DataState::getHeadersPath(), WORKINGDIR, WORKINGDIR);
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "installation will run: " + cmd);
 

commit f5e0c7f61348779dc2810394571485ddbb0fc09e
Author: Vaxry <43317083+vaxerski@users.noreply.github.com>
Date:   Sun Apr 28 22:25:24 2024 +0100

    core: Move /tmp/hypr to $XDG_RUNTIME_DIR/hypr (#5788)
    
    Moves the directory containing sockets and logs.
    Also restructures lockfiles a bit.
    
    For consumers, check if `$XDG_RUNTIME_DIR/hypr` exists. If so, use it. If not, use the old `/tmp/hypr`.

diff --git a/docs/ISSUE_GUIDELINES.md b/docs/ISSUE_GUIDELINES.md
index c031fe85..2f6cbbf8 100644
--- a/docs/ISSUE_GUIDELINES.md
+++ b/docs/ISSUE_GUIDELINES.md
@@ -34,16 +34,16 @@ If your bug crashes Hyprland, append additionally:
 ## Obtaining the Hyprland log
 If you are in a TTY, and the hyprland session that crashed was the last one you launched, the log will be printed with
 ```
-cat /tmp/hypr/$(ls -t /tmp/hypr/ | head -n 1)/hyprland.log
+cat $XDG_RUNTIME_DIR/hypr/$(ls -t $XDG_RUNTIME_DIR/hypr | head -n 1)/hyprland.log
 ```
 feel free to send it to a file, save, copy, etc.
 
 if you are in a Hyprland session, and you want the log of the last session, use
 ```
-cat /tmp/hypr/$(ls -t /tmp/hypr/ | head -n 2 | tail -n 1)/hyprland.log
+cat $XDG_RUNTIME_DIR/hypr/$(ls -t $XDG_RUNTIME_DIR/hypr | head -n 2 | tail -n 1)/hyprland.log
 ```
 
-basically, directories in /tmp/hypr are your sessions.
+basically, directories in $XDG_RUNTIME_DIR/hypr are your sessions.
 
 ## Obtaining the Hyprland Crash Report (v0.22.0beta and up)
 
diff --git a/hyprctl/main.cpp b/hyprctl/main.cpp
index 9b2c2fd2..dad49fc4 100644
--- a/hyprctl/main.cpp
+++ b/hyprctl/main.cpp
@@ -8,6 +8,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
+#include <pwd.h>
 #include <unistd.h>
 #include <ranges>
 #include <algorithm>
@@ -41,21 +42,22 @@ struct SInstanceData {
 std::vector<SInstanceData> instances() {
     std::vector<SInstanceData> result;
 
-    for (const auto& el : std::filesystem::directory_iterator("/tmp/hypr")) {
-        if (el.is_directory() || !el.path().string().ends_with(".lock"))
+    const std::string          USERID = std::to_string(getpwuid(getuid())->pw_uid);
+
+    for (const auto& el : std::filesystem::directory_iterator("/run/user/" + USERID + "/hypr")) {
+        if (!el.is_directory() || !std::filesystem::exists(el.path().string() + "/hyprland.lock"))
             continue;
 
         // read lock
         SInstanceData* data = &result.emplace_back();
         data->id            = el.path().string();
-        data->id            = data->id.substr(data->id.find_last_of('/') + 1, data->id.find(".lock") - data->id.find_last_of('/') - 1);
 
         try {
             data->time = std::stoull(data->id.substr(data->id.find_first_of('_') + 1, data->id.find_last_of('_') - (data->id.find_first_of('_') + 1)));
         } catch (std::exception& e) { continue; }
 
         // read file
-        std::ifstream ifs(el.path().string());
+        std::ifstream ifs(el.path().string() + "/hyprland.lock");
 
         int           i = 0;
         for (std::string line; std::getline(ifs, line); ++i) {
@@ -99,10 +101,12 @@ void request(std::string arg, int minArgs = 0) {
         return;
     }
 
-    sockaddr_un serverAddress = {0};
-    serverAddress.sun_family  = AF_UNIX;
+    const std::string USERID = std::to_string(getpwuid(getuid())->pw_uid);
 
-    std::string socketPath = "/tmp/hypr/" + instanceSignature + "/.socket.sock";
+    sockaddr_un       serverAddress = {0};
+    serverAddress.sun_family        = AF_UNIX;
+
+    std::string socketPath = "/run/user/" + USERID + "/hypr/" + instanceSignature + "/.socket.sock";
 
     strncpy(serverAddress.sun_path, socketPath.c_str(), sizeof(serverAddress.sun_path) - 1);
 
@@ -160,7 +164,9 @@ void requestHyprpaper(std::string arg) {
     sockaddr_un serverAddress = {0};
     serverAddress.sun_family  = AF_UNIX;
 
-    std::string socketPath = "/tmp/hypr/" + instanceSignature + "/.hyprpaper.sock";
+    const std::string USERID = std::to_string(getpwuid(getuid())->pw_uid);
+
+    std::string       socketPath = "/run/user/" + USERID + "/hypr/" + instanceSignature + "/.hyprpaper.sock";
 
     strncpy(serverAddress.sun_path, socketPath.c_str(), sizeof(serverAddress.sun_path) - 1);
 
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 53c9c1b1..074759f3 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -14,8 +14,8 @@
 #include <ranges>
 #include "helpers/VarList.hpp"
 
-#include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 
 int handleCritSignal(int signo, void* data) {
     Debug::log(LOG, "Hyprland received signal {}", signo);
@@ -60,6 +60,16 @@ void handleUserSignal(int sig) {
 CCompositor::CCompositor() {
     m_iHyprlandPID = getpid();
 
+    m_szHyprTempDataRoot = std::string{getenv("XDG_RUNTIME_DIR")} + "/hypr";
+
+    if (m_szHyprTempDataRoot.starts_with("/hypr")) {
+        std::cout << "Bailing out, XDG_RUNTIME_DIR is invalid\n";
+        throw std::runtime_error("CCompositor() failed");
+    }
+
+    if (!m_szHyprTempDataRoot.starts_with("/run/user"))
+        std::cout << "[!!WARNING!!] XDG_RUNTIME_DIR looks non-standard. Proceeding anyways...\n";
+
     std::random_device              dev;
     std::mt19937                    engine(dev());
     std::uniform_int_distribution<> distribution(0, INT32_MAX);
@@ -68,29 +78,31 @@ CCompositor::CCompositor() {
 
     setenv("HYPRLAND_INSTANCE_SIGNATURE", m_szInstanceSignature.c_str(), true);
 
-    if (!std::filesystem::exists("/tmp/hypr"))
-        mkdir("/tmp/hypr", S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);
-    else if (!std::filesystem::is_directory("/tmp/hypr")) {
-        std::cout << "Bailing out, /tmp/hypr is not a directory\n";
-        return;
+    if (!std::filesystem::exists(m_szHyprTempDataRoot))
+        mkdir(m_szHyprTempDataRoot.c_str(), S_IRWXU);
+    else if (!std::filesystem::is_directory(m_szHyprTempDataRoot)) {
+        std::cout << "Bailing out, " << m_szHyprTempDataRoot << " is not a directory\n";
+        throw std::runtime_error("CCompositor() failed");
     }
 
-    const auto INSTANCEPATH = "/tmp/hypr/" + m_szInstanceSignature;
+    m_szInstancePath = m_szHyprTempDataRoot + "/" + m_szInstanceSignature;
 
-    if (std::filesystem::exists(INSTANCEPATH)) {
-        std::cout << "Bailing out, /tmp/hypr/$HIS exists??\n";
-        return;
+    if (std::filesystem::exists(m_szInstancePath)) {
+        std::cout << "Bailing out, " << m_szInstancePath << " exists??\n";
+        throw std::runtime_error("CCompositor() failed");
     }
 
-    if (mkdir(INSTANCEPATH.c_str(), S_IRWXU) < 0) {
-        std::cout << "Bailing out, couldn't create /tmp/hypr/$HIS\n";
-        return;
+    if (mkdir(m_szInstancePath.c_str(), S_IRWXU) < 0) {
+        std::cout << "Bailing out, couldn't create " << m_szInstancePath << "\n";
+        throw std::runtime_error("CCompositor() failed");
     }
 
-    Debug::init(m_szInstanceSignature);
+    Debug::init(m_szInstancePath);
 
     Debug::log(LOG, "Instance Signature: {}", m_szInstanceSignature);
 
+    Debug::log(LOG, "Runtime directory: {}", m_szInstancePath);
+
     Debug::log(LOG, "Hyprland PID: {}", m_iHyprlandPID);
 
     Debug::log(LOG, "===== SYSTEM INFO: =====");
@@ -550,7 +562,7 @@ void CCompositor::initManagers(eManagersInitStage stage) {
 }
 
 void CCompositor::createLockFile() {
-    const auto    PATH = "/tmp/hypr/" + m_szInstanceSignature + ".lock";
+    const auto    PATH = m_szInstancePath + "/hyprland.lock";
 
     std::ofstream ofs(PATH, std::ios::trunc);
 
@@ -560,7 +572,7 @@ void CCompositor::createLockFile() {
 }
 
 void CCompositor::removeLockFile() {
-    const auto PATH = "/tmp/hypr/" + m_szInstanceSignature + ".lock";
+    const auto PATH = m_szInstancePath + "/hyprland.lock";
 
     if (std::filesystem::exists(PATH))
         std::filesystem::remove(PATH);
diff --git a/src/Compositor.hpp b/src/Compositor.hpp
index 9244c673..34ea322a 100644
--- a/src/Compositor.hpp
+++ b/src/Compositor.hpp
@@ -84,8 +84,11 @@ class CCompositor {
     wlr_cursor_shape_manager_v1*               m_sWLRCursorShapeMgr;
     // ------------------------------------------------- //
 
+    std::string                               m_szHyprTempDataRoot = "";
+
     std::string                               m_szWLDisplaySocket   = "";
     std::string                               m_szInstanceSignature = "";
+    std::string                               m_szInstancePath      = "";
     std::string                               m_szCurrentSplash     = "error";
 
     std::vector<std::shared_ptr<CMonitor>>    m_vMonitors;
diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index 9fc227c7..a8f39f27 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -1746,7 +1746,7 @@ void CHyprCtl::startHyprCtlSocket() {
 
     sockaddr_un SERVERADDRESS = {.sun_family = AF_UNIX};
 
-    std::string socketPath = "/tmp/hypr/" + g_pCompositor->m_szInstanceSignature + "/.socket.sock";
+    std::string socketPath = g_pCompositor->m_szInstancePath + "/.socket.sock";
 
     strcpy(SERVERADDRESS.sun_path, socketPath.c_str());
 
diff --git a/src/debug/Log.cpp b/src/debug/Log.cpp
index 66c430d5..2e8795a6 100644
--- a/src/debug/Log.cpp
+++ b/src/debug/Log.cpp
@@ -6,7 +6,7 @@
 #include <iostream>
 
 void Debug::init(const std::string& IS) {
-    logFile = "/tmp/hypr/" + IS + (ISDEBUG ? "/hyprlandd.log" : "/hyprland.log");
+    logFile = IS + (ISDEBUG ? "/hyprlandd.log" : "/hyprland.log");
 }
 
 void Debug::wlrLog(wlr_log_importance level, const char* fmt, va_list args) {
diff --git a/src/main.cpp b/src/main.cpp
index e1f43ad0..7e6fee02 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -97,8 +97,13 @@ int main(int argc, char** argv) {
 
     // let's init the compositor.
     // it initializes basic Wayland stuff in the constructor.
-    g_pCompositor                     = std::make_unique<CCompositor>();
-    g_pCompositor->explicitConfigPath = configPath;
+    try {
+        g_pCompositor                     = std::make_unique<CCompositor>();
+        g_pCompositor->explicitConfigPath = configPath;
+    } catch (std::exception& e) {
+        std::cout << "Hyprland threw in ctor: " << e.what() << "\nCannot continue.\n";
+        return 1;
+    }
 
     g_pCompositor->initServer();
 
diff --git a/src/managers/EventManager.cpp b/src/managers/EventManager.cpp
index 57824430..8605768c 100644
--- a/src/managers/EventManager.cpp
+++ b/src/managers/EventManager.cpp
@@ -39,7 +39,7 @@ void CEventManager::startThread() {
     }
 
     sockaddr_un SERVERADDRESS = {.sun_family = AF_UNIX};
-    std::string socketPath    = "/tmp/hypr/" + g_pCompositor->m_szInstanceSignature + "/.socket2.sock";
+    std::string socketPath    = g_pCompositor->m_szInstancePath + "/.socket2.sock";
     strncpy(SERVERADDRESS.sun_path, socketPath.c_str(), sizeof(SERVERADDRESS.sun_path) - 1);
 
     bind(m_iSocketFD, (sockaddr*)&SERVERADDRESS, SUN_LEN(&SERVERADDRESS));
diff --git a/src/plugins/HookSystem.cpp b/src/plugins/HookSystem.cpp
index 7ae71726..5c9a5cca 100644
--- a/src/plugins/HookSystem.cpp
+++ b/src/plugins/HookSystem.cpp
@@ -2,6 +2,7 @@
 #include "../debug/Log.hpp"
 #include "../helpers/VarList.hpp"
 #include "../managers/TokenManager.hpp"
+#include "../Compositor.hpp"
 
 #define register
 #include <udis86.h>
@@ -138,7 +139,7 @@ CFunctionHook::SAssembly CFunctionHook::fixInstructionProbeRIPCalls(const SInstr
         currentAddress += len;
     }
 
-    const auto RANDOMDIR = "/tmp/hypr/" + g_pTokenManager->getRandomUUID();
+    const auto RANDOMDIR = g_pCompositor->m_szInstancePath + "/" + g_pTokenManager->getRandomUUID();
 
     mkdir(RANDOMDIR.c_str(), S_IRWXU);
 

commit 12c6319835ad5a2f99eb4a0e1b6675ae58699f7b
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon Apr 29 16:10:22 2024 +0100

    hyprctl: make commits wrapped in quotes in json

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index a8f39f27..ec0fca8e 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -834,7 +834,7 @@ std::string versionRequest(eHyprCtlOutputFormat format, std::string request) {
     "commit_message": "{}",
     "commit_date": "{}",
     "tag": "{}",
-    "commits": {},
+    "commits": "{}",
     "flags": [)#",
             GIT_BRANCH, GIT_COMMIT_HASH, (strcmp(GIT_DIRTY, "dirty") == 0 ? "true" : "false"), escapeJSONStrings(commitMsg), GIT_COMMIT_DATE, GIT_TAG, GIT_COMMITS);
 

commit 22d0c815c35b2d2198c1aadb59e24b1d6c86ab7b
Author: Sungyoon Cho <sungyoon@sungyooncho.dev>
Date:   Tue Apr 30 22:13:36 2024 +0900

    hyprctl: add missing json string escapes (#5811)

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index ec0fca8e..a19d4d95 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -107,9 +107,10 @@ std::string monitorsRequest(eHyprCtlOutputFormat format, std::string request) {
     "currentFormat": "{}",
     "availableModes": [{}]
 }},)#",
-                m->ID, escapeJSONStrings(m->szName), escapeJSONStrings(m->szShortDescription), (m->output->make ? m->output->make : ""), (m->output->model ? m->output->model : ""),
-                (m->output->serial ? m->output->serial : ""), (int)m->vecPixelSize.x, (int)m->vecPixelSize.y, m->refreshRate, (int)m->vecPosition.x, (int)m->vecPosition.y,
-                m->activeWorkspaceID(), (!m->activeWorkspace ? "" : escapeJSONStrings(m->activeWorkspace->m_szName)), m->activeSpecialWorkspaceID(),
+                m->ID, escapeJSONStrings(m->szName), escapeJSONStrings(m->szShortDescription), escapeJSONStrings(m->output->make ? m->output->make : ""),
+                escapeJSONStrings(m->output->model ? m->output->model : ""), escapeJSONStrings(m->output->serial ? m->output->serial : ""), (int)m->vecPixelSize.x,
+                (int)m->vecPixelSize.y, m->refreshRate, (int)m->vecPosition.x, (int)m->vecPosition.y, m->activeWorkspaceID(),
+                (!m->activeWorkspace ? "" : escapeJSONStrings(m->activeWorkspace->m_szName)), m->activeSpecialWorkspaceID(),
                 escapeJSONStrings(m->activeSpecialWorkspace ? m->activeSpecialWorkspace->m_szName : ""), (int)m->vecReservedTopLeft.x, (int)m->vecReservedTopLeft.y,
                 (int)m->vecReservedBottomRight.x, (int)m->vecReservedBottomRight.y, m->scale, (int)m->transform, (m.get() == g_pCompositor->m_pLastMonitor ? "true" : "false"),
                 (m->dpmsStatus ? "true" : "false"), (m->output->adaptive_sync_status == WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED ? "true" : "false"),
@@ -595,7 +596,7 @@ std::string devicesRequest(eHyprCtlOutputFormat format, std::string request) {
         "address": "0x{:x}",
         "name": "{}"
     }},)#",
-                (uintptr_t)&d, d.name);
+                (uintptr_t)&d, escapeJSONStrings(d.name));
         }
 
         trimTrailingComma(result);
@@ -609,7 +610,7 @@ std::string devicesRequest(eHyprCtlOutputFormat format, std::string request) {
         "address": "0x{:x}",
         "name": "{}"
     }},)#",
-                (uintptr_t)&d, d.pWlrDevice ? d.pWlrDevice->name : "");
+                (uintptr_t)&d, escapeJSONStrings(d.pWlrDevice ? d.pWlrDevice->name : ""));
         }
 
         trimTrailingComma(result);
@@ -694,8 +695,8 @@ std::string animationsRequest(eHyprCtlOutputFormat format, std::string request)
     "speed": {:.2f},
     "style": "{}"
 }},)#",
-                               ac.first, ac.second.overridden ? "true" : "false", ac.second.internalBezier, ac.second.internalEnabled ? "true" : "false", ac.second.internalSpeed,
-                               ac.second.internalStyle);
+                               ac.first, ac.second.overridden ? "true" : "false", escapeJSONStrings(ac.second.internalBezier), ac.second.internalEnabled ? "true" : "false",
+                               ac.second.internalSpeed, escapeJSONStrings(ac.second.internalStyle));
         }
 
         ret[ret.length() - 1] = ']';
@@ -707,7 +708,7 @@ std::string animationsRequest(eHyprCtlOutputFormat format, std::string request)
 {{
     "name": "{}"
 }},)#",
-                               bz.first);
+                               escapeJSONStrings(bz.first));
         }
 
         trimTrailingComma(ret);

commit 0a8fe444b6fc1dadbd54357ca8944150846e1875
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 30 14:17:32 2024 +0100

    hyprctl: use XDG_RUNTIME_DIR if available
    
    fixes #5813

diff --git a/hyprctl/main.cpp b/hyprctl/main.cpp
index dad49fc4..2d1b5a76 100644
--- a/hyprctl/main.cpp
+++ b/hyprctl/main.cpp
@@ -39,12 +39,21 @@ struct SInstanceData {
     bool        valid = true;
 };
 
+std::string getRuntimeDir() {
+    const auto XDG = getenv("XDG_RUNTIME_DIR");
+
+    if (!XDG) {
+        const std::string USERID = std::to_string(getpwuid(getuid())->pw_uid);
+        return "/run/user/" + USERID + "/hypr";
+    }
+
+    return std::string{XDG} + "/hypr";
+}
+
 std::vector<SInstanceData> instances() {
     std::vector<SInstanceData> result;
 
-    const std::string          USERID = std::to_string(getpwuid(getuid())->pw_uid);
-
-    for (const auto& el : std::filesystem::directory_iterator("/run/user/" + USERID + "/hypr")) {
+    for (const auto& el : std::filesystem::directory_iterator(getRuntimeDir())) {
         if (!el.is_directory() || !std::filesystem::exists(el.path().string() + "/hyprland.lock"))
             continue;
 
@@ -106,7 +115,7 @@ void request(std::string arg, int minArgs = 0) {
     sockaddr_un       serverAddress = {0};
     serverAddress.sun_family        = AF_UNIX;
 
-    std::string socketPath = "/run/user/" + USERID + "/hypr/" + instanceSignature + "/.socket.sock";
+    std::string socketPath = getRuntimeDir() + "/" + instanceSignature + "/.socket.sock";
 
     strncpy(serverAddress.sun_path, socketPath.c_str(), sizeof(serverAddress.sun_path) - 1);
 
@@ -166,7 +175,7 @@ void requestHyprpaper(std::string arg) {
 
     const std::string USERID = std::to_string(getpwuid(getuid())->pw_uid);
 
-    std::string       socketPath = "/run/user/" + USERID + "/hypr/" + instanceSignature + "/.hyprpaper.sock";
+    std::string       socketPath = getRuntimeDir() + "/" + instanceSignature + "/.hyprpaper.sock";
 
     strncpy(serverAddress.sun_path, socketPath.c_str(), sizeof(serverAddress.sun_path) - 1);
 

commit c52eeb77a40f6d3d700f1c64af3c5990397761a1
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Apr 30 16:42:31 2024 +0100

    keybinds: check for special workspace equality before switching
    
    fixes #5814

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index ad863274..ff00438b 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1832,7 +1832,8 @@ void CKeybindManager::focusWindow(std::string regexp) {
         return;
     }
 
-    if (g_pCompositor->m_pLastMonitor->activeWorkspace != PWINDOW->m_pWorkspace) {
+    if (g_pCompositor->m_pLastMonitor && g_pCompositor->m_pLastMonitor->activeWorkspace != PWINDOW->m_pWorkspace &&
+        g_pCompositor->m_pLastMonitor->activeSpecialWorkspace != PWINDOW->m_pWorkspace) {
         Debug::log(LOG, "Fake executing workspace to move focus");
         changeworkspace(PWORKSPACE->getConfigName());
     }

commit 55921134cfd6f1e7095516d810ee04034246bb8e
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed May 1 00:32:42 2024 +0100

    makefile: fix old headers only being copied

diff --git a/Makefile b/Makefile
index 432dd4eb..41480427 100644
--- a/Makefile
+++ b/Makefile
@@ -22,7 +22,7 @@ debug:
 
 clear:
 	rm -rf build
-	rm -f ./protocols/*-protocol.h ./protocols/*-protocol.c
+	rm -f ./protocols/*.h ./protocols/*.c ./protocols/*.cpp ./protocols/*.hpp
 	rm -rf ./subprojects/wlroots-hyprland/build
 
 all:
@@ -95,7 +95,8 @@ installheaders:
 	find src -name '*.h*' -print0 | cpio --quiet -0dump ${PREFIX}/include/hyprland
 	cd subprojects/wlroots-hyprland/include && find . -name '*.h*' -print0 | cpio --quiet -0dump ${PREFIX}/include/hyprland/wlroots-hyprland && cd ../../..
 	cd subprojects/wlroots-hyprland/build/include && find . -name '*.h*' -print0 | cpio --quiet -0dump ${PREFIX}/include/hyprland/wlroots-hyprland && cd ../../../..
-	cp ./protocols/*-protocol.h ${PREFIX}/include/hyprland/protocols
+	cp ./protocols/*.h ${PREFIX}/include/hyprland/protocols
+	cp ./protocols/*.hpp ${PREFIX}/include/hyprland/protocols
 	cp ./build/hyprland.pc ${PREFIX}/share/pkgconfig
 	if [ -d /usr/share/pkgconfig ]; then cp ./build/hyprland.pc /usr/share/pkgconfig 2>/dev/null || true; fi
 

commit a6bce82dda54bd59dbd8d4dc8dfc7ad63da3f18d
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed May 1 16:47:31 2024 +0100

    hyprctl: fix instances path
    
    fixes #5831

diff --git a/hyprctl/main.cpp b/hyprctl/main.cpp
index 2d1b5a76..097ef5d8 100644
--- a/hyprctl/main.cpp
+++ b/hyprctl/main.cpp
@@ -59,7 +59,7 @@ std::vector<SInstanceData> instances() {
 
         // read lock
         SInstanceData* data = &result.emplace_back();
-        data->id            = el.path().string();
+        data->id            = el.path().filename().string();
 
         try {
             data->time = std::stoull(data->id.substr(data->id.find_first_of('_') + 1, data->id.find_last_of('_') - (data->id.find_first_of('_') + 1)));

commit 6d2a268b1872c59667d89b59bd8a177583bc402b
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu May 2 14:47:05 2024 +0100

    cursormgr: attempt using - instead of _ for failed cursors before fallback
    
    web uses -, and thus some themes might use - too. Attempt replacing _ with - before assuming a shape is missing.

diff --git a/src/managers/CursorManager.cpp b/src/managers/CursorManager.cpp
index 51f012b4..c7e47120 100644
--- a/src/managers/CursorManager.cpp
+++ b/src/managers/CursorManager.cpp
@@ -116,6 +116,14 @@ void CCursorManager::setCursorFromName(const std::string& name) {
 
     m_sCurrentCursorShapeData = m_pHyprcursor->getShape(name.c_str(), m_sCurrentStyleInfo);
 
+    if (m_sCurrentCursorShapeData.images.size() < 1) {
+        // try with '-' first (xcursor, web, etc)
+        std::string newName = name;
+        std::replace(newName.begin(), newName.end(), '_', '-');
+
+        m_sCurrentCursorShapeData = m_pHyprcursor->getShape(newName.c_str(), m_sCurrentStyleInfo);
+    }
+
     if (m_sCurrentCursorShapeData.images.size() < 1) {
         // fallback to a default if available
         constexpr const std::array<const char*, 2> fallbackShapes = {"default", "left_ptr"};

commit b90acfe1667b0299b02f06587ad4fdce660694a3
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Fri May 3 15:42:08 2024 +0200

    internal: fix a few asan reported leaks on exit of hyprland (#5852)
    
    * notifications: free cairo images on destruction
    
    asan reports a leak on exit if we dont free the image we created in the
    draw function. add a destructor and free images on exit.
    
    * compositor: destroy wlroots types on exit
    
    there are a few types not being destroyed on exit and causing a leak on
    exit in wlroots reported by asan, add those.
    
    * cursormgr: ensure we destroy cursor mgr on exit
    
    add a destructor and call wlr_xcursor_manager_destroy on the manager on
    destruction, leak reported by asan.
    
    * keybindmgr: free state and keymap
    
    add missing keymap_unref on creation, and add a destructor and free the
    state on exit. leak reported by asan.
    
    * skeyboard: add destructor and free state
    
    free the state on destruction of keyboard, reported as leak by asan

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 074759f3..27b89995 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -477,8 +477,22 @@ void CCompositor::cleanup() {
     g_pWatchdog.reset();
     g_pXWaylandManager.reset();
 
-    wl_display_terminate(m_sWLDisplay);
+    if (m_sWLRCursor)
+        wlr_cursor_destroy(m_sWLRCursor);
+
+    if (m_sSeat.seat)
+        wlr_seat_destroy(m_sSeat.seat);
+
+    if (m_sWLRRenderer)
+        wlr_renderer_destroy(m_sWLRRenderer);
+
+    if (m_sWLRAllocator)
+        wlr_allocator_destroy(m_sWLRAllocator);
 
+    if (m_sWLRBackend)
+        wlr_backend_destroy(m_sWLRBackend);
+
+    wl_display_terminate(m_sWLDisplay);
     m_sWLDisplay = nullptr;
 }
 
diff --git a/src/debug/HyprNotificationOverlay.cpp b/src/debug/HyprNotificationOverlay.cpp
index 2f00d978..80c80601 100644
--- a/src/debug/HyprNotificationOverlay.cpp
+++ b/src/debug/HyprNotificationOverlay.cpp
@@ -36,6 +36,13 @@ CHyprNotificationOverlay::CHyprNotificationOverlay() {
     m_szIconFontName = fonts.substr(COLON + 2, LASTCHAR - (COLON + 2));
 }
 
+CHyprNotificationOverlay::~CHyprNotificationOverlay() {
+    if (m_pCairo)
+        cairo_destroy(m_pCairo);
+    if (m_pCairoSurface)
+        cairo_surface_destroy(m_pCairoSurface);
+}
+
 void CHyprNotificationOverlay::addNotification(const std::string& text, const CColor& color, const float timeMs, const eIcons icon, const float fontSize) {
     const auto PNOTIF = m_dNotifications.emplace_back(std::make_unique<SNotification>()).get();
 
diff --git a/src/debug/HyprNotificationOverlay.hpp b/src/debug/HyprNotificationOverlay.hpp
index 25934734..d086ada9 100644
--- a/src/debug/HyprNotificationOverlay.hpp
+++ b/src/debug/HyprNotificationOverlay.hpp
@@ -39,6 +39,7 @@ struct SNotification {
 class CHyprNotificationOverlay {
   public:
     CHyprNotificationOverlay();
+    ~CHyprNotificationOverlay();
 
     void draw(CMonitor* pMonitor);
     void addNotification(const std::string& text, const CColor& color, const float timeMs, const eIcons icon = ICON_NONE, const float fontSize = 13.f);
diff --git a/src/helpers/WLClasses.hpp b/src/helpers/WLClasses.hpp
index 89af21c3..0bd3d7d4 100644
--- a/src/helpers/WLClasses.hpp
+++ b/src/helpers/WLClasses.hpp
@@ -157,6 +157,11 @@ struct SKeyboard {
     bool operator==(const SKeyboard& rhs) const {
         return keyboard == rhs.keyboard;
     }
+
+    ~SKeyboard() {
+        if (xkbTranslationState)
+            xkb_state_unref(xkbTranslationState);
+    }
 };
 
 struct SMouse {
diff --git a/src/managers/CursorManager.cpp b/src/managers/CursorManager.cpp
index c7e47120..41f94328 100644
--- a/src/managers/CursorManager.cpp
+++ b/src/managers/CursorManager.cpp
@@ -53,6 +53,11 @@ CCursorManager::CCursorManager() {
     static auto P = g_pHookSystem->hookDynamic("monitorLayoutChanged", [this](void* self, SCallbackInfo& info, std::any param) { this->updateTheme(); });
 }
 
+CCursorManager::~CCursorManager() {
+    if (m_pWLRXCursorMgr)
+        wlr_xcursor_manager_destroy(m_pWLRXCursorMgr);
+}
+
 void CCursorManager::dropBufferRef(CCursorManager::CCursorBuffer* ref) {
     std::erase_if(m_vCursorBuffers, [ref](const auto& buf) { return buf.get() == ref; });
 }
diff --git a/src/managers/CursorManager.hpp b/src/managers/CursorManager.hpp
index ff633592..629f29e1 100644
--- a/src/managers/CursorManager.hpp
+++ b/src/managers/CursorManager.hpp
@@ -13,6 +13,7 @@ struct wlr_xwayland;
 class CCursorManager {
   public:
     CCursorManager();
+    ~CCursorManager();
 
     wlr_buffer*      getCursorBuffer();
 
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index ff00438b..07a6fc87 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -115,6 +115,11 @@ CKeybindManager::CKeybindManager() {
     });
 }
 
+CKeybindManager::~CKeybindManager() {
+    if (m_pXKBTranslationState)
+        xkb_state_unref(m_pXKBTranslationState);
+}
+
 void CKeybindManager::addKeybind(SKeybind kb) {
     m_lKeybinds.push_back(kb);
 
@@ -218,6 +223,7 @@ void CKeybindManager::updateXKBTranslationState() {
 
     xkb_context_unref(PCONTEXT);
     m_pXKBTranslationState = xkb_state_new(PKEYMAP);
+    xkb_keymap_unref(PKEYMAP);
 }
 
 bool CKeybindManager::ensureMouseBindState() {
diff --git a/src/managers/KeybindManager.hpp b/src/managers/KeybindManager.hpp
index aec9e02d..e86ad7ab 100644
--- a/src/managers/KeybindManager.hpp
+++ b/src/managers/KeybindManager.hpp
@@ -55,6 +55,7 @@ struct SParsedKey {
 class CKeybindManager {
   public:
     CKeybindManager();
+    ~CKeybindManager();
 
     bool                                                              onKeyEvent(wlr_keyboard_key_event*, SKeyboard*);
     bool                                                              onAxisEvent(wlr_pointer_axis_event*);

commit 1615501176857665ed9457183deca2b9d468c3b9
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Fri May 3 19:10:41 2024 +0200

    inputmgr: dont double free on hotplug (#5855)
    
    * inputmgr: dont double free on hotplug
    
    since we are also unrefing the state on hotplugging the keyboard set the
    state to nullptr so the destructor if case actually catches its been
    already freed.
    
    * keybindgmgr: dont double free on layout switching
    
    d5bf153 added keymap unref at the end of updateXKBTranslationState to
    not leak it when exiting, only it causes updateXKBTranslationState to
    double free when changing layouts. since its already freed. remove the
    unneeded extra xkb_keymap_unref.

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 07a6fc87..a92e01b7 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -180,7 +180,6 @@ uint32_t CKeybindManager::keycodeToModifier(xkb_keycode_t keycode) {
 
 void CKeybindManager::updateXKBTranslationState() {
     if (m_pXKBTranslationState) {
-        xkb_keymap_unref(xkb_state_get_keymap(m_pXKBTranslationState));
         xkb_state_unref(m_pXKBTranslationState);
 
         m_pXKBTranslationState = nullptr;
diff --git a/src/managers/input/InputManager.cpp b/src/managers/input/InputManager.cpp
index e69197f2..9487d108 100644
--- a/src/managers/input/InputManager.cpp
+++ b/src/managers/input/InputManager.cpp
@@ -1140,6 +1140,7 @@ void CInputManager::destroyKeyboard(SKeyboard* pKeyboard) {
     pKeyboard->hyprListener_keyboardKey.removeCallback();
 
     xkb_state_unref(pKeyboard->xkbTranslationState);
+    pKeyboard->xkbTranslationState = nullptr;
 
     m_lKeyboards.remove(*pKeyboard);
 

commit 3b07e48a7dec0fdfce732e24ed39755be1dbf499
Author: William Gray <ruwagray@gmail.com>
Date:   Fri May 3 12:38:00 2024 -0500

    config: add absolute monitor workspace selectors (#5848)
    
    * add absolute monitor workspace selectors
    
    * implement absolute for `r`
    
    * format code

diff --git a/src/helpers/MiscFunctions.cpp b/src/helpers/MiscFunctions.cpp
index b8061bef..5a6fb885 100644
--- a/src/helpers/MiscFunctions.cpp
+++ b/src/helpers/MiscFunctions.cpp
@@ -302,13 +302,14 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
         outName = PLASTWORKSPACE->m_szName;
         return PLASTWORKSPACE->m_iID;
     } else {
-        if (in[0] == 'r' && (in[1] == '-' || in[1] == '+') && isNumber(in.substr(2))) {
+        if (in[0] == 'r' && (in[1] == '-' || in[1] == '+' || in[1] == '~') && isNumber(in.substr(2))) {
+            bool absolute = in[1] == '~';
             if (!g_pCompositor->m_pLastMonitor) {
                 Debug::log(ERR, "Relative monitor workspace on monitor null!");
                 return WORKSPACE_INVALID;
             }
 
-            const auto PLUSMINUSRESULT = getPlusMinusKeywordResult(in.substr(1), 0);
+            const auto PLUSMINUSRESULT = getPlusMinusKeywordResult(in.substr(absolute ? 2 : 1), 0);
 
             if (!PLUSMINUSRESULT.has_value())
                 return WORKSPACE_INVALID;
@@ -346,103 +347,124 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
             }
             std::sort(namedWSes.begin(), namedWSes.end());
 
-            // Just take a blind guess at where we'll probably end up
-            int  activeWSID    = g_pCompositor->m_pLastMonitor->activeWorkspace ? g_pCompositor->m_pLastMonitor->activeWorkspace->m_iID : 1;
-            int  predictedWSID = activeWSID + remains;
-            int  remainingWSes = 0;
-            char walkDir       = in[1];
-
-            // sanitize. 0 means invalid oob in -
-            predictedWSID = std::max(predictedWSID, 0);
-
-            // Count how many invalidWSes are in between (how bad the prediction was)
-            int  beginID = in[1] == '+' ? activeWSID + 1 : predictedWSID;
-            int  endID   = in[1] == '+' ? predictedWSID : activeWSID;
-            auto begin   = invalidWSes.upper_bound(beginID - 1); // upper_bound is >, we want >=
-            for (auto it = begin; *it <= endID && it != invalidWSes.end(); it++) {
-                remainingWSes++;
-            }
+            if (absolute) {
+                // 1-index
+                remains -= 1;
 
-            // Handle named workspaces. They are treated like always before other workspaces
-            if (activeWSID < 0) {
-                // Behaviour similar to 'm'
-                // Find current
-                int currentItem = -1;
-                for (size_t i = 0; i < namedWSes.size(); i++) {
-                    if (namedWSes[i] == activeWSID) {
-                        currentItem = i;
-                        break;
+                // traverse valid workspaces until we reach the remains
+                if ((size_t)remains < namedWSes.size()) {
+                    result = namedWSes[remains];
+                } else {
+                    remains -= namedWSes.size();
+                    result = 0;
+                    while (remains >= 0) {
+                        result++;
+                        if (!invalidWSes.contains(result)) {
+                            remains--;
+                        }
                     }
                 }
+            } else {
+
+                // Just take a blind guess at where we'll probably end up
+                int  activeWSID    = g_pCompositor->m_pLastMonitor->activeWorkspace ? g_pCompositor->m_pLastMonitor->activeWorkspace->m_iID : 1;
+                int  predictedWSID = activeWSID + remains;
+                int  remainingWSes = 0;
+                char walkDir       = in[1];
+
+                // sanitize. 0 means invalid oob in -
+                predictedWSID = std::max(predictedWSID, 0);
+
+                // Count how many invalidWSes are in between (how bad the prediction was)
+                int  beginID = in[1] == '+' ? activeWSID + 1 : predictedWSID;
+                int  endID   = in[1] == '+' ? predictedWSID : activeWSID;
+                auto begin   = invalidWSes.upper_bound(beginID - 1); // upper_bound is >, we want >=
+                for (auto it = begin; *it <= endID && it != invalidWSes.end(); it++) {
+                    remainingWSes++;
+                }
 
-                currentItem += remains;
-                currentItem = std::max(currentItem, 0);
-                if (currentItem >= (int)namedWSes.size()) {
-                    // At the seam between namedWSes and normal WSes. Behave like r+[diff] at imaginary ws 0
-                    int diff      = currentItem - (namedWSes.size() - 1);
-                    predictedWSID = diff;
-                    int  beginID  = 1;
-                    int  endID    = predictedWSID;
-                    auto begin    = invalidWSes.upper_bound(beginID - 1); // upper_bound is >, we want >=
-                    for (auto it = begin; *it <= endID && it != invalidWSes.end(); it++) {
-                        remainingWSes++;
+                // Handle named workspaces. They are treated like always before other workspaces
+                if (activeWSID < 0) {
+                    // Behaviour similar to 'm'
+                    // Find current
+                    int currentItem = -1;
+                    for (size_t i = 0; i < namedWSes.size(); i++) {
+                        if (namedWSes[i] == activeWSID) {
+                            currentItem = i;
+                            break;
+                        }
                     }
-                    walkDir = '+';
-                } else {
-                    // We found our final ws.
-                    remainingWSes = 0;
-                    predictedWSID = namedWSes[currentItem];
-                }
-            }
 
-            // Go in the search direction for remainingWSes
-            // The performance impact is directly proportional to the number of open and bound workspaces
-            int finalWSID = predictedWSID;
-            if (walkDir == '-') {
-                int beginID = finalWSID;
-                int curID   = finalWSID;
-                while (--curID > 0 && remainingWSes > 0) {
-                    if (!invalidWSes.contains(curID)) {
-                        remainingWSes--;
+                    currentItem += remains;
+                    currentItem = std::max(currentItem, 0);
+                    if (currentItem >= (int)namedWSes.size()) {
+                        // At the seam between namedWSes and normal WSes. Behave like r+[diff] at imaginary ws 0
+                        int diff      = currentItem - (namedWSes.size() - 1);
+                        predictedWSID = diff;
+                        int  beginID  = 1;
+                        int  endID    = predictedWSID;
+                        auto begin    = invalidWSes.upper_bound(beginID - 1); // upper_bound is >, we want >=
+                        for (auto it = begin; *it <= endID && it != invalidWSes.end(); it++) {
+                            remainingWSes++;
+                        }
+                        walkDir = '+';
+                    } else {
+                        // We found our final ws.
+                        remainingWSes = 0;
+                        predictedWSID = namedWSes[currentItem];
                     }
-                    finalWSID = curID;
                 }
-                if (finalWSID <= 0 || invalidWSes.contains(finalWSID)) {
-                    if (namedWSes.size()) {
-                        // Go to the named workspaces
-                        // Need remainingWSes more
-                        int namedWSIdx = namedWSes.size() - remainingWSes;
-                        // Sanitze
-                        namedWSIdx = std::clamp(namedWSIdx, 0, (int)namedWSes.size() - 1);
-                        finalWSID  = namedWSes[namedWSIdx];
-                    } else {
-                        // Couldn't find valid workspace in negative direction, search last first one back up positive direction
-                        walkDir = '+';
-                        // We know, that everything less than beginID is invalid, so don't bother with that
-                        finalWSID     = beginID;
-                        remainingWSes = 1;
+
+                // Go in the search direction for remainingWSes
+                // The performance impact is directly proportional to the number of open and bound workspaces
+                int finalWSID = predictedWSID;
+                if (walkDir == '-') {
+                    int beginID = finalWSID;
+                    int curID   = finalWSID;
+                    while (--curID > 0 && remainingWSes > 0) {
+                        if (!invalidWSes.contains(curID)) {
+                            remainingWSes--;
+                        }
+                        finalWSID = curID;
+                    }
+                    if (finalWSID <= 0 || invalidWSes.contains(finalWSID)) {
+                        if (namedWSes.size()) {
+                            // Go to the named workspaces
+                            // Need remainingWSes more
+                            int namedWSIdx = namedWSes.size() - remainingWSes;
+                            // Sanitze
+                            namedWSIdx = std::clamp(namedWSIdx, 0, (int)namedWSes.size() - 1);
+                            finalWSID  = namedWSes[namedWSIdx];
+                        } else {
+                            // Couldn't find valid workspace in negative direction, search last first one back up positive direction
+                            walkDir = '+';
+                            // We know, that everything less than beginID is invalid, so don't bother with that
+                            finalWSID     = beginID;
+                            remainingWSes = 1;
+                        }
                     }
                 }
-            }
-            if (walkDir == '+') {
-                int curID = finalWSID;
-                while (++curID < INT32_MAX && remainingWSes > 0) {
-                    if (!invalidWSes.contains(curID)) {
-                        remainingWSes--;
+                if (walkDir == '+') {
+                    int curID = finalWSID;
+                    while (++curID < INT32_MAX && remainingWSes > 0) {
+                        if (!invalidWSes.contains(curID)) {
+                            remainingWSes--;
+                        }
+                        finalWSID = curID;
                     }
-                    finalWSID = curID;
                 }
+                result = finalWSID;
             }
 
-            result                = finalWSID;
             const auto PWORKSPACE = g_pCompositor->getWorkspaceByID(result);
             if (PWORKSPACE)
                 outName = g_pCompositor->getWorkspaceByID(result)->m_szName;
             else
-                outName = std::to_string(finalWSID);
+                outName = std::to_string(result);
 
-        } else if ((in[0] == 'm' || in[0] == 'e') && (in[1] == '-' || in[1] == '+') && isNumber(in.substr(2))) {
+        } else if ((in[0] == 'm' || in[0] == 'e') && (in[1] == '-' || in[1] == '+' || in[1] == '~') && isNumber(in.substr(2))) {
             bool onAllMonitors = in[0] == 'e';
+            bool absolute      = in[1] == '~';
 
             if (!g_pCompositor->m_pLastMonitor) {
                 Debug::log(ERR, "Relative monitor workspace on monitor null!");
@@ -450,7 +472,7 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
             }
 
             // monitor relative
-            const auto PLUSMINUSRESULT = getPlusMinusKeywordResult(in.substr(1), 0);
+            const auto PLUSMINUSRESULT = getPlusMinusKeywordResult(in.substr(absolute ? 2 : 1), 0);
 
             if (!PLUSMINUSRESULT.has_value())
                 return WORKSPACE_INVALID;
@@ -470,27 +492,40 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
 
             std::sort(validWSes.begin(), validWSes.end());
 
-            // get the offset
-            remains = remains < 0 ? -((-remains) % validWSes.size()) : remains % validWSes.size();
-
-            // get the current item
-            int activeWSID  = g_pCompositor->m_pLastMonitor->activeWorkspace ? g_pCompositor->m_pLastMonitor->activeWorkspace->m_iID : 1;
             int currentItem = -1;
-            for (size_t i = 0; i < validWSes.size(); i++) {
-                if (validWSes[i] == activeWSID) {
-                    currentItem = i;
-                    break;
+
+            if (absolute) {
+                // 1-index
+                currentItem = remains - 1;
+
+                // clamp
+                if (currentItem < 0) {
+                    currentItem = 0;
+                } else if (currentItem >= (int)validWSes.size()) {
+                    currentItem = validWSes.size() - 1;
+                }
+            } else {
+                // get the offset
+                remains = remains < 0 ? -((-remains) % validWSes.size()) : remains % validWSes.size();
+
+                // get the current item
+                int activeWSID = g_pCompositor->m_pLastMonitor->activeWorkspace ? g_pCompositor->m_pLastMonitor->activeWorkspace->m_iID : 1;
+                for (size_t i = 0; i < validWSes.size(); i++) {
+                    if (validWSes[i] == activeWSID) {
+                        currentItem = i;
+                        break;
+                    }
                 }
-            }
 
-            // apply
-            currentItem += remains;
+                // apply
+                currentItem += remains;
 
-            // sanitize
-            if (currentItem >= (int)validWSes.size()) {
-                currentItem = currentItem % validWSes.size();
-            } else if (currentItem < 0) {
-                currentItem = validWSes.size() + currentItem;
+                // sanitize
+                if (currentItem >= (int)validWSes.size()) {
+                    currentItem = currentItem % validWSes.size();
+                } else if (currentItem < 0) {
+                    currentItem = validWSes.size() + currentItem;
+                }
             }
 
             result  = validWSes[currentItem];

commit df972a8e1c581db8eb4822642739faa7792dd30b
Author: thejch <66577496+thejch@users.noreply.github.com>
Date:   Fri May 3 18:18:04 2024 -0700

    workspacerule: Fix monitor settings being deleted when merging ws rules (#5864)
    
    * fix deleting monitor settings when merging rules
    
    * use empty and workspace invalid

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 56142857..61988040 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -984,6 +984,15 @@ SWorkspaceRule CConfigManager::getWorkspaceRuleFor(PHLWORKSPACE pWorkspace) {
 SWorkspaceRule CConfigManager::mergeWorkspaceRules(const SWorkspaceRule& rule1, const SWorkspaceRule& rule2) {
     SWorkspaceRule mergedRule = rule1;
 
+    if (rule1.monitor.empty())
+        mergedRule.monitor = rule2.monitor;
+    if (rule1.workspaceString.empty())
+        mergedRule.workspaceString = rule2.workspaceString;
+    if (rule1.workspaceName.empty())
+        mergedRule.workspaceName = rule2.workspaceName;
+    if (rule1.workspaceId == WORKSPACE_INVALID)
+        mergedRule.workspaceId = rule2.workspaceId;
+
     if (rule2.isDefault)
         mergedRule.isDefault = true;
     if (rule2.isPersistent)

commit 886ae30ea090209186b8b304a99ebf834691e5c6
Author: JManch <61563764+JManch@users.noreply.github.com>
Date:   Sat May 4 12:07:36 2024 +0100

    windows: set fullscreen border size to 0 (#5865)

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index bda6c60c..a365ef79 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -1168,7 +1168,7 @@ void CWindow::updateSpecialRenderData(const SWorkspaceRule& workspaceRule) {
 }
 
 int CWindow::getRealBorderSize() {
-    if (!m_sSpecialRenderData.border || m_sAdditionalConfigData.forceNoBorder)
+    if (!m_sSpecialRenderData.border || m_sAdditionalConfigData.forceNoBorder || (m_pWorkspace && m_bIsFullscreen && (m_pWorkspace->m_efFullscreenMode == FULLSCREEN_FULL)))
         return 0;
 
     if (m_sAdditionalConfigData.borderSize.toUnderlying() != -1)

commit c01d9a2cdac8165ad1610748bb53be29a476f2d6
Author: Vaxry <vaxry@vaxry.net>
Date:   Sat May 4 20:30:03 2024 +0100

    shadow: fix small pixel gaps between border
    
    huge fix

diff --git a/src/render/decorations/CHyprDropShadowDecoration.cpp b/src/render/decorations/CHyprDropShadowDecoration.cpp
index bba2c639..9f184e63 100644
--- a/src/render/decorations/CHyprDropShadowDecoration.cpp
+++ b/src/render/decorations/CHyprDropShadowDecoration.cpp
@@ -184,7 +184,7 @@ void CHyprDropShadowDecoration::draw(CMonitor* pMonitor, float a) {
         g_pHyprOpenGL->renderRoundedShadow(&fullBox, ROUNDING * pMonitor->scale, *PSHADOWSIZE * pMonitor->scale, CColor(1, 1, 1, m_pWindow->m_cRealShadowColor.value().a), a);
 
         // render black window box ("clip")
-        g_pHyprOpenGL->renderRect(&windowBox, CColor(0, 0, 0, 1.0), ROUNDING * pMonitor->scale);
+        g_pHyprOpenGL->renderRect(&windowBox, CColor(0, 0, 0, 1.0), (ROUNDING + 1 /* This fixes small pixel gaps. */) * pMonitor->scale);
 
         alphaSwapFB.bind();
 

commit c8b30e9c09f8b67cbc8f13cec51f5f8645e16727
Author: Ikalco <73481042+ikalco@users.noreply.github.com>
Date:   Sun May 5 13:28:14 2024 -0500

    keybinds: make the keybind manager check for session lock (#5894)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index a92e01b7..858a2ec3 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -560,6 +560,9 @@ bool CKeybindManager::handleKeybinds(const uint32_t modmask, const SPressedKeyWi
         const bool IGNORECONDITIONS =
             SPECIALDISPATCHER && !pressed && SPECIALTRIGGERED; // ignore mods. Pass, global dispatchers should be released immediately once the key is released.
 
+        if (!k.locked && g_pSessionLockManager->isSessionLocked())
+            continue;
+
         if (!IGNORECONDITIONS &&
             ((modmask != k.modmask && !k.ignoreMods) || (g_pCompositor->m_sSeat.exclusiveClient && !k.locked) || k.submap != m_szCurrentSelectedSubmap || k.shadowed))
             continue;

commit 03a547827d0543f145dcda3aa6d7dd83b926f876
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon May 6 02:24:11 2024 +0100

    renderer: deny solitary during a session lock
    
    closes #5906
    
    fixes #5899

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 2bf6d290..c3623f69 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -2558,7 +2558,7 @@ bool CHyprRenderer::canSkipBackBufferClear(CMonitor* pMonitor) {
 void CHyprRenderer::recheckSolitaryForMonitor(CMonitor* pMonitor) {
     pMonitor->solitaryClient = nullptr; // reset it, if we find one it will be set.
 
-    if (g_pHyprNotificationOverlay->hasAny())
+    if (g_pHyprNotificationOverlay->hasAny() || g_pSessionLockManager->isSessionLocked())
         return;
 
     const auto PWORKSPACE = pMonitor->activeWorkspace;

commit 5d775c2b03abe685c04e9588b9fb49aa7dd4c812
Author: outfoxxed <outfoxxed@outfoxxed.me>
Date:   Mon May 6 07:32:01 2024 -0700

    windows: Revert "window: set config only when both props end anims" (#5904)
    
    This reverts commit 7617c03dfd0073654ca8c4d9a6f5db278d14cd28,
    fixing a bug that caused the bottom right corner of windows to
    animate oddly.

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index 72d57d59..d3a31480 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -36,10 +36,10 @@ void setAnimToMove(void* data) {
 
     CBaseAnimatedVariable* animvar = (CBaseAnimatedVariable*)data;
 
-    if (animvar->getWindow() && !animvar->getWindow()->m_vRealPosition.isBeingAnimated() && !animvar->getWindow()->m_vRealSize.isBeingAnimated()) {
-        animvar->setConfig(PANIMCFG);
+    animvar->setConfig(PANIMCFG);
+
+    if (animvar->getWindow() && !animvar->getWindow()->m_vRealPosition.isBeingAnimated() && !animvar->getWindow()->m_vRealSize.isBeingAnimated())
         animvar->getWindow()->m_bAnimatingIn = false;
-    }
 }
 
 void Events::listener_mapWindow(void* owner, void* data) {

commit 0a0368cd0b24a4ffea01af8c031cc8358e2c418f
Author: Ikalco <73481042+ikalco@users.noreply.github.com>
Date:   Tue May 7 01:20:06 2024 -0500

    keybinds: fix xkb keybind name to keysym comparison (#5917)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 858a2ec3..6ad79e42 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -579,9 +579,10 @@ bool CKeybindManager::handleKeybinds(const uint32_t modmask, const SPressedKeyWi
         } else {
             // oMg such performance hit!!11!
             // this little maneouver is gonna cost us 4µs
-            const auto KBKEY = xkb_keysym_from_name(k.key.c_str(), XKB_KEYSYM_CASE_INSENSITIVE);
+            const auto KBKEY      = xkb_keysym_from_name(k.key.c_str(), XKB_KEYSYM_NO_FLAGS);
+            const auto KBKEYLOWER = xkb_keysym_from_name(k.key.c_str(), XKB_KEYSYM_CASE_INSENSITIVE);
 
-            if (KBKEY == 0) {
+            if (KBKEY == 0 && KBKEYLOWER == 0) {
                 // Keysym failed to resolve from the key name of the currently iterated bind.
                 // This happens for names such as `switch:off:Lid Switch` as well as some keys
                 // (such as yen and ro).
@@ -592,9 +593,7 @@ bool CKeybindManager::handleKeybinds(const uint32_t modmask, const SPressedKeyWi
                 continue;
             }
 
-            const auto KBKEYUPPER = xkb_keysym_to_upper(KBKEY);
-
-            if (key.keysym != KBKEY && key.keysym != KBKEYUPPER)
+            if (key.keysym != KBKEY && key.keysym != KBKEYLOWER)
                 continue;
         }
 

commit 5f9a7e172d629621de95401537e769de0447d8c6
Author: Username404-59 <53659497+Username404-59@users.noreply.github.com>
Date:   Wed May 8 00:13:58 2024 +0200

    internal: Add missing errno.h include to SdDaemon.cpp (#5938)
    
    Fixes clang

diff --git a/src/helpers/SdDaemon.cpp b/src/helpers/SdDaemon.cpp
index 0835637a..d5df3121 100644
--- a/src/helpers/SdDaemon.cpp
+++ b/src/helpers/SdDaemon.cpp
@@ -4,6 +4,7 @@
 
 #include <fcntl.h>
 #include <unistd.h>
+#include <errno.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 

commit 5f9b11d44525009c3f6eb0d257cd324234ddb71c
Author: William Gray <wagyourtail@wagyourtail.xyz>
Date:   Wed May 8 07:30:20 2024 -0500

    keybinds: add empty on monitor and next empty flags (#5936)
    
    * empty on monitor
    
    * add flag for next empty
    
    * clang-format changes
    
    * next also uses m_pLastMonitor

diff --git a/src/helpers/MiscFunctions.cpp b/src/helpers/MiscFunctions.cpp
index 5a6fb885..bdd7f847 100644
--- a/src/helpers/MiscFunctions.cpp
+++ b/src/helpers/MiscFunctions.cpp
@@ -279,10 +279,18 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
         }
         outName = WORKSPACENAME;
     } else if (in.starts_with("empty")) {
-        int id = 0;
+        const bool same_mon = in.substr(5).contains("m");
+        const bool next     = in.substr(5).contains("n");
+        if (same_mon || next) {
+            if (!g_pCompositor->m_pLastMonitor) {
+                Debug::log(ERR, "Empty monitor workspace on monitor null!");
+                return WORKSPACE_INVALID;
+            }
+        }
+        int id = next ? g_pCompositor->m_pLastMonitor->activeWorkspaceID() : 0;
         while (++id < INT_MAX) {
             const auto PWORKSPACE = g_pCompositor->getWorkspaceByID(id);
-            if (!PWORKSPACE || (g_pCompositor->getWindowsOnWorkspace(id) == 0))
+            if (!PWORKSPACE || (g_pCompositor->getWindowsOnWorkspace(id) == 0 && (!same_mon || PWORKSPACE->m_iMonitorID == g_pCompositor->m_pLastMonitor->ID)))
                 return id;
         }
     } else if (in.starts_with("prev")) {

commit e32ac20052df905b611f96f0e38b5ea2e6c783d8
Author: Ikalco <73481042+ikalco@users.noreply.github.com>
Date:   Wed May 8 12:11:08 2024 -0500

    core: cleanup environment on exit (#5941)

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 27b89995..7d330db4 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -408,6 +408,28 @@ void CCompositor::removeAllSignals() {
         removeWLSignal(&Events::listen_sessionActive);
 }
 
+void CCompositor::cleanEnvironment() {
+    // in compositor constructor
+    unsetenv("WAYLAND_DISPLAY");
+    // in startCompositor
+    unsetenv("HYPRLAND_INSTANCE_SIGNATURE");
+
+    // in main
+    unsetenv("HYPRLAND_CMD");
+    unsetenv("XDG_BACKEND");
+    unsetenv("XDG_CURRENT_DESKTOP");
+
+    if (m_sWLRSession) {
+        const auto CMD =
+#ifdef USES_SYSTEMD
+            "systemctl --user unset-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME && hash "
+            "dbus-update-activation-environment 2>/dev/null && "
+#endif
+            "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME";
+        g_pKeybindManager->spawn(CMD);
+    }
+}
+
 void CCompositor::cleanup() {
     if (!m_sWLDisplay || m_bIsShuttingDown)
         return;
@@ -425,6 +447,8 @@ void CCompositor::cleanup() {
         Systemd::SdNotify(0, "STOPPING=1");
 #endif
 
+    cleanEnvironment();
+
     // unload all remaining plugins while the compositor is
     // still in a normal working state.
     g_pPluginSystem->unloadAllPlugins();
diff --git a/src/Compositor.hpp b/src/Compositor.hpp
index 34ea322a..60c575d5 100644
--- a/src/Compositor.hpp
+++ b/src/Compositor.hpp
@@ -215,6 +215,7 @@ class CCompositor {
   private:
     void     initAllSignals();
     void     removeAllSignals();
+    void     cleanEnvironment();
     void     setRandomSplash();
     void     initManagers(eManagersInitStage stage);
     void     prepareFallbackOutput();
diff --git a/src/managers/XWaylandManager.cpp b/src/managers/XWaylandManager.cpp
index 325229e7..5d8bea3a 100644
--- a/src/managers/XWaylandManager.cpp
+++ b/src/managers/XWaylandManager.cpp
@@ -28,7 +28,11 @@ CHyprXWaylandManager::CHyprXWaylandManager() {
 #endif
 }
 
-CHyprXWaylandManager::~CHyprXWaylandManager() {}
+CHyprXWaylandManager::~CHyprXWaylandManager() {
+#ifndef NO_XWAYLAND
+    unsetenv("DISPLAY");
+#endif
+}
 
 wlr_surface* CHyprXWaylandManager::getWindowSurface(CWindow* pWindow) {
     if (pWindow->m_bIsX11)

commit 8a2c51e1b8a9fd6f0d623ac04207cc3453e3f056
Author: Ikalco <73481042+ikalco@users.noreply.github.com>
Date:   Thu May 9 07:39:15 2024 -0500

    core: remove wayland sockets on exit (#5959)

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 7d330db4..07d386c0 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -518,6 +518,10 @@ void CCompositor::cleanup() {
 
     wl_display_terminate(m_sWLDisplay);
     m_sWLDisplay = nullptr;
+
+    std::string waylandSocket = std::string{getenv("XDG_RUNTIME_DIR")} + "/" + m_szWLDisplaySocket;
+    std::filesystem::remove(waylandSocket);
+    std::filesystem::remove(waylandSocket + ".lock");
 }
 
 void CCompositor::initManagers(eManagersInitStage stage) {

commit 32be21d9b87c81edc58e811ad74698cc24a8dd45
Author: sub-kek <100521725+sub-kek@users.noreply.github.com>
Date:   Fri May 10 00:05:13 2024 +0300

    keybinds: Fix classic global keybinds(pass dispatcher) (#5967)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 6ad79e42..36e0c84c 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1966,7 +1966,7 @@ void CKeybindManager::pass(std::string regexp) {
     }
 
     if (g_pKeybindManager->m_uLastCode != 0)
-        wlr_seat_keyboard_enter(g_pCompositor->m_sSeat.seat, PLASTSRF, KEYBOARD->keycodes, KEYBOARD->num_keycodes, &KEYBOARD->modifiers);
+        wlr_seat_keyboard_enter(g_pCompositor->m_sSeat.seat, PWINDOW->m_pWLSurface.wlr(), KEYBOARD->keycodes, KEYBOARD->num_keycodes, &KEYBOARD->modifiers);
     else
         wlr_seat_pointer_enter(g_pCompositor->m_sSeat.seat, PWINDOW->m_pWLSurface.wlr(), SL.x, SL.y);
 }

commit 2f7667ada82d49105dc659a2af92a28dbf859103
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri May 10 12:58:53 2024 +0100

    box: fix noNegativeSize

diff --git a/src/helpers/Box.cpp b/src/helpers/Box.cpp
index 8470b509..1dab447b 100644
--- a/src/helpers/Box.cpp
+++ b/src/helpers/Box.cpp
@@ -115,8 +115,8 @@ CBox& CBox::expand(const double& value) {
 }
 
 CBox& CBox::noNegativeSize() {
-    std::clamp(w, 0.0, std::numeric_limits<double>::infinity());
-    std::clamp(h, 0.0, std::numeric_limits<double>::infinity());
+    w = std::clamp(w, 0.0, std::numeric_limits<double>::infinity());
+    h = std::clamp(h, 0.0, std::numeric_limits<double>::infinity());
 
     return *this;
 }

commit f918702ced4b820e647327a01015130d7e2dcce1
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri May 10 23:41:32 2024 +0100

    hyprpm: force en_US locale for date calcs
    
    ref #5994

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 72ec7861..e52f64b6 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -443,7 +443,7 @@ bool CPluginManager::updateHeaders(bool force) {
 
     // let us give a bit of leg-room for shallowing
     // due to timezones, etc.
-    const std::string SHALLOW_DATE = removeBeginEndSpacesTabs(HLVER.date).empty() ? "" : execAndGet("date --date='" + HLVER.date + " - 1 weeks' '+\%a \%b \%d \%H:\%M:\%S \%Y'");
+    const std::string SHALLOW_DATE = removeBeginEndSpacesTabs(HLVER.date).empty() ? "" : execAndGet("LC_TIME=\"en_US.UTF-8\" date --date='" + HLVER.date + " - 1 weeks' '+\%a \%b \%d \%H:\%M:\%S \%Y'");
 
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "will shallow since: " + SHALLOW_DATE);

commit 5733617c6c42ff7115bda1d7a9d80f6ab352605a
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri May 10 23:56:49 2024 +0100

    hyprpm: fix style

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index e52f64b6..be207045 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -443,7 +443,8 @@ bool CPluginManager::updateHeaders(bool force) {
 
     // let us give a bit of leg-room for shallowing
     // due to timezones, etc.
-    const std::string SHALLOW_DATE = removeBeginEndSpacesTabs(HLVER.date).empty() ? "" : execAndGet("LC_TIME=\"en_US.UTF-8\" date --date='" + HLVER.date + " - 1 weeks' '+\%a \%b \%d \%H:\%M:\%S \%Y'");
+    const std::string SHALLOW_DATE =
+        removeBeginEndSpacesTabs(HLVER.date).empty() ? "" : execAndGet("LC_TIME=\"en_US.UTF-8\" date --date='" + HLVER.date + " - 1 weeks' '+\%a \%b \%d \%H:\%M:\%S \%Y'");
 
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "will shallow since: " + SHALLOW_DATE);

commit c16e1a912ca1e0e4725fb09bb84f5a597025b13b
Author: Sungyoon Cho <sungyoon@sungyooncho.dev>
Date:   Sat May 11 18:35:20 2024 +0900

    compositor: fix getMonitorFromVector getting wrong monitor (#6010)

diff --git a/src/macros.hpp b/src/macros.hpp
index 19b4cbc6..e6824cb6 100644
--- a/src/macros.hpp
+++ b/src/macros.hpp
@@ -31,7 +31,7 @@
 #define DYNLISTENER(name)      CHyprWLListener hyprListener_##name
 #define DYNMULTILISTENER(name) wl_listener listen_##name
 
-#define VECINRECT(vec, x1, y1, x2, y2) ((vec).x >= (x1) && (vec).x <= (x2) && (vec).y >= (y1) && (vec).y <= (y2))
+#define VECINRECT(vec, x1, y1, x2, y2) ((vec).x >= (x1) && (vec).x < (x2) && (vec).y >= (y1) && (vec).y < (y2))
 
 #define DELTALESSTHAN(a, b, delta) (abs((a) - (b)) < (delta))
 

commit b888a147aacaf9bcabab6afde08d5a4cc131b7e2
Author: shezdy <77217897+shezdy@users.noreply.github.com>
Date:   Sat May 11 17:02:26 2024 -0600

    keybinds: fix release binds in submaps (#6025)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 36e0c84c..b17c6785 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -385,8 +385,7 @@ bool CKeybindManager::onKeyEvent(wlr_keyboard_key_event* e, SKeyboard* pKeyboard
         bool foundInPressedKeys = false;
         for (auto it = m_dPressedKeys.begin(); it != m_dPressedKeys.end();) {
             if (it->keycode == KEYCODE) {
-                if (it->submapAtPress == m_szCurrentSelectedSubmap)
-                    handleKeybinds(MODS, *it, false);
+                handleKeybinds(MODS, *it, false);
                 foundInPressedKeys = true;
                 suppressEvent      = !it->sent;
                 it                 = m_dPressedKeys.erase(it);
@@ -574,7 +573,7 @@ bool CKeybindManager::handleKeybinds(const uint32_t modmask, const SPressedKeyWi
             if (key.keycode != k.keycode)
                 continue;
         } else if (k.catchAll) {
-            if (found)
+            if (found || key.submapAtPress != m_szCurrentSelectedSubmap)
                 continue;
         } else {
             // oMg such performance hit!!11!

commit 7d0d8a000525814634d257b185f1ecc704ffbc1c
Author: Mihai Fufezan <mihai@fufexan.net>
Date:   Sun May 12 02:53:50 2024 +0300

    hyprpm: don't shallow clone on non-main branches

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index be207045..20c0c509 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -441,15 +441,18 @@ bool CPluginManager::updateHeaders(bool force) {
 
     progress.printMessageAbove(std::string{Colors::YELLOW} + "!" + Colors::RESET + " Cloning https://github.com/hyprwm/hyprland, this might take a moment.");
 
+    const bool bShallow = HLVER.branch == "main" || HLVER.branch == "";
+
     // let us give a bit of leg-room for shallowing
     // due to timezones, etc.
     const std::string SHALLOW_DATE =
         removeBeginEndSpacesTabs(HLVER.date).empty() ? "" : execAndGet("LC_TIME=\"en_US.UTF-8\" date --date='" + HLVER.date + " - 1 weeks' '+\%a \%b \%d \%H:\%M:\%S \%Y'");
 
-    if (m_bVerbose)
+    if (m_bVerbose && bShallow)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "will shallow since: " + SHALLOW_DATE);
 
-    std::string ret = execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland-" + USERNAME + " --shallow-since='" + SHALLOW_DATE + "'");
+    std::string ret =
+        execAndGet("cd /tmp/hyprpm && git clone --recursive https://github.com/hyprwm/hyprland hyprland-" + USERNAME + (bShallow ? " --shallow-since='" + SHALLOW_DATE + "'" : ""));
 
     if (!std::filesystem::exists(WORKINGDIR)) {
         progress.printMessageAbove(std::string{Colors::RED} + "✖" + Colors::RESET + " Clone failed. Retrying without shallow.");

commit e848a448afc2e5a49b256de8993f80085573991a
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun May 12 16:00:55 2024 +0100

    keybinds: fix pass
    
    reverts #5967
    
    fixes #6022

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index b17c6785..fab40a00 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1915,6 +1915,7 @@ void CKeybindManager::pass(std::string regexp) {
     const auto XWTOXW       = PWINDOW->m_bIsX11 && g_pCompositor->m_pLastWindow && g_pCompositor->m_pLastWindow->m_bIsX11;
     const auto SL           = Vector2D(g_pCompositor->m_sSeat.seat->pointer_state.sx, g_pCompositor->m_sSeat.seat->pointer_state.sy);
     uint32_t   keycodes[32] = {0};
+    const auto LASTSRF      = g_pCompositor->m_pLastFocus;
 
     // pass all mf shit
     if (!XWTOXW) {
@@ -1965,7 +1966,7 @@ void CKeybindManager::pass(std::string regexp) {
     }
 
     if (g_pKeybindManager->m_uLastCode != 0)
-        wlr_seat_keyboard_enter(g_pCompositor->m_sSeat.seat, PWINDOW->m_pWLSurface.wlr(), KEYBOARD->keycodes, KEYBOARD->num_keycodes, &KEYBOARD->modifiers);
+        wlr_seat_keyboard_enter(g_pCompositor->m_sSeat.seat, LASTSRF, KEYBOARD->keycodes, KEYBOARD->num_keycodes, &KEYBOARD->modifiers);
     else
         wlr_seat_pointer_enter(g_pCompositor->m_sSeat.seat, PWINDOW->m_pWLSurface.wlr(), SL.x, SL.y);
 }

commit 3d7783df1d61fff9e1b2fd9867a791540ee8f2bb
Author: Paul <leftaslt@gmail.com>
Date:   Mon May 13 16:57:06 2024 +0300

    hyprctl: Add locked cmd to requests (#6042)
    
    Co-authored-by: Leftas <info@leftas.dev>

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index a19d4d95..ff12efb4 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -1544,6 +1544,18 @@ std::string dispatchDismissNotify(eHyprCtlOutputFormat format, std::string reque
     return "ok";
 }
 
+std::string getIsLocked(eHyprCtlOutputFormat format, std::string request) {
+    std::string lockedStr = g_pSessionLockManager->isSessionLocked() ? "true" : "false";
+    if (format == eHyprCtlOutputFormat::FORMAT_JSON)
+        lockedStr = std::format(R"#(
+{{
+    "locked": {}
+}}
+)#",
+                                lockedStr);
+    return lockedStr;
+}
+
 CHyprCtl::CHyprCtl() {
     registerCommand(SHyprCtlCommand{"workspaces", true, workspacesRequest});
     registerCommand(SHyprCtlCommand{"workspacerules", true, workspaceRulesRequest});
@@ -1563,6 +1575,7 @@ CHyprCtl::CHyprCtl() {
     registerCommand(SHyprCtlCommand{"rollinglog", true, rollinglogRequest});
     registerCommand(SHyprCtlCommand{"layouts", true, layoutsRequest});
     registerCommand(SHyprCtlCommand{"configerrors", true, configErrorsRequest});
+    registerCommand(SHyprCtlCommand{"locked", true, getIsLocked});
 
     registerCommand(SHyprCtlCommand{"monitors", false, monitorsRequest});
     registerCommand(SHyprCtlCommand{"reload", false, reloadRequest});

commit a70bc3c6822377fc1cca09c7783d53891a21cfa8
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon May 13 22:21:06 2024 +0100

    window: set sane default pseudo size

diff --git a/src/desktop/Window.hpp b/src/desktop/Window.hpp
index 4eccba55..a447fbf7 100644
--- a/src/desktop/Window.hpp
+++ b/src/desktop/Window.hpp
@@ -252,7 +252,7 @@ class CWindow {
 
     // this is used for pseudotiling
     bool         m_bIsPseudotiled = false;
-    Vector2D     m_vPseudoSize    = Vector2D(0, 0);
+    Vector2D     m_vPseudoSize    = Vector2D(1280, 720);
 
     bool         m_bFirstMap           = false; // for layouts
     bool         m_bIsFloating         = false;

commit df1f9101face0f1c8be292b0aad5f0255f9b4737
Author: Daniil <118675096+dnvery@users.noreply.github.com>
Date:   Tue May 14 12:33:20 2024 +0000

    xwayland: Remove delta for real position with xwayland zero scaling (#6057)

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index d3a31480..dbfb77ec 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -1189,9 +1189,7 @@ void Events::listener_unmanagedSetGeometry(void* owner, void* data) {
 
         if (*PXWLFORCESCALEZERO) {
             if (const auto PMONITOR = g_pCompositor->getMonitorFromID(PWINDOW->m_iMonitorID); PMONITOR) {
-                const Vector2D DELTA = PWINDOW->m_vRealSize.goal() - PWINDOW->m_vRealSize.goal() / PMONITOR->scale;
                 PWINDOW->m_vRealSize.setValueAndWarp(PWINDOW->m_vRealSize.goal() / PMONITOR->scale);
-                PWINDOW->m_vRealPosition.setValueAndWarp(PWINDOW->m_vRealPosition.goal() + DELTA / 2.0);
             }
         }
 

commit 520fceb801a656e66b143f31464e1ec0c4581bf8
Author: Raphael Tannous <107765121+rofe33@users.noreply.github.com>
Date:   Wed May 15 18:54:23 2024 +0300

    hyprctl: return exitStatus in requestHyprpaper() and request() (#6083)

diff --git a/hyprctl/main.cpp b/hyprctl/main.cpp
index 097ef5d8..e9d7583c 100644
--- a/hyprctl/main.cpp
+++ b/hyprctl/main.cpp
@@ -90,24 +90,24 @@ std::vector<SInstanceData> instances() {
     return result;
 }
 
-void request(std::string arg, int minArgs = 0) {
+int request(std::string arg, int minArgs = 0) {
     const auto SERVERSOCKET = socket(AF_UNIX, SOCK_STREAM, 0);
 
     const auto ARGS = std::count(arg.begin(), arg.end(), ' ');
 
     if (ARGS < minArgs) {
         std::cout << "Not enough arguments, expected at least " << minArgs;
-        return;
+        return -1;
     }
 
     if (SERVERSOCKET < 0) {
         std::cout << "Couldn't open a socket (1)";
-        return;
+        return 1;
     }
 
     if (instanceSignature.empty()) {
         std::cout << "HYPRLAND_INSTANCE_SIGNATURE was not set! (Is Hyprland running?)";
-        return;
+        return 2;
     }
 
     const std::string USERID = std::to_string(getpwuid(getuid())->pw_uid);
@@ -121,14 +121,14 @@ void request(std::string arg, int minArgs = 0) {
 
     if (connect(SERVERSOCKET, (sockaddr*)&serverAddress, SUN_LEN(&serverAddress)) < 0) {
         std::cout << "Couldn't connect to " << socketPath << ". (3)";
-        return;
+        return 3;
     }
 
     auto sizeWritten = write(SERVERSOCKET, arg.c_str(), arg.length());
 
     if (sizeWritten < 0) {
         std::cout << "Couldn't write (4)";
-        return;
+        return 4;
     }
 
     std::string reply        = "";
@@ -138,7 +138,7 @@ void request(std::string arg, int minArgs = 0) {
 
     if (sizeWritten < 0) {
         std::cout << "Couldn't read (5)";
-        return;
+        return 5;
     }
 
     reply += std::string(buffer, sizeWritten);
@@ -147,7 +147,7 @@ void request(std::string arg, int minArgs = 0) {
         sizeWritten = read(SERVERSOCKET, buffer, 8192);
         if (sizeWritten < 0) {
             std::cout << "Couldn't read (5)";
-            return;
+            return 5;
         }
         reply += std::string(buffer, sizeWritten);
     }
@@ -155,19 +155,21 @@ void request(std::string arg, int minArgs = 0) {
     close(SERVERSOCKET);
 
     std::cout << reply;
+
+    return 0;
 }
 
-void requestHyprpaper(std::string arg) {
+int requestHyprpaper(std::string arg) {
     const auto SERVERSOCKET = socket(AF_UNIX, SOCK_STREAM, 0);
 
     if (SERVERSOCKET < 0) {
         std::cout << "Couldn't open a socket (1)";
-        return;
+        return 1;
     }
 
     if (instanceSignature.empty()) {
         std::cout << "HYPRLAND_INSTANCE_SIGNATURE was not set! (Is Hyprland running?)";
-        return;
+        return 2;
     }
 
     sockaddr_un serverAddress = {0};
@@ -181,7 +183,7 @@ void requestHyprpaper(std::string arg) {
 
     if (connect(SERVERSOCKET, (sockaddr*)&serverAddress, SUN_LEN(&serverAddress)) < 0) {
         std::cout << "Couldn't connect to " << socketPath << ". (3)";
-        return;
+        return 3;
     }
 
     arg = arg.substr(arg.find_first_of('/') + 1); // strip flags
@@ -191,7 +193,7 @@ void requestHyprpaper(std::string arg) {
 
     if (sizeWritten < 0) {
         std::cout << "Couldn't write (4)";
-        return;
+        return 4;
     }
 
     char buffer[8192] = {0};
@@ -200,12 +202,14 @@ void requestHyprpaper(std::string arg) {
 
     if (sizeWritten < 0) {
         std::cout << "Couldn't read (5)";
-        return;
+        return 5;
     }
 
     close(SERVERSOCKET);
 
     std::cout << std::string(buffer);
+
+    return 0;
 }
 
 void batchRequest(std::string arg, bool json) {
@@ -384,33 +388,33 @@ int main(int argc, char** argv) {
     if (fullRequest.contains("/--batch"))
         batchRequest(fullRequest, json);
     else if (fullRequest.contains("/hyprpaper"))
-        requestHyprpaper(fullRequest);
+        exitStatus = requestHyprpaper(fullRequest);
     else if (fullRequest.contains("/switchxkblayout"))
-        request(fullRequest, 2);
+        exitStatus = request(fullRequest, 2);
     else if (fullRequest.contains("/seterror"))
-        request(fullRequest, 1);
+        exitStatus = request(fullRequest, 1);
     else if (fullRequest.contains("/setprop"))
-        request(fullRequest, 3);
+        exitStatus = request(fullRequest, 3);
     else if (fullRequest.contains("/plugin"))
-        request(fullRequest, 1);
+        exitStatus = request(fullRequest, 1);
     else if (fullRequest.contains("/dismissnotify"))
-        request(fullRequest, 0);
+        exitStatus = request(fullRequest, 0);
     else if (fullRequest.contains("/notify"))
-        request(fullRequest, 2);
+        exitStatus = request(fullRequest, 2);
     else if (fullRequest.contains("/output"))
-        request(fullRequest, 2);
+        exitStatus = request(fullRequest, 2);
     else if (fullRequest.contains("/setcursor"))
-        request(fullRequest, 1);
+        exitStatus = request(fullRequest, 1);
     else if (fullRequest.contains("/dispatch"))
-        request(fullRequest, 1);
+        exitStatus = request(fullRequest, 1);
     else if (fullRequest.contains("/keyword"))
-        request(fullRequest, 2);
+        exitStatus = request(fullRequest, 2);
     else if (fullRequest.contains("/decorations"))
-        request(fullRequest, 1);
+        exitStatus = request(fullRequest, 1);
     else if (fullRequest.contains("/--help"))
         std::cout << USAGE << std::endl;
     else {
-        request(fullRequest);
+        exitStatus = request(fullRequest);
     }
 
     std::cout << std::endl;

commit 186202732a3215ef2bfce810431313fe39b59a7c
Author: JManch <61563764+JManch@users.noreply.github.com>
Date:   Wed May 15 21:03:51 2024 +0100

    keybinds: fix empty on monitor for new workspaces (#6089)

diff --git a/src/helpers/MiscFunctions.cpp b/src/helpers/MiscFunctions.cpp
index bdd7f847..defffe52 100644
--- a/src/helpers/MiscFunctions.cpp
+++ b/src/helpers/MiscFunctions.cpp
@@ -281,16 +281,24 @@ int getWorkspaceIDFromString(const std::string& in, std::string& outName) {
     } else if (in.starts_with("empty")) {
         const bool same_mon = in.substr(5).contains("m");
         const bool next     = in.substr(5).contains("n");
-        if (same_mon || next) {
-            if (!g_pCompositor->m_pLastMonitor) {
-                Debug::log(ERR, "Empty monitor workspace on monitor null!");
-                return WORKSPACE_INVALID;
+        if ((same_mon || next) && !g_pCompositor->m_pLastMonitor) {
+            Debug::log(ERR, "Empty monitor workspace on monitor null!");
+            return WORKSPACE_INVALID;
+        }
+
+        std::set<int> invalidWSes;
+        if (same_mon) {
+            for (auto& rule : g_pConfigManager->getAllWorkspaceRules()) {
+                const auto PMONITOR = g_pCompositor->getMonitorFromName(rule.monitor);
+                if (PMONITOR && (PMONITOR->ID != g_pCompositor->m_pLastMonitor->ID))
+                    invalidWSes.insert(rule.workspaceId);
             }
         }
+
         int id = next ? g_pCompositor->m_pLastMonitor->activeWorkspaceID() : 0;
         while (++id < INT_MAX) {
             const auto PWORKSPACE = g_pCompositor->getWorkspaceByID(id);
-            if (!PWORKSPACE || (g_pCompositor->getWindowsOnWorkspace(id) == 0 && (!same_mon || PWORKSPACE->m_iMonitorID == g_pCompositor->m_pLastMonitor->ID)))
+            if (!invalidWSes.contains(id) && (!PWORKSPACE || g_pCompositor->getWindowsOnWorkspace(id) == 0))
                 return id;
         }
     } else if (in.starts_with("prev")) {

commit f314e0451c952b7420de6d80fcf3e7ff6db90a67
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed May 15 23:01:48 2024 +0100

    sysd: add missing header
    
    ref #6094

diff --git a/src/helpers/SdDaemon.cpp b/src/helpers/SdDaemon.cpp
index d5df3121..497101e4 100644
--- a/src/helpers/SdDaemon.cpp
+++ b/src/helpers/SdDaemon.cpp
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <string.h>
 
 namespace Systemd {
     int SdBooted(void) {

commit eec65f442bf3b227ed6c5650b383d9a3cfbc6f75
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu May 16 00:55:55 2024 +0100

    configmgr: shadow exec rules when window is unmapped
    
    fixes #6091

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 61988040..051dff6b 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -1027,6 +1027,9 @@ std::vector<SWindowRule> CConfigManager::getMatchingRules(CWindow* pWindow, bool
     if (!g_pCompositor->windowExists(pWindow))
         return std::vector<SWindowRule>();
 
+    // if the window is unmapped, don't process exec rules yet.
+    shadowExec = shadowExec || !pWindow->m_bIsMapped;
+
     std::vector<SWindowRule> returns;
 
     std::string              title      = g_pXWaylandManager->getTitle(pWindow);

commit cdd36654f77997b69cc17aeb8390d609c2b03c3e
Author: Gabriel Ford <gabe@fordltc.net>
Date:   Sat May 18 18:28:48 2024 +0000

    layout: Fix shrinking pseudotile windows. (#6143)

diff --git a/src/layout/IHyprLayout.cpp b/src/layout/IHyprLayout.cpp
index 3648faee..cb1cceaa 100644
--- a/src/layout/IHyprLayout.cpp
+++ b/src/layout/IHyprLayout.cpp
@@ -518,7 +518,7 @@ void IHyprLayout::changeWindowFloatingMode(CWindow* pWindow) {
         CBox wb = {pWindow->m_vRealPosition.goal() + (pWindow->m_vRealSize.goal() - pWindow->m_vLastFloatingSize) / 2.f, pWindow->m_vLastFloatingSize};
         wb.round();
 
-        if (DELTALESSTHAN(pWindow->m_vRealSize.value().x, pWindow->m_vLastFloatingSize.x, 10) &&
+        if (!(pWindow->m_bIsFloating && pWindow->m_bIsPseudotiled) && DELTALESSTHAN(pWindow->m_vRealSize.value().x, pWindow->m_vLastFloatingSize.x, 10) &&
             DELTALESSTHAN(pWindow->m_vRealSize.value().y, pWindow->m_vLastFloatingSize.y, 10)) {
             wb = {wb.pos() + Vector2D{10, 10}, wb.size() - Vector2D{20, 20}};
         }

commit 6ca142811ce88e08796317e9657a7a998705e71b
Author: shezdy <77217897+shezdy@users.noreply.github.com>
Date:   Wed May 22 13:51:46 2024 -0600

    keybinds: Add option to disable window direction monitor fallback (#6182)
    
    * add monitor fallback option
    
    * format

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 07d386c0..b02d31af 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -1620,7 +1620,8 @@ CWindow* CCompositor::getWindowInDirection(CWindow* pWindow, char dir) {
         return nullptr;
 
     // 0 -> history, 1 -> shared length
-    static auto PMETHOD = CConfigValue<Hyprlang::INT>("binds:focus_preferred_method");
+    static auto PMETHOD          = CConfigValue<Hyprlang::INT>("binds:focus_preferred_method");
+    static auto PMONITORFALLBACK = CConfigValue<Hyprlang::INT>("binds:window_direction_monitor_fallback");
 
     const auto  PMONITOR = g_pCompositor->getMonitorFromID(pWindow->m_iMonitorID);
 
@@ -1650,6 +1651,9 @@ CWindow* CCompositor::getWindowInDirection(CWindow* pWindow, char dir) {
             if (PWORKSPACE->m_bHasFullscreenWindow && !w->m_bIsFullscreen && !w->m_bCreatedOverFullscreen)
                 continue;
 
+            if (!*PMONITORFALLBACK && pWindow->m_iMonitorID != w->m_iMonitorID)
+                continue;
+
             const auto BWINDOWIDEALBB = w->getWindowIdealBoundingBoxIgnoreReserved();
 
             const auto POSB  = Vector2D(BWINDOWIDEALBB.x, BWINDOWIDEALBB.y);
@@ -1739,6 +1743,9 @@ CWindow* CCompositor::getWindowInDirection(CWindow* pWindow, char dir) {
             if (PWORKSPACE->m_bHasFullscreenWindow && !w->m_bIsFullscreen && !w->m_bCreatedOverFullscreen)
                 continue;
 
+            if (!*PMONITORFALLBACK && pWindow->m_iMonitorID != w->m_iMonitorID)
+                continue;
+
             const auto DIST  = w->middle().distance(pWindow->middle());
             const auto ANGLE = vectorAngles(Vector2D{w->middle() - pWindow->middle()}, VECTORS.at(dir));
 
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 051dff6b..3fcf6930 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -493,6 +493,7 @@ CConfigManager::CConfigManager() {
     m_pConfig->addConfigValue("binds:ignore_group_lock", Hyprlang::INT{0});
     m_pConfig->addConfigValue("binds:movefocus_cycles_fullscreen", Hyprlang::INT{1});
     m_pConfig->addConfigValue("binds:disable_keybind_grabbing", Hyprlang::INT{0});
+    m_pConfig->addConfigValue("binds:window_direction_monitor_fallback", Hyprlang::INT{1});
 
     m_pConfig->addConfigValue("gestures:workspace_swipe", Hyprlang::INT{0});
     m_pConfig->addConfigValue("gestures:workspace_swipe_fingers", Hyprlang::INT{3});
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index fab40a00..de94e933 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1175,8 +1175,9 @@ void CKeybindManager::moveActiveToWorkspaceSilent(std::string args) {
 }
 
 void CKeybindManager::moveFocusTo(std::string args) {
-    static auto PFULLCYCLE = CConfigValue<Hyprlang::INT>("binds:movefocus_cycles_fullscreen");
-    char        arg        = args[0];
+    static auto PFULLCYCLE       = CConfigValue<Hyprlang::INT>("binds:movefocus_cycles_fullscreen");
+    static auto PMONITORFALLBACK = CConfigValue<Hyprlang::INT>("binds:window_direction_monitor_fallback");
+    char        arg              = args[0];
 
     if (!isDirection(args)) {
         Debug::log(ERR, "Cannot move focus in direction {}, unsupported direction. Supported: l,r,u/t,d/b", arg);
@@ -1185,7 +1186,9 @@ void CKeybindManager::moveFocusTo(std::string args) {
 
     const auto PLASTWINDOW = g_pCompositor->m_pLastWindow;
     if (!PLASTWINDOW) {
-        tryMoveFocusToMonitor(g_pCompositor->getMonitorInDirection(arg));
+        if (*PMONITORFALLBACK)
+            tryMoveFocusToMonitor(g_pCompositor->getMonitorInDirection(arg));
+
         return;
     }
 
@@ -1201,7 +1204,7 @@ void CKeybindManager::moveFocusTo(std::string args) {
 
     Debug::log(LOG, "No window found in direction {}, looking for a monitor", arg);
 
-    if (tryMoveFocusToMonitor(g_pCompositor->getMonitorInDirection(arg)))
+    if (*PMONITORFALLBACK && tryMoveFocusToMonitor(g_pCompositor->getMonitorInDirection(arg)))
         return;
 
     static auto PNOFALLBACK = CConfigValue<Hyprlang::INT>("general:no_focus_fallback");
@@ -1272,6 +1275,8 @@ void CKeybindManager::moveActiveTo(std::string args) {
             moveActiveToWorkspaceSilent(PNEWMONITOR->activeWorkspace->getConfigName());
         else
             moveActiveToWorkspace(PNEWMONITOR->activeWorkspace->getConfigName());
+
+        return;
     }
 
     if (!isDirection(args)) {
@@ -1311,6 +1316,10 @@ void CKeybindManager::moveActiveTo(std::string args) {
         return;
     }
 
+    static auto PMONITORFALLBACK = CConfigValue<Hyprlang::INT>("binds:window_direction_monitor_fallback");
+    if (!*PMONITORFALLBACK)
+        return;
+
     // Otherwise, we always want to move to the next monitor in that direction
     const auto PMONITORTOCHANGETO = g_pCompositor->getMonitorInDirection(arg);
     if (!PMONITORTOCHANGETO)

commit 6e758c8010d9a7d79cbabc4b1d226f010d39d5b1
Author: vaxerski <vaxry@vaxry.net>
Date:   Wed May 22 22:37:02 2024 +0200

    window: guard monitor in bounding box calculations
    
    fixes #6190

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index a365ef79..8f13718f 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -41,9 +41,9 @@ SWindowDecorationExtents CWindow::getFullWindowExtents() {
     const int BORDERSIZE = getRealBorderSize();
 
     if (m_sAdditionalConfigData.dimAround) {
-        const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID);
-        return {{m_vRealPosition.value().x - PMONITOR->vecPosition.x, m_vRealPosition.value().y - PMONITOR->vecPosition.y},
-                {PMONITOR->vecSize.x - (m_vRealPosition.value().x - PMONITOR->vecPosition.x), PMONITOR->vecSize.y - (m_vRealPosition.value().y - PMONITOR->vecPosition.y)}};
+        if (const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID); PMONITOR)
+            return {{m_vRealPosition.value().x - PMONITOR->vecPosition.x, m_vRealPosition.value().y - PMONITOR->vecPosition.y},
+                    {PMONITOR->vecSize.x - (m_vRealPosition.value().x - PMONITOR->vecPosition.x), PMONITOR->vecSize.y - (m_vRealPosition.value().y - PMONITOR->vecPosition.y)}};
     }
 
     SWindowDecorationExtents maxExtents = {{BORDERSIZE + 2, BORDERSIZE + 2}, {BORDERSIZE + 2, BORDERSIZE + 2}};
@@ -98,8 +98,8 @@ SWindowDecorationExtents CWindow::getFullWindowExtents() {
 
 CBox CWindow::getFullWindowBoundingBox() {
     if (m_sAdditionalConfigData.dimAround) {
-        const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID);
-        return {PMONITOR->vecPosition.x, PMONITOR->vecPosition.y, PMONITOR->vecSize.x, PMONITOR->vecSize.y};
+        if (const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID); PMONITOR)
+            return {PMONITOR->vecPosition.x, PMONITOR->vecPosition.y, PMONITOR->vecSize.x, PMONITOR->vecSize.y};
     }
 
     auto maxExtents = getFullWindowExtents();

commit a4e886ab15e06dbcb973bae2be841cb1b9594ad9
Author: shezdy <77217897+shezdy@users.noreply.github.com>
Date:   Thu May 23 05:01:12 2024 -0600

    internal: save previous workspace before change (#6202)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index de94e933..c285f92c 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1026,6 +1026,14 @@ void CKeybindManager::changeworkspace(std::string args) {
 
     g_pCompositor->setActiveMonitor(PMONITORWORKSPACEOWNER);
 
+    if (BISWORKSPACECURRENT) {
+        if (*PALLOWWORKSPACECYCLES)
+            pWorkspaceToChangeTo->rememberPrevWorkspace(PCURRENTWORKSPACE);
+        else if (!EXPLICITPREVIOUS && !*PBACKANDFORTH)
+            pWorkspaceToChangeTo->rememberPrevWorkspace(nullptr);
+    } else
+        pWorkspaceToChangeTo->rememberPrevWorkspace(PCURRENTWORKSPACE);
+
     PMONITORWORKSPACEOWNER->changeWorkspace(pWorkspaceToChangeTo, false, true);
 
     if (PMONITOR != PMONITORWORKSPACEOWNER) {
@@ -1038,14 +1046,6 @@ void CKeybindManager::changeworkspace(std::string args) {
         g_pCompositor->warpCursorTo(middle);
     }
 
-    if (BISWORKSPACECURRENT) {
-        if (*PALLOWWORKSPACECYCLES)
-            pWorkspaceToChangeTo->rememberPrevWorkspace(PCURRENTWORKSPACE);
-        else if (!EXPLICITPREVIOUS && !*PBACKANDFORTH)
-            pWorkspaceToChangeTo->rememberPrevWorkspace(nullptr);
-    } else
-        pWorkspaceToChangeTo->rememberPrevWorkspace(PCURRENTWORKSPACE);
-
     if (!g_pInputManager->m_bLastFocusOnLS) {
         if (g_pCompositor->m_pLastFocus)
             g_pInputManager->sendMotionEventsToFocused();
@@ -1118,13 +1118,13 @@ void CKeybindManager::moveActiveToWorkspace(std::string args) {
     else if (POLDWS->m_bIsSpecialWorkspace)
         g_pCompositor->getMonitorFromID(POLDWS->m_iMonitorID)->setSpecialWorkspace(nullptr);
 
+    if (*PALLOWWORKSPACECYCLES)
+        pWorkspace->rememberPrevWorkspace(POLDWS);
+
     pMonitor->changeWorkspace(pWorkspace);
 
     g_pCompositor->focusWindow(PWINDOW);
     g_pCompositor->warpCursorTo(PWINDOW->middle());
-
-    if (*PALLOWWORKSPACECYCLES)
-        pWorkspace->rememberPrevWorkspace(POLDWS);
 }
 
 void CKeybindManager::moveActiveToWorkspaceSilent(std::string args) {

commit 92596c82f2951dc315af1bb1411d217be92699bb
Author: vaxerski <vaxry@vaxry.net>
Date:   Fri May 24 20:40:15 2024 +0200

    window: fix invalid env buffer size in getEnv

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index 8f13718f..78b715d7 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -1295,9 +1295,12 @@ std::unordered_map<std::string, std::string> CWindow::getEnv() {
         needle += 512;
     }
 
+    if (needle <= 1)
+        return {};
+
     std::replace(buffer.begin(), buffer.end() - 1, '\0', '\n');
 
-    CVarList envs(std::string{buffer.data(), needle - 1}, 0, '\n', true);
+    CVarList envs(std::string{buffer.data(), buffer.size() - 1}, 0, '\n', true);
 
     for (auto& e : envs) {
         if (!e.contains('='))

commit cdc21f77e5635eecef2313cbe914ff63046ca9a3
Author: Flafy <flafyarazi@gmail.com>
Date:   Mon May 27 23:31:35 2024 +0300

    hyprctl: add delimiter to hyprctl batch command (#6261)
    
    adds a delimiter of 3 newlines to separate different command outputs

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index ff12efb4..56ec7783 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -1030,13 +1030,15 @@ std::string dispatchBatch(eHyprCtlOutputFormat format, std::string request) {
 
     nextItem();
 
+    const std::string DELIMITER = "\n\n\n";
+
     while (curitem != "" || request != "") {
-        reply += g_pHyprCtl->getReply(curitem);
+        reply += g_pHyprCtl->getReply(curitem) + DELIMITER;
 
         nextItem();
     }
 
-    return reply;
+    return reply.substr(0, std::max(static_cast<int>(reply.size() - DELIMITER.size()), 0));
 }
 
 std::string dispatchSetCursor(eHyprCtlOutputFormat format, std::string request) {

commit c6140e5fe87b5137c694ef635874bafaed0ad7e5
Author: Connor Wong <cdubthecoolcat@gmail.com>
Date:   Mon May 27 13:45:32 2024 -0700

    windows: make new_window_takes_over_fullscreen use the new window's workspace (#6263)
    
    * fix new_window_takes_over_fullscreen behavior
    
    * missed a few things

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index dbfb77ec..e414000e 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -486,12 +486,12 @@ void Events::listener_mapWindow(void* owner, void* data) {
     const auto PLSFROMFOCUS = g_pCompositor->getLayerSurfaceFromSurface(g_pCompositor->m_pLastFocus);
     if (PLSFROMFOCUS && PLSFROMFOCUS->layerSurface->current.keyboard_interactive)
         PWINDOW->m_bNoInitialFocus = true;
-    if (PWORKSPACE->m_bHasFullscreenWindow && !requestsFullscreen && !PWINDOW->m_bIsFloating) {
+    if (PWINDOW->m_pWorkspace->m_bHasFullscreenWindow && !requestsFullscreen && !PWINDOW->m_bIsFloating) {
         if (*PNEWTAKESOVERFS == 0)
             PWINDOW->m_bNoInitialFocus = true;
         else if (*PNEWTAKESOVERFS == 2)
-            g_pCompositor->setWindowFullscreen(g_pCompositor->getFullscreenWindowOnWorkspace(PWORKSPACE->m_iID), false, FULLSCREEN_INVALID);
-        else if (PWORKSPACE->m_efFullscreenMode == FULLSCREEN_MAXIMIZED)
+            g_pCompositor->setWindowFullscreen(g_pCompositor->getFullscreenWindowOnWorkspace(PWINDOW->m_pWorkspace->m_iID), false, FULLSCREEN_INVALID);
+        else if (PWINDOW->m_pWorkspace->m_efFullscreenMode == FULLSCREEN_MAXIMIZED)
             requestsMaximize = true;
         else
             requestsFullscreen = true;
@@ -538,8 +538,8 @@ void Events::listener_mapWindow(void* owner, void* data) {
     if ((requestsFullscreen && (!(PWINDOW->m_eSuppressedEvents & SUPPRESS_FULLSCREEN) || overridingNoFullscreen)) ||
         (requestsMaximize && (!(PWINDOW->m_eSuppressedEvents & SUPPRESS_MAXIMIZE) || overridingNoMaximize)) || requestsFakeFullscreen) {
         // fix fullscreen on requested (basically do a switcheroo)
-        if (PWORKSPACE->m_bHasFullscreenWindow) {
-            const auto PFULLWINDOW = g_pCompositor->getFullscreenWindowOnWorkspace(PWORKSPACE->m_iID);
+        if (PWINDOW->m_pWorkspace->m_bHasFullscreenWindow) {
+            const auto PFULLWINDOW = g_pCompositor->getFullscreenWindowOnWorkspace(PWINDOW->m_pWorkspace->m_iID);
             g_pCompositor->setWindowFullscreen(PFULLWINDOW, false, FULLSCREEN_FULL);
         }
 

commit c8bd1be601fb6258f71708fd6e896fc747bf368f
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon Jun 3 21:09:18 2024 +0200

    window: avoid nullptr deref on monitor in box helpers
    
    fixes #6321

diff --git a/src/desktop/Window.cpp b/src/desktop/Window.cpp
index 78b715d7..9c6676e7 100644
--- a/src/desktop/Window.cpp
+++ b/src/desktop/Window.cpp
@@ -111,11 +111,13 @@ CBox CWindow::getFullWindowBoundingBox() {
 }
 
 CBox CWindow::getWindowIdealBoundingBoxIgnoreReserved() {
-
     const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID);
 
-    auto       POS  = m_vPosition;
-    auto       SIZE = m_vSize;
+    if (!PMONITOR)
+        return {m_vPosition, m_vSize};
+
+    auto POS  = m_vPosition;
+    auto SIZE = m_vSize;
 
     if (m_bIsFullscreen) {
         POS  = PMONITOR->vecPosition;
@@ -143,10 +145,10 @@ CBox CWindow::getWindowIdealBoundingBoxIgnoreReserved() {
 }
 
 CBox CWindow::getWindowBoxUnified(uint64_t properties) {
-
     if (m_sAdditionalConfigData.dimAround) {
         const auto PMONITOR = g_pCompositor->getMonitorFromID(m_iMonitorID);
-        return {PMONITOR->vecPosition.x, PMONITOR->vecPosition.y, PMONITOR->vecSize.x, PMONITOR->vecSize.y};
+        if (PMONITOR)
+            return {PMONITOR->vecPosition.x, PMONITOR->vecPosition.y, PMONITOR->vecSize.x, PMONITOR->vecSize.y};
     }
 
     SWindowDecorationExtents EXTENTS = {{0, 0}, {0, 0}};

commit f192a1ebbaffefc3c64e2c0c3bf3f2522290be60
Author: phonetic112 <73647246+phonetic112@users.noreply.github.com>
Date:   Wed Jun 5 12:26:38 2024 -0400

    hyprctl: Allow setting name for custom/headless outputs (#6319)

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index 56ec7783..204de7b5 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -1347,73 +1347,64 @@ std::string decorationRequest(eHyprCtlOutputFormat format, std::string request)
     return result;
 }
 
-void createOutputIter(wlr_backend* backend, void* data) {
-    const auto DATA = (std::pair<std::string, bool>*)data;
-
-    if (DATA->second)
-        return;
-
-    if (DATA->first.empty() || DATA->first == "auto") {
-        if (wlr_backend_is_wl(backend)) {
-            wlr_wl_output_create(backend);
-            DATA->second = true;
-        } else if (wlr_backend_is_x11(backend)) {
-            wlr_x11_output_create(backend);
-            DATA->second = true;
-        } else if (wlr_backend_is_headless(backend)) {
-            wlr_headless_add_output(backend, 1920, 1080);
-            DATA->second = true;
-        }
+static bool addOutput(wlr_backend* backend, const std::string& type, const std::string& name) {
+    wlr_output* output = nullptr;
+
+    if (type.empty() || type == "auto") {
+        if (wlr_backend_is_wl(backend))
+            output = wlr_wl_output_create(backend);
+        else if (wlr_backend_is_headless(backend))
+            output = wlr_headless_add_output(backend, 1920, 1080);
     } else {
-        if (wlr_backend_is_wl(backend) && DATA->first == "wayland") {
-            wlr_wl_output_create(backend);
-            DATA->second = true;
-        } else if (wlr_backend_is_x11(backend) && DATA->first == "x11") {
-            wlr_x11_output_create(backend);
-            DATA->second = true;
-        } else if (wlr_backend_is_headless(backend) && DATA->first == "headless") {
-            wlr_headless_add_output(backend, 1920, 1080);
-            DATA->second = true;
-        }
+        if (wlr_backend_is_wl(backend) && type == "wayland")
+            output = wlr_wl_output_create(backend);
+        else if (wlr_backend_is_headless(backend) && type == "headless")
+            output = wlr_headless_add_output(backend, 1920, 1080);
     }
-}
 
-std::string dispatchOutput(eHyprCtlOutputFormat format, std::string request) {
-    std::string curitem = "";
+    if (output && !name.empty())
+        g_pCompositor->getMonitorFromOutput(output)->szName = name;
 
-    auto        nextItem = [&]() {
-        auto idx = request.find_first_of(' ');
+    return output != nullptr;
+}
 
-        if (idx != std::string::npos) {
-            curitem = request.substr(0, idx);
-            request = request.substr(idx + 1);
-        } else {
-            curitem = request;
-            request = "";
-        }
+struct outputData {
+    std::string type;
+    std::string name;
+    bool        added;
+};
 
-        curitem = removeBeginEndSpacesTabs(curitem);
-    };
+void createOutputIter(wlr_backend* backend, void* data) {
+    const auto DATA = static_cast<outputData*>(data);
 
-    nextItem();
-    nextItem();
+    if (DATA->added)
+        return;
 
-    const auto MODE = curitem;
+    if (addOutput(backend, DATA->type, DATA->name))
+        DATA->added = true;
+}
 
-    nextItem();
+std::string dispatchOutput(eHyprCtlOutputFormat format, std::string request) {
+    CVarList vars(request, 0, ' ');
 
-    const auto NAME = curitem;
+    if (vars.size() < 2)
+        return "not enough args";
+
+    const auto MODE = vars[1];
 
     if (MODE == "create" || MODE == "add") {
-        std::pair<std::string, bool> result = {NAME, false};
+        if (g_pCompositor->getMonitorFromName(vars[3]))
+            return "A real monitor already uses that name.";
+
+        outputData result{vars[2], vars[3], false};
 
         wlr_multi_for_each_backend(g_pCompositor->m_sWLRBackend, createOutputIter, &result);
 
-        if (!result.second)
+        if (!result.added)
             return "no backend replied to the request";
 
     } else if (MODE == "destroy" || MODE == "remove") {
-        const auto PMONITOR = g_pCompositor->getMonitorFromName(NAME);
+        const auto PMONITOR = g_pCompositor->getMonitorFromName(vars[2]);
 
         if (!PMONITOR)
             return "output not found";

commit 07c18cc77d5d16dba654282dc49ddfb41aca3b17
Author: John M. Harris, Jr <johnmh@johnmh.me>
Date:   Fri Jun 7 09:31:27 2024 -0700

    hookSystem: Make needsDeadCleanup volatile (#6356)
    
    The value of needsDeadCleanup would be clobbered after longjmp,
    having an undefined value.

diff --git a/src/managers/HookSystemManager.cpp b/src/managers/HookSystemManager.cpp
index 11007f1a..cd8ba516 100644
--- a/src/managers/HookSystemManager.cpp
+++ b/src/managers/HookSystemManager.cpp
@@ -28,7 +28,7 @@ void CHookSystemManager::emit(std::vector<SCallbackFNPtr>* const callbacks, SCal
         return;
 
     std::vector<HANDLE> faultyHandles;
-    bool                needsDeadCleanup = false;
+    volatile bool       needsDeadCleanup = false;
 
     for (auto& cb : *callbacks) {
 
@@ -80,4 +80,4 @@ std::vector<SCallbackFNPtr>* CHookSystemManager::getVecForEvent(const std::strin
         Debug::log(LOG, "[hookSystem] New hook event registered: {}", event);
 
     return &m_mRegisteredHooks[event];
-}
\ No newline at end of file
+}

commit 3f8362f35e2cfebbe68b2bbaa624d8c77f19f3d2
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Jun 9 09:42:14 2024 +0200

    hyprpm: print and fail on missing packages during configure
    
    instead of failing later with something like exit code 2, print out what's missing

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 20c0c509..0daeefb1 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -494,6 +494,16 @@ bool CPluginManager::updateHeaders(bool force) {
     if (m_bVerbose)
         progress.printMessageAbove(std::string{Colors::BLUE} + "[v] " + Colors::RESET + "cmake returned: " + ret);
 
+    if (ret.contains("required packages were not found")) {
+        // missing deps, let the user know.
+        std::string missing = ret.substr(ret.find("The following required packages were not found:"));
+        missing             = missing.substr(0, missing.find("Call Stack"));
+        missing             = missing.substr(0, missing.find_last_of('\n'));
+
+        std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not configure the hyprland source, cmake complained:\n" << missing << "\n";
+        return false;
+    }
+
     // le hack. Wlroots has to generate its build/include
     ret = execAndGet("cd " + WORKINGDIR + "/subprojects/wlroots-hyprland && meson setup -Drenderers=gles2 -Dexamples=false build");
     if (m_bVerbose)

commit 3582cb25479117f8c55675949b3c56fd27958545
Author: Mykola Perehudov <nexec@users.noreply.github.com>
Date:   Sun Jun 9 10:43:39 2024 +0300

    helpers: fix misuse of syscalls in sd namespace (#6379)

diff --git a/src/helpers/SdDaemon.cpp b/src/helpers/SdDaemon.cpp
index 497101e4..25e0ca3b 100644
--- a/src/helpers/SdDaemon.cpp
+++ b/src/helpers/SdDaemon.cpp
@@ -21,8 +21,8 @@ namespace Systemd {
     }
 
     int SdNotify(int unsetEnvironment, const char* state) {
-        int fd = socket(AF_UNIX, SOCK_DGRAM, 0);
-        if (fd == -1)
+        int fd = socket(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0);
+        if (fd < 0)
             return -errno;
 
         constexpr char envVar[] = "NOTIFY_SOCKET";
@@ -47,12 +47,12 @@ namespace Systemd {
         if (unixAddr.sun_path[0] == '@')
             unixAddr.sun_path[0] = '\0';
 
-        if (!connect(fd, (const sockaddr*)&unixAddr, sizeof(struct sockaddr_un)))
-            return 1;
+        if (connect(fd, (const sockaddr*)&unixAddr, sizeof(struct sockaddr_un)) < 0)
+            return -errno;
 
         // arbitrary value which seems to be enough for s-d messages
-        size_t stateLen = strnlen(state, 128);
-        if (write(fd, state, stateLen) >= 0)
+        ssize_t stateLen = strnlen(state, 128);
+        if (write(fd, state, stateLen) == stateLen)
             return 1;
 
         return -errno;

commit 61fdb0bf60bd949372040968c9c00bb6e8a3d4ea
Author: DrummyFloyd <jonathan.monnet28@gmail.com>
Date:   Sun Jun 9 15:53:05 2024 +0200

    ci: add auto labels on PR (#6369)
    
    * ci: add auto labels
    
    * ci(labeler): add glob for src/protocols
    
    * ci: adapt to vaxerski request

diff --git a/.github/labeler.yml b/.github/labeler.yml
new file mode 100644
index 00000000..a0685fcf
--- /dev/null
+++ b/.github/labeler.yml
@@ -0,0 +1,83 @@
+assets:
+  - changed-files:
+      - any-glob-to-any-file: "assets/**"
+
+docs:
+  - changed-files:
+      - any-glob-to-any-file: "docs/**"
+
+hyprctl:
+  - changed-files:
+      - any-glob-to-any-file: "hyprctl/**"
+
+hyprpm:
+  - changed-files:
+      - any-glob-to-any-file: "hyprpm/**"
+
+nix:
+  - changed-files:
+      - any-glob-to-any-file: "nix/**"
+
+protocols:
+  - changed-files:
+      - any-glob-to-any-file: ["protocols/**", "src/protocols/**"]
+
+core:
+  - changed-files:
+      - any-glob-to-any-file: "src/**"
+
+config:
+  - changed-files:
+      - any-glob-to-any-file: "src/config/**"
+
+debug:
+  - changed-files:
+      - any-glob-to-any-file: "src/debug/**"
+
+desktop:
+  - changed-files:
+      - any-glob-to-any-file: "src/desktop/**"
+
+devices:
+  - changed-files:
+      - any-glob-to-any-file: "src/devices/**"
+
+events:
+  - changed-files:
+      - any-glob-to-any-file: "src/events/**"
+
+helpers:
+  - changed-files:
+      - any-glob-to-any-file: "src/helpers/**"
+
+hyprerror:
+  - changed-files:
+      - any-glob-to-any-file: "src/hyprerror/**"
+
+init:
+  - changed-files:
+      - any-glob-to-any-file: "src/init/**"
+
+layout:
+  - changed-files:
+      - any-glob-to-any-file: "src/layout/**"
+
+managers:
+  - changed-files:
+      - any-glob-to-any-file: "src/managers/**"
+
+pch:
+  - changed-files:
+      - any-glob-to-any-file: "src/pch/**"
+
+plugins:
+  - changed-files:
+      - any-glob-to-any-file: "src/plugins/**"
+
+render:
+  - changed-files:
+      - any-glob-to-any-file: "src/render/**"
+
+xwayland:
+  - changed-files:
+      - any-glob-to-any-file: "src/xwayland/**"
diff --git a/.github/workflows/labeler.yml b/.github/workflows/labeler.yml
new file mode 100644
index 00000000..52474c6a
--- /dev/null
+++ b/.github/workflows/labeler.yml
@@ -0,0 +1,12 @@
+name: "Pull Request Labeler"
+on:
+  - pull_request_target
+
+jobs:
+  labeler:
+    permissions:
+      contents: read
+      pull-requests: write
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/labeler@v5

commit 98f307fa4744f47fc6f844a1a3d99b0828e0bd5b
Author: Daniel Rammelt <daniel@styrocat.com>
Date:   Sun Sep 29 16:30:14 2024 +1300

    props: bump version to 0.39.3

diff --git a/props.json b/props.json
index 4f7eed72..72242080 100644
--- a/props.json
+++ b/props.json
@@ -1,3 +1,3 @@
 {
-    "version": "0.39.1"
-}
\ No newline at end of file
+    "version": "0.39.3"
+}

commit a8a951af14ca035c6d8413d7b72c38ec0e676fc9
Author: phonetic112 <73647246+phonetic112@users.noreply.github.com>
Date:   Thu Jun 13 17:23:23 2024 -0400

    misc: Fix build warnings (#6486)

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 0daeefb1..7a99662b 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -39,9 +39,10 @@ static std::string removeBeginEndSpacesTabs(std::string str) {
 
 static std::string execAndGet(std::string cmd) {
     cmd += " 2>&1";
-    std::array<char, 128>                          buffer;
-    std::string                                    result;
-    const std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
+    std::array<char, 128> buffer;
+    std::string           result;
+    using PcloseType = int (*)(FILE*);
+    const std::unique_ptr<FILE, PcloseType> pipe(popen(cmd.c_str(), "r"), static_cast<PcloseType>(pclose));
     if (!pipe)
         return "";
 
diff --git a/src/helpers/MiscFunctions.cpp b/src/helpers/MiscFunctions.cpp
index defffe52..99762b9d 100644
--- a/src/helpers/MiscFunctions.cpp
+++ b/src/helpers/MiscFunctions.cpp
@@ -619,9 +619,10 @@ float vecToRectDistanceSquared(const Vector2D& vec, const Vector2D& p1, const Ve
 
 // Execute a shell command and get the output
 std::string execAndGet(const char* cmd) {
-    std::array<char, 128>                          buffer;
-    std::string                                    result;
-    const std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
+    std::array<char, 128> buffer;
+    std::string           result;
+    using PcloseType = int (*)(FILE*);
+    const std::unique_ptr<FILE, PcloseType> pipe(popen(cmd, "r"), static_cast<PcloseType>(pclose));
     if (!pipe) {
         Debug::log(ERR, "execAndGet: failed in pipe");
         return "";

commit b08483000bfa0e19baed8aa745767531b94239a7
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Jun 18 21:38:33 2024 +0200

    hyprctl: avoid using select()
    
    move to poll()
    
    ref #6584

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index 204de7b5..e09bb445 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -10,6 +10,7 @@
 #include <sys/utsname.h>
 #include <sys/un.h>
 #include <unistd.h>
+#include <sys/poll.h>
 
 #include <sstream>
 #include <string>
@@ -1700,13 +1701,17 @@ int hyprCtlFDTick(int fd, uint32_t mask, void* data) {
 
     std::array<char, 1024> readBuffer;
 
-    fd_set                 fdset;
-    FD_ZERO(&fdset);
-    FD_SET(ACCEPTEDCONNECTION, &fdset);
-    timeval timeout = {.tv_sec = 0, .tv_usec = 5000};
-    auto    success = select(ACCEPTEDCONNECTION + 1, &fdset, nullptr, nullptr, &timeout);
+    //
+    pollfd pollfds[1] = {
+        {
+            .fd     = ACCEPTEDCONNECTION,
+            .events = POLLIN,
+        },
+    };
+
+    int ret = poll(pollfds, 1, 5000);
 
-    if (success <= 0) {
+    if (ret <= 0) {
         close(ACCEPTEDCONNECTION);
         return 0;
     }

commit cd9d4eb40f262da7915706285684db50a5fb40e1
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Jun 18 21:52:55 2024 +0200

    compositor: bump nofile rlimits on launch
    
    ref #6584

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index b02d31af..68404df8 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -16,6 +16,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/resource.h>
 
 int handleCritSignal(int signo, void* data) {
     Debug::log(LOG, "Hyprland received signal {}", signo);
@@ -57,6 +58,46 @@ void handleUserSignal(int sig) {
     }
 }
 
+static void bumpNofile() {
+    unsigned long limit = 1024;
+
+    try {
+        std::ifstream f("/proc/sys/fs/nr_open");
+        if (!f.good())
+            limit = 1073741816;
+        else {
+            std::string content((std::istreambuf_iterator<char>(f)), (std::istreambuf_iterator<char>()));
+            f.close();
+
+            limit = std::stoll(content);
+        }
+
+    } catch (...) { limit = 1073741816; }
+
+    struct rlimit rlimit_;
+    if (!getrlimit(RLIMIT_NOFILE, &rlimit_))
+        Debug::log(LOG, "Old rlimit: soft -> {}, hard -> {}", rlimit_.rlim_cur, rlimit_.rlim_max);
+
+    if (rlimit_.rlim_max <= 1024)
+        rlimit_.rlim_max = limit;
+
+    unsigned long oldHardLimit = rlimit_.rlim_max;
+
+    rlimit_.rlim_max = limit;
+
+    if (setrlimit(RLIMIT_NOFILE, &rlimit_) < 0) {
+        Debug::log(LOG, "Failed bumping NOFILE limits higher, retrying with previous hard.");
+        rlimit_.rlim_max = oldHardLimit;
+        rlimit_.rlim_cur = std::clamp((unsigned long)limit, 1UL, (unsigned long)rlimit_.rlim_max);
+
+        if (setrlimit(RLIMIT_NOFILE, &rlimit_) < 0)
+            Debug::log(LOG, "Failed bumping NOFILE limits higher for the second time.");
+    }
+
+    if (!getrlimit(RLIMIT_NOFILE, &rlimit_))
+        Debug::log(LOG, "New rlimit: soft -> {}, hard -> {}", rlimit_.rlim_cur, rlimit_.rlim_max);
+}
+
 CCompositor::CCompositor() {
     m_iHyprlandPID = getpid();
 
@@ -118,6 +159,8 @@ CCompositor::CCompositor() {
     setRandomSplash();
 
     Debug::log(LOG, "\nCurrent splash: {}\n\n", m_szCurrentSplash);
+
+    bumpNofile();
 }
 
 CCompositor::~CCompositor() {

commit 63a931e762b023aaa2e103f3f8887751153f6b3e
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri Jun 21 19:25:34 2024 +0200

    renderer: shrink occlusion rect if blur is used
    
    if we are blurring, we cannot be sure whether the occluded region won't be included in the expanded damage. If it is, we'd get dark shimmers.
    
    fixes #6547

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index c3623f69..8074ee17 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -2503,9 +2503,14 @@ void CHyprRenderer::setOccludedForMainWorkspace(CRegion& region, PHLWORKSPACE pW
 }
 
 void CHyprRenderer::setOccludedForBackLayers(CRegion& region, PHLWORKSPACE pWorkspace) {
-    CRegion    rg;
+    CRegion     rg;
 
-    const auto PMONITOR = g_pCompositor->getMonitorFromID(pWorkspace->m_iMonitorID);
+    const auto  PMONITOR = g_pCompositor->getMonitorFromID(pWorkspace->m_iMonitorID);
+
+    static auto PBLUR       = CConfigValue<Hyprlang::INT>("decoration:blur:enabled");
+    static auto PBLURSIZE   = CConfigValue<Hyprlang::INT>("decoration:blur:size");
+    static auto PBLURPASSES = CConfigValue<Hyprlang::INT>("decoration:blur:passes");
+    const auto  BLURRADIUS  = *PBLUR ? (*PBLURPASSES > 10 ? pow(2, 15) : std::clamp(*PBLURSIZE, (int64_t)1, (int64_t)40) * pow(2, *PBLURPASSES)) : 0;
 
     for (auto& w : g_pCompositor->m_vWindows) {
         if (!w->m_bIsMapped || w->isHidden() || w->m_pWorkspace != pWorkspace)
@@ -2520,7 +2525,8 @@ void CHyprRenderer::setOccludedForBackLayers(CRegion& region, PHLWORKSPACE pWork
 
         CBox           box = {POS.x, POS.y, SIZE.x, SIZE.y};
 
-        box.scale(PMONITOR->scale);
+        box.scale(PMONITOR->scale).expand(-BLURRADIUS);
+
         g_pHyprOpenGL->m_RenderData.renderModif.applyToBox(box);
 
         rg.add(box);

commit 11897a420cb0d7aad5b937e3e2b1c3d5709ab937
Author: John Titor <50095635+JohnRTitor@users.noreply.github.com>
Date:   Sun Jun 23 12:43:17 2024 +0530

    dbus: import PATH XDG_DATA_DIRS variables into systemd and dbus session

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 68404df8..3cbd73bc 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -465,10 +465,10 @@ void CCompositor::cleanEnvironment() {
     if (m_sWLRSession) {
         const auto CMD =
 #ifdef USES_SYSTEMD
-            "systemctl --user unset-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME && hash "
+            "systemctl --user unset-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS && hash "
             "dbus-update-activation-environment 2>/dev/null && "
 #endif
-            "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME";
+            "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS";
         g_pKeybindManager->spawn(CMD);
     }
 }
@@ -718,10 +718,10 @@ void CCompositor::startCompositor() {
     if (m_sWLRSession /* Session-less Hyprland usually means a nest, don't update the env in that case */) {
         const auto CMD =
 #ifdef USES_SYSTEMD
-            "systemctl --user import-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME && hash "
+            "systemctl --user import-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS && hash "
             "dbus-update-activation-environment 2>/dev/null && "
 #endif
-            "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME";
+            "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS";
         g_pKeybindManager->spawn(CMD);
     }
 
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 3fcf6930..d77a5501 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -1218,10 +1218,10 @@ void CConfigManager::dispatchExecOnce() {
     if (g_pCompositor->m_sWLRSession)
         handleRawExec("",
 #ifdef USES_SYSTEMD
-                      "systemctl --user import-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME && hash "
+                      "systemctl --user import-environment DISPLAY WAYLAND_DISPLAY HYPRLAND_INSTANCE_SIGNATURE XDG_CURRENT_DESKTOP QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS && hash "
                       "dbus-update-activation-environment 2>/dev/null && "
 #endif
-                      "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME");
+                      "dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP HYPRLAND_INSTANCE_SIGNATURE QT_QPA_PLATFORMTHEME PATH XDG_DATA_DIRS");
 
     firstExecDispatched = true;
 

commit f31d7ebcd0acb59f1261032a8857692b40141d6d
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Jun 25 22:46:36 2024 +0200

    ime-relay: fix crash on nullptr surface focus

diff --git a/src/managers/input/InputMethodRelay.cpp b/src/managers/input/InputMethodRelay.cpp
index 17da87ea..763268ed 100644
--- a/src/managers/input/InputMethodRelay.cpp
+++ b/src/managers/input/InputMethodRelay.cpp
@@ -202,6 +202,9 @@ void CInputMethodRelay::onKeyboardFocus(wlr_surface* pSurface) {
         ti->leave();
     }
 
+    if (!pSurface)
+        return;
+
     for (auto& ti : m_vTextInputs) {
         if (!ti->isV3())
             continue;

commit 410c3bf332d2559799948726fed451be6f166ab8
Author: はれなよ <123649644+harenayo@users.noreply.github.com>
Date:   Sun Jun 30 03:04:48 2024 +0900

    session: fix activate events being always treated as on (#6696)
    
    * Fix listener_sessionActive to handle an event correctly when the session get inactivated
    
    * Remove log

diff --git a/src/events/Misc.cpp b/src/events/Misc.cpp
index 53bd6f9f..dc6b1c03 100644
--- a/src/events/Misc.cpp
+++ b/src/events/Misc.cpp
@@ -175,16 +175,27 @@ void Events::listener_RendererDestroy(wl_listener* listener, void* data) {
 }
 
 void Events::listener_sessionActive(wl_listener* listener, void* data) {
-    Debug::log(LOG, "Session got activated!");
+    if (g_pCompositor->m_sWLRSession->active) {
+        Debug::log(LOG, "Session got activated!");
 
-    g_pCompositor->m_bSessionActive = true;
+        g_pCompositor->m_bSessionActive = true;
 
-    for (auto& m : g_pCompositor->m_vMonitors) {
-        g_pCompositor->scheduleFrameForMonitor(m.get());
-        g_pHyprRenderer->applyMonitorRule(m.get(), &m->activeMonitorRule, true);
-    }
+        for (auto& m : g_pCompositor->m_vMonitors) {
+            g_pCompositor->scheduleFrameForMonitor(m.get());
+            g_pHyprRenderer->applyMonitorRule(m.get(), &m->activeMonitorRule, true);
+        }
+
+        g_pConfigManager->m_bWantsMonitorReload = true;
+    } else {
+        Debug::log(LOG, "Session got inactivated!");
 
-    g_pConfigManager->m_bWantsMonitorReload = true;
+        g_pCompositor->m_bSessionActive = false;
+
+        for (auto& m : g_pCompositor->m_vMonitors) {
+            m->noFrameSchedule = true;
+            m->framesToSkip    = 1;
+        }
+    }
 }
 
 void Events::listener_powerMgrSetMode(wl_listener* listener, void* data) {
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index c285f92c..3f673d78 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -738,18 +738,7 @@ bool CKeybindManager::handleVT(xkb_keysym_t keysym) {
 
         Debug::log(LOG, "Switching from VT {} to VT {}", ttynum, TTY);
 
-        if (!wlr_session_change_vt(g_pCompositor->m_sWLRSession, TTY))
-            return true; // probably same session
-
-        g_pCompositor->m_bSessionActive = false;
-
-        for (auto& m : g_pCompositor->m_vMonitors) {
-            m->noFrameSchedule = true;
-            m->framesToSkip    = 1;
-        }
-
-        Debug::log(LOG, "Switched to VT {}, destroyed all render data, frames to skip for each: 2", TTY);
-
+        wlr_session_change_vt(g_pCompositor->m_sWLRSession, TTY);
         return true;
     }
 

commit b3ba35ff47f64eec318d10f5961c4b13439c8a2b
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Jul 2 18:40:21 2024 +0200

    renderer: don't skip back background on preBlurQueued
    
    fixes #6332

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 8074ee17..ea0024b3 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -808,7 +808,7 @@ void CHyprRenderer::renderAllClientsForWorkspace(CMonitor* pMonitor, PHLWORKSPAC
     // TODO: check better with solitary after MR for tearing.
     const auto PFULLWINDOW = pWorkspace ? g_pCompositor->getFullscreenWindowOnWorkspace(pWorkspace->m_iID) : nullptr;
     if (!pWorkspace->m_bHasFullscreenWindow || pWorkspace->m_efFullscreenMode != FULLSCREEN_FULL || !PFULLWINDOW || PFULLWINDOW->m_vRealSize.isBeingAnimated() ||
-        !PFULLWINDOW->opaque() || pWorkspace->m_vRenderOffset.value() != Vector2D{}) {
+        !PFULLWINDOW->opaque() || pWorkspace->m_vRenderOffset.value() != Vector2D{} || g_pHyprOpenGL->preBlurQueued()) {
 
         if (!g_pHyprOpenGL->m_RenderData.pCurrentMonData->blurFBShouldRender)
             setOccludedForBackLayers(g_pHyprOpenGL->m_RenderData.damage, pWorkspace);

commit 0dbd87c3230e8b5d738fd40c442353cc1bbed865
Author: Lincoln Yuji de Oliveira <63720047+Lincoln-Yuji@users.noreply.github.com>
Date:   Thu Jul 4 08:21:07 2024 -0300

    Completions: use only awk (#6763)

diff --git a/hyprctl/hyprctl.usage b/hyprctl/hyprctl.usage
index a98541dd..04f75641 100644
--- a/hyprctl/hyprctl.usage
+++ b/hyprctl/hyprctl.usage
@@ -10,11 +10,11 @@ hyprctl [<OPTIONS>]... <ARGUMENTS>
             |   (--batch)                                             "Execute a batch of commands separated by ;"
             ;
 
-<WINDOWS> ::= {{{ hyprctl clients | grep class | awk '{print $2}' }}};
+<WINDOWS> ::= {{{ hyprctl clients | awk '/class/{print $2}' }}};
 
-<AVAILABLE_PLUGINS> ::= {{{ hyprpm list | grep "Plugin" | awk '{print $4}' }}};
+<AVAILABLE_PLUGINS> ::= {{{ hyprpm list | awk '/Plugin/{print $4}' }}};
 
-<MONITORS> ::= {{{ hyprctl monitors | grep Monitor | awk '{ print $2 }' }}};
+<MONITORS> ::= {{{ hyprctl monitors | awk '/Monitor/{ print $2 }' }}};
 
 <KEYBOARDS> ::= {{{ hyprctl devices | sed -n '/Keyboard at/{n; s/^\s\+//; p}' }}};
 
diff --git a/hyprpm/hyprpm.bash b/hyprpm/hyprpm.bash
index 6989f7c1..ffc33e19 100644
--- a/hyprpm/hyprpm.bash
+++ b/hyprpm/hyprpm.bash
@@ -1,5 +1,5 @@
 _hyprpm_cmd_0 () {
-    hyprpm list | grep Plugin | awk '{print $4}'
+    hyprpm list | awk '/Plugin/{print $4}'
 }
 
 _hyprpm () {
diff --git a/hyprpm/hyprpm.fish b/hyprpm/hyprpm.fish
index 81a1c59e..7be4f224 100644
--- a/hyprpm/hyprpm.fish
+++ b/hyprpm/hyprpm.fish
@@ -1,6 +1,6 @@
 function _hyprpm_1
     set 1 $argv[1]
-    hyprpm list | grep Plugin | awk '{print $4}'
+    hyprpm list | awk '/Plugin/{print $4}'
 end
 
 function _hyprpm
diff --git a/hyprpm/hyprpm.usage b/hyprpm/hyprpm.usage
index f321faf6..369c9d2b 100644
--- a/hyprpm/hyprpm.usage
+++ b/hyprpm/hyprpm.usage
@@ -16,4 +16,4 @@ hyprpm [<FLAGS>]... <ARGUMENT>
         |   (reload)                    "Reload all plugins"
         ;
 
-<PLUGINS> ::= {{{ hyprpm list | grep Plugin | awk '{print $4}' }}};
+<PLUGINS> ::= {{{ hyprpm list | awk '/Plugin/{print $4}' }}};
diff --git a/hyprpm/hyprpm.zsh b/hyprpm/hyprpm.zsh
index e355a1fa..854e8426 100644
--- a/hyprpm/hyprpm.zsh
+++ b/hyprpm/hyprpm.zsh
@@ -1,7 +1,7 @@
 #compdef hyprpm
 
 _hyprpm_cmd_0 () {
-    hyprpm list | grep Plugin | awk '{print $4}'
+    hyprpm list | awk '/Plugin/{print $4}'
 }
 
 _hyprpm () {

commit 7f194c5ed2828c9cb832c529612b02a111bf40b4
Author: MightyPlaza <123664421+MightyPlaza@users.noreply.github.com>
Date:   Fri Jul 5 20:46:38 2024 +0000

    keybinds: fix movewindow float to 0 (#6777)
    
    modified:   src/managers/KeybindManager.cpp

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 3f673d78..57a6f2cf 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -1279,20 +1279,21 @@ void CKeybindManager::moveActiveTo(std::string args) {
         return;
 
     if (PLASTWINDOW->m_bIsFloating) {
-        Vector2D   vPos;
-        const auto PMONITOR   = g_pCompositor->getMonitorFromID(PLASTWINDOW->m_iMonitorID);
-        const auto BORDERSIZE = PLASTWINDOW->getRealBorderSize();
+        std::optional<float> vPosx, vPosy;
+        const auto           PMONITOR   = g_pCompositor->getMonitorFromID(PLASTWINDOW->m_iMonitorID);
+        const auto           BORDERSIZE = PLASTWINDOW->getRealBorderSize();
 
         switch (arg) {
-            case 'l': vPos.x = PMONITOR->vecReservedTopLeft.x + BORDERSIZE + PMONITOR->vecPosition.x; break;
-            case 'r': vPos.x = PMONITOR->vecSize.x - PMONITOR->vecReservedBottomRight.x - PLASTWINDOW->m_vRealSize.goal().x - BORDERSIZE + PMONITOR->vecPosition.x; break;
+            case 'l': vPosx = PMONITOR->vecReservedTopLeft.x + BORDERSIZE + PMONITOR->vecPosition.x; break;
+            case 'r': vPosx = PMONITOR->vecSize.x - PMONITOR->vecReservedBottomRight.x - PLASTWINDOW->m_vRealSize.goal().x - BORDERSIZE + PMONITOR->vecPosition.x; break;
             case 't':
-            case 'u': vPos.y = PMONITOR->vecReservedTopLeft.y + BORDERSIZE + PMONITOR->vecPosition.y; break;
+            case 'u': vPosy = PMONITOR->vecReservedTopLeft.y + BORDERSIZE + PMONITOR->vecPosition.y; break;
             case 'b':
-            case 'd': vPos.y = PMONITOR->vecSize.y - PMONITOR->vecReservedBottomRight.y - PLASTWINDOW->m_vRealSize.goal().y - BORDERSIZE + PMONITOR->vecPosition.y; break;
+            case 'd': vPosy = PMONITOR->vecSize.y - PMONITOR->vecReservedBottomRight.y - PLASTWINDOW->m_vRealSize.goal().y - BORDERSIZE + PMONITOR->vecPosition.y; break;
         }
 
-        PLASTWINDOW->m_vRealPosition = Vector2D(vPos.x != 0 ? vPos.x : PLASTWINDOW->m_vRealPosition.goal().x, vPos.y != 0 ? vPos.y : PLASTWINDOW->m_vRealPosition.goal().y);
+        PLASTWINDOW->m_vRealPosition = Vector2D(vPosx.value_or(PLASTWINDOW->m_vRealPosition.goal().x), vPosy.value_or(PLASTWINDOW->m_vRealPosition.goal().y));
+
         return;
     }
 

commit 79aac05f1dee49647108e031623767786c9e5bf6
Author: Maximilian Seidler <maximilian.seidler@soundwork.at>
Date:   Fri Jul 5 22:58:47 2024 +0200

    config: don't crash when getenv HOME returns null

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index d77a5501..aad318c0 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -610,7 +610,12 @@ std::string CConfigManager::getConfigDir() {
     if (xdgConfigHome && std::filesystem::path(xdgConfigHome).is_absolute())
         return xdgConfigHome;
 
-    return getenv("HOME") + std::string("/.config");
+    static const char* home = getenv("HOME");
+
+    if (!home)
+        throw std::runtime_error("Neither HOME nor XDG_CONFIG_HOME is set in the environment. Cannot determine config directory.");
+
+    return home + std::string("/.config");
 }
 
 std::string CConfigManager::getMainConfigPath() {

commit e899ac81e16237917affe0609eabc97122915cfe
Author: Virt <41426325+VirtCode@users.noreply.github.com>
Date:   Sun Jul 7 21:27:18 2024 +0200

    workspaces: don't try to reopen special workspaces (#6802)

diff --git a/src/helpers/Monitor.cpp b/src/helpers/Monitor.cpp
index ceb021c8..77348214 100644
--- a/src/helpers/Monitor.cpp
+++ b/src/helpers/Monitor.cpp
@@ -616,6 +616,9 @@ void CMonitor::changeWorkspace(const int& id, bool internal, bool noMouseMove, b
 }
 
 void CMonitor::setSpecialWorkspace(const PHLWORKSPACE& pWorkspace) {
+    if (activeSpecialWorkspace == pWorkspace)
+        return;
+
     g_pHyprRenderer->damageMonitor(this);
 
     if (!pWorkspace) {

commit 45d524cfab91cba7a6eb2d0c8aca4a264068362a
Author: Khiet Tam Nguyen <86177399+nktnet1@users.noreply.github.com>
Date:   Sun Jul 14 04:44:32 2024 +1000

    window: override noMaximize if new window takes over fullscreen (#6812) (#6870)

diff --git a/src/events/Windows.cpp b/src/events/Windows.cpp
index e414000e..12f2020a 100644
--- a/src/events/Windows.cpp
+++ b/src/events/Windows.cpp
@@ -491,9 +491,11 @@ void Events::listener_mapWindow(void* owner, void* data) {
             PWINDOW->m_bNoInitialFocus = true;
         else if (*PNEWTAKESOVERFS == 2)
             g_pCompositor->setWindowFullscreen(g_pCompositor->getFullscreenWindowOnWorkspace(PWINDOW->m_pWorkspace->m_iID), false, FULLSCREEN_INVALID);
-        else if (PWINDOW->m_pWorkspace->m_efFullscreenMode == FULLSCREEN_MAXIMIZED)
+        else if (PWINDOW->m_pWorkspace->m_efFullscreenMode == FULLSCREEN_MAXIMIZED) {
             requestsMaximize = true;
-        else
+            if (*PNEWTAKESOVERFS == 1)
+                overridingNoMaximize = true;
+        } else
             requestsFullscreen = true;
     }
 

commit 869f4486748bed3317972447355b13aa626b0c9e
Author: Party Wumpus <48649272+PartyWumpus@users.noreply.github.com>
Date:   Tue Jul 16 21:03:10 2024 +0100

    renderer: Make shader time always count from zero (#6903)
    
    * testing out an initialtime variable
    
    * Make time universally start at zero instead of exposing an initial time
    
    * Appease the CI

diff --git a/src/render/OpenGL.cpp b/src/render/OpenGL.cpp
index c4884245..bd3008b4 100644
--- a/src/render/OpenGL.cpp
+++ b/src/render/OpenGL.cpp
@@ -603,9 +603,11 @@ void CHyprOpenGLImpl::applyScreenShader(const std::string& path) {
         return;
     }
 
-    m_sFinalScreenShader.proj      = glGetUniformLocation(m_sFinalScreenShader.program, "proj");
-    m_sFinalScreenShader.tex       = glGetUniformLocation(m_sFinalScreenShader.program, "tex");
-    m_sFinalScreenShader.time      = glGetUniformLocation(m_sFinalScreenShader.program, "time");
+    m_sFinalScreenShader.proj = glGetUniformLocation(m_sFinalScreenShader.program, "proj");
+    m_sFinalScreenShader.tex  = glGetUniformLocation(m_sFinalScreenShader.program, "tex");
+    m_sFinalScreenShader.time = glGetUniformLocation(m_sFinalScreenShader.program, "time");
+    if (m_sFinalScreenShader.time != -1)
+        m_sFinalScreenShader.initialTime = m_tGlobalTimer.getSeconds();
     m_sFinalScreenShader.wl_output = glGetUniformLocation(m_sFinalScreenShader.program, "wl_output");
     m_sFinalScreenShader.fullSize  = glGetUniformLocation(m_sFinalScreenShader.program, "screen_size");
     if (m_sFinalScreenShader.fullSize == -1)
@@ -898,7 +900,7 @@ void CHyprOpenGLImpl::renderTextureInternalWithDamage(const CTexture& tex, CBox*
     glUniform1i(shader->tex, 0);
 
     if ((usingFinalShader && *PDT == 0) || CRASHING) {
-        glUniform1f(shader->time, m_tGlobalTimer.getSeconds());
+        glUniform1f(shader->time, m_tGlobalTimer.getSeconds() - shader->initialTime);
     } else if (usingFinalShader && shader->time != -1) {
         // Don't let time be unitialised
         glUniform1f(shader->time, 0.f);
diff --git a/src/render/Shader.hpp b/src/render/Shader.hpp
index 185c3dff..d5a312c3 100644
--- a/src/render/Shader.hpp
+++ b/src/render/Shader.hpp
@@ -42,9 +42,10 @@ class CShader {
     GLint   gradientLength = -1;
     GLint   angle          = -1;
 
-    GLint   time      = -1;
-    GLint   distort   = -1;
-    GLint   wl_output = -1;
+    float   initialTime = 0;
+    GLint   time        = -1;
+    GLint   distort     = -1;
+    GLint   wl_output   = -1;
 
     // Blur prepare
     GLint contrast = -1;
@@ -64,4 +65,4 @@ class CShader {
 
   private:
     std::unordered_map<std::string, GLint> m_muUniforms;
-};
\ No newline at end of file
+};

commit d6142069e7a45cf0f7e20efc964727c0a878c46e
Author: Ferdinand Bachmann <ferdinand.bachmann@yrlf.at>
Date:   Sat Jul 20 00:37:20 2024 +0200

    compositor: implement wayland socket handover (#6930)
    
    * compositor: implement wayland socket handover
    
    This commit implements the compositor side of the Wayland socket
    handover protocol as described in the [KDE Wiki]. The CLI options are
    chosen so that they are compatible with Kwin.
    
    [KDE Wiki]: https://invent.kde.org/plasma/kwin/-/wikis/Restarting
    
    * main: verify that --wayland-fd is a valid file descriptor
    
    * main: fail if only one of --socket and --wayland-fd is passed

diff --git a/docs/Hyprland.1 b/docs/Hyprland.1
index f43d2c5d..5ef24fd5 100644
--- a/docs/Hyprland.1
+++ b/docs/Hyprland.1
@@ -32,6 +32,10 @@ Show command usage.
 .TP
 \f[B]-c\f[R], \f[B]--config\f[R]
 Specify config file to use.
+\f[B]--socket\f[R]
+Sets the Wayland socket name (for Wayland socket handover)
+\f[B]--wayland-fd\f[R]
+Sets the Wayland socket file descriptor (for Wayland socket handover)
 .SH BUGS
 .TP
 Submit bug reports and request features online at:
diff --git a/docs/Hyprland.1.rst b/docs/Hyprland.1.rst
index 54126501..c73b4343 100644
--- a/docs/Hyprland.1.rst
+++ b/docs/Hyprland.1.rst
@@ -41,6 +41,12 @@ OPTIONS
 **-c**, **--config**
     Specify config file to use.
 
+**--socket**
+    Sets the Wayland socket name (for Wayland socket handover)
+
+**--wayland-fd**
+    Sets the Wayland socket file descriptor (for Wayland socket handover)
+
 BUGS
 ====
 
diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 3cbd73bc..81627eb4 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -14,6 +14,7 @@
 #include <ranges>
 #include "helpers/VarList.hpp"
 
+#include <fcntl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/resource.h>
@@ -682,19 +683,28 @@ void CCompositor::prepareFallbackOutput() {
     wlr_headless_add_output(headless, 1920, 1080);
 }
 
-void CCompositor::startCompositor() {
+void CCompositor::startCompositor(std::string socketName, int socketFd) {
     initAllSignals();
 
-    // get socket, avoid using 0
-    for (int candidate = 1; candidate <= 32; candidate++) {
-        const auto CANDIDATESTR = ("wayland-" + std::to_string(candidate));
-        const auto RETVAL       = wl_display_add_socket(m_sWLDisplay, CANDIDATESTR.c_str());
+    if (!socketName.empty() && socketFd != -1) {
+        fcntl(socketFd, F_SETFD, FD_CLOEXEC);
+        const auto RETVAL = wl_display_add_socket_fd(m_sWLDisplay, socketFd);
         if (RETVAL >= 0) {
-            m_szWLDisplaySocket = CANDIDATESTR;
-            Debug::log(LOG, "wl_display_add_socket for {} succeeded with {}", CANDIDATESTR, RETVAL);
-            break;
-        } else {
-            Debug::log(WARN, "wl_display_add_socket for {} returned {}: skipping candidate {}", CANDIDATESTR, RETVAL, candidate);
+            m_szWLDisplaySocket = socketName;
+            Debug::log(LOG, "wl_display_add_socket_fd for {} succeeded with {}", socketName, RETVAL);
+        } else
+            Debug::log(WARN, "wl_display_add_socket_fd for {} returned {}: skipping", socketName, RETVAL);
+    } else {
+        // get socket, avoid using 0
+        for (int candidate = 1; candidate <= 32; candidate++) {
+            const auto CANDIDATESTR = ("wayland-" + std::to_string(candidate));
+            const auto RETVAL       = wl_display_add_socket(m_sWLDisplay, CANDIDATESTR.c_str());
+            if (RETVAL >= 0) {
+                m_szWLDisplaySocket = CANDIDATESTR;
+                Debug::log(LOG, "wl_display_add_socket for {} succeeded with {}", CANDIDATESTR, RETVAL);
+                break;
+            } else
+                Debug::log(WARN, "wl_display_add_socket for {} returned {}: skipping candidate {}", CANDIDATESTR, RETVAL, candidate);
         }
     }
 
diff --git a/src/Compositor.hpp b/src/Compositor.hpp
index 60c575d5..14733944 100644
--- a/src/Compositor.hpp
+++ b/src/Compositor.hpp
@@ -101,7 +101,7 @@ class CCompositor {
     std::unordered_map<std::string, uint64_t> m_mMonitorIDMap;
 
     void                                      initServer();
-    void                                      startCompositor();
+    void                                      startCompositor(std::string socketName, int socketFd);
     void                                      cleanup();
     void                                      createLockFile();
     void                                      removeLockFile();
diff --git a/src/main.cpp b/src/main.cpp
index 7e6fee02..1ac3ab8b 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -4,6 +4,7 @@
 #include "config/ConfigManager.hpp"
 #include "init/initHelpers.hpp"
 
+#include <fcntl.h>
 #include <iostream>
 #include <iterator>
 #include <vector>
@@ -16,6 +17,8 @@ void help() {
     std::cout << "\nArguments:\n";
     std::cout << "  --help              -h       - Show this message again\n";
     std::cout << "  --config FILE       -c FILE  - Specify config file to use\n";
+    std::cout << "  --socket NAME                - Sets the Wayland socket name (for Wayland socket handover)\n";
+    std::cout << "  --wayland-fd FD              - Sets the Wayland socket fd (for Wayland socket handover)\n";
     std::cout << "  --i-am-really-stupid         - Omits root user privileges check (why would you do that?)\n";
 }
 
@@ -37,6 +40,8 @@ int main(int argc, char** argv) {
 
     // parse some args
     std::string              configPath;
+    std::string              socketName;
+    int                      socketFd   = -1;
     bool                     ignoreSudo = false;
 
     std::vector<std::string> args{argv + 1, argv + argc};
@@ -46,6 +51,36 @@ int main(int argc, char** argv) {
             std::cout << "[ WARNING ] Running Hyprland with superuser privileges might damage your system\n";
 
             ignoreSudo = true;
+        } else if (it->compare("--socket") == 0) {
+            if (std::next(it) == args.end()) {
+                help();
+
+                return 1;
+            }
+
+            socketName = *std::next(it);
+            it++;
+        } else if (it->compare("--wayland-fd") == 0) {
+            if (std::next(it) == args.end()) {
+                help();
+
+                return 1;
+            }
+
+            try {
+                socketFd = std::stoi(std::next(it)->c_str());
+
+                // check if socketFd is a valid file descriptor
+                if (fcntl(socketFd, F_GETFD) == -1)
+                    throw std::exception();
+            } catch (...) {
+                std::cerr << "[ ERROR ] Invalid Wayland FD!\n";
+                help();
+
+                return 1;
+            }
+
+            it++;
         } else if (it->compare("-c") == 0 || it->compare("--config") == 0) {
             if (std::next(it) == args.end()) {
                 help();
@@ -93,6 +128,13 @@ int main(int argc, char** argv) {
         std::cout << "Superuser privileges check is omitted. I hope you know what you're doing.\n";
     }
 
+    if (socketName.empty() ^ (socketFd == -1)) {
+        std::cerr << "[ ERROR ] Hyprland was launched with only one of --socket and --wayland-fd.\n";
+        std::cerr << "          Hint: Pass both --socket and --wayland-fd to perform Wayland socket handover.\n";
+
+        return 1;
+    }
+
     std::cout << "Welcome to Hyprland!\n";
 
     // let's init the compositor.
@@ -113,7 +155,7 @@ int main(int argc, char** argv) {
     Debug::log(LOG, "Hyprland init finished.");
 
     // If all's good to go, start.
-    g_pCompositor->startCompositor();
+    g_pCompositor->startCompositor(socketName, socketFd);
 
     g_pCompositor->m_bIsShuttingDown = true;
 

commit 8de40f5daa9a6ae13b99671ca6a951dbe28e3106
Author: khachbe <woody.hojeily@gmail.com>
Date:   Sun Jul 21 13:59:09 2024 +0200

    touch: add touch swipe invert config (#6940)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index aad318c0..2ab3828b 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -507,6 +507,7 @@ CConfigManager::CConfigManager() {
     m_pConfig->addConfigValue("gestures:workspace_swipe_forever", Hyprlang::INT{0});
     m_pConfig->addConfigValue("gestures:workspace_swipe_use_r", Hyprlang::INT{0});
     m_pConfig->addConfigValue("gestures:workspace_swipe_touch", Hyprlang::INT{0});
+    m_pConfig->addConfigValue("gestures:workspace_swipe_touch_invert", Hyprlang::INT{0});
 
     m_pConfig->addConfigValue("xwayland:use_nearest_neighbor", Hyprlang::INT{1});
     m_pConfig->addConfigValue("xwayland:force_zero_scaling", Hyprlang::INT{0});
diff --git a/src/managers/input/Touch.cpp b/src/managers/input/Touch.cpp
index de369340..b3a951d0 100644
--- a/src/managers/input/Touch.cpp
+++ b/src/managers/input/Touch.cpp
@@ -107,7 +107,7 @@ void CInputManager::onTouchMove(wlr_touch_motion_event* e) {
             return;
         const bool VERTANIMS = m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle == "slidevert" ||
             m_sActiveSwipe.pWorkspaceBegin->m_vRenderOffset.getConfig()->pValues->internalStyle.starts_with("slidefadevert");
-        static auto PSWIPEINVR    = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_invert");
+        static auto PSWIPEINVR    = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_touch_invert");
         static auto PSWIPEDIST    = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_distance");
         const auto  SWIPEDISTANCE = std::clamp(*PSWIPEDIST, (int64_t)1LL, (int64_t)UINT32_MAX);
         // Handle the workspace swipe if there is one

commit 6b67ea1ca891f04d2557ef46acbfa5884b285923
Author: Vaxry <vaxry@vaxry.net>
Date:   Sun Jul 21 16:42:43 2024 +0200

    hyprpm: init submodules after resets
    
    ref #6948

diff --git a/hyprpm/src/core/PluginManager.cpp b/hyprpm/src/core/PluginManager.cpp
index 7a99662b..c3583970 100644
--- a/hyprpm/src/core/PluginManager.cpp
+++ b/hyprpm/src/core/PluginManager.cpp
@@ -187,6 +187,9 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
             std::cerr << "\n" << Colors::RED << "✖" << Colors::RESET << " Could not check out revision " << rev << ". shell returned:\n" << ret << "\n";
             return false;
         }
+        ret = execAndGet("git -C " + m_szWorkingPluginDirectory + " submodule update --init");
+        if (m_bVerbose)
+            std::cout << Colors::BLUE << "[v] " << Colors::RESET << "git submodule update --init returned: " << ret << "\n";
     }
 
     progress.m_iSteps = 1;
@@ -241,6 +244,12 @@ bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string&
             progress.printMessageAbove(std::string{Colors::GREEN} + "✔" + Colors::RESET + " commit pin " + plugin + " matched hl, resetting");
 
             execAndGet("cd " + m_szWorkingPluginDirectory + " && git reset --hard --recurse-submodules " + plugin);
+
+            ret = execAndGet("git -C " + m_szWorkingPluginDirectory + " submodule update --init");
+            if (m_bVerbose)
+                std::cout << Colors::BLUE << "[v] " << Colors::RESET << "git submodule update --init returned: " << ret << "\n";
+
+            break;
         }
     }
 

commit c01654b91c33ce6cf70e51ec51dd39217ee53949
Author: Leon <99900077+leon-erd@users.noreply.github.com>
Date:   Wed Jul 24 10:59:50 2024 +0200

    touch: fix touch swipe invert config (#7014)

diff --git a/src/managers/input/Touch.cpp b/src/managers/input/Touch.cpp
index b3a951d0..5d182f2b 100644
--- a/src/managers/input/Touch.cpp
+++ b/src/managers/input/Touch.cpp
@@ -9,7 +9,7 @@ void CInputManager::onTouchDown(wlr_touch_down_event* e) {
     // TODO: WORKSPACERULE.gapsOut.value_or()
     auto        gapsOut     = *PGAPSOUT;
     static auto PBORDERSIZE = CConfigValue<Hyprlang::INT>("general:border_size");
-    static auto PSWIPEINVR  = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_invert");
+    static auto PSWIPEINVR  = CConfigValue<Hyprlang::INT>("gestures:workspace_swipe_touch_invert");
     EMIT_HOOK_EVENT_CANCELLABLE("touchDown", e);
 
     auto       PMONITOR = g_pCompositor->getMonitorFromName(e->touch->output_name ? e->touch->output_name : "");

commit 5f7929bdcdfaa3ef21f8f9999142c6a4b89377dd
Author: MightyPlaza <123664421+MightyPlaza@users.noreply.github.com>
Date:   Wed Jul 24 17:05:54 2024 +0000

    crashreporter: add date and flags to crash report (#7028)
    
    modified:   src/debug/CrashReporter.cpp

diff --git a/src/debug/CrashReporter.cpp b/src/debug/CrashReporter.cpp
index ce1a92ba..85377b4c 100644
--- a/src/debug/CrashReporter.cpp
+++ b/src/debug/CrashReporter.cpp
@@ -104,7 +104,19 @@ void CrashReporter::createAndSaveCrash(int sig) {
     finalCrashReport += GIT_COMMIT_HASH;
     finalCrashReport += "\nTag: ";
     finalCrashReport += GIT_TAG;
-    finalCrashReport += "\n\n";
+    finalCrashReport += "\nDate: ";
+    finalCrashReport += GIT_COMMIT_DATE;
+    finalCrashReport += "\nFlags:\n";
+#ifdef LEGACY_RENDERER
+    finalCrashReport += "legacyrenderer\n";
+#endif
+#ifndef ISDEBUG
+    finalCrashReport += "debug\n";
+#endif
+#ifdef NO_XWAYLAND
+    finalCrashReport += "no xwayland\n";
+#endif
+    finalCrashReport += "\n";
 
     if (g_pPluginSystem && g_pPluginSystem->pluginCount() > 0) {
         finalCrashReport += "Hyprland seems to be running with plugins. This crash might not be Hyprland's fault.\nPlugins:\n";

commit 7e4ed0a8f3d6ac6a4ba09ae209ff0a21f0446327
Author: MightyPlaza <123664421+MightyPlaza@users.noreply.github.com>
Date:   Wed Jul 24 18:00:25 2024 +0000

    keybinds: handle monitor change in moveWindowIntoGroup (#7030)
    
    modified:   src/managers/KeybindManager.cpp

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index 57a6f2cf..f9c2a15c 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -2223,6 +2223,11 @@ void CKeybindManager::moveWindowIntoGroup(CWindow* pWindow, CWindow* pWindowInDi
 
     g_pLayoutManager->getCurrentLayout()->onWindowRemoved(pWindow); // This removes groupped property!
 
+    if (pWindow->m_iMonitorID != pWindowInDirection->m_iMonitorID) {
+        pWindow->moveToWorkspace(pWindowInDirection->m_pWorkspace);
+        pWindow->m_iMonitorID = pWindowInDirection->m_iMonitorID;
+    }
+
     static auto USECURRPOS = CConfigValue<Hyprlang::INT>("group:insert_after_current");
     pWindowInDirection     = *USECURRPOS ? pWindowInDirection : pWindowInDirection->getGroupTail();
 

commit 7960c072235207d77e38a7afc866fe5f81ffcbc0
Author: MightyPlaza <123664421+MightyPlaza@users.noreply.github.com>
Date:   Wed Jul 24 22:19:15 2024 +0000

    keybinds: add safeguard to mousebinds (#7034)
    
    modified:   src/managers/KeybindManager.cpp

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index f9c2a15c..fa7843c6 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -2100,7 +2100,7 @@ void CKeybindManager::mouse(std::string args) {
     const auto PRESSED = args[0] == '1';
 
     if (ARGS[0] == "movewindow") {
-        if (PRESSED) {
+        if (PRESSED && g_pInputManager->dragMode == MBIND_INVALID) {
             g_pKeybindManager->m_bIsMouseBindActive = true;
 
             const auto mouseCoords = g_pInputManager->getMouseCoordsInternal();
@@ -2114,7 +2114,7 @@ void CKeybindManager::mouse(std::string args) {
 
             g_pInputManager->dragMode = MBIND_MOVE;
             g_pLayoutManager->getCurrentLayout()->onBeginDragWindow();
-        } else {
+        } else if (!PRESSED && g_pInputManager->dragMode == MBIND_MOVE) {
             g_pKeybindManager->m_bIsMouseBindActive = false;
 
             if (g_pInputManager->currentlyDraggedWindow) {
@@ -2124,7 +2124,7 @@ void CKeybindManager::mouse(std::string args) {
             }
         }
     } else if (ARGS[0] == "resizewindow") {
-        if (PRESSED) {
+        if (PRESSED && g_pInputManager->dragMode == MBIND_INVALID) {
             g_pKeybindManager->m_bIsMouseBindActive = true;
 
             g_pInputManager->currentlyDraggedWindow =
@@ -2138,7 +2138,8 @@ void CKeybindManager::mouse(std::string args) {
                 }
             } catch (std::exception& e) { g_pInputManager->dragMode = MBIND_RESIZE; }
             g_pLayoutManager->getCurrentLayout()->onBeginDragWindow();
-        } else {
+        } else if (!PRESSED &&
+                   (g_pInputManager->dragMode == MBIND_RESIZE_FORCE_RATIO || g_pInputManager->dragMode == MBIND_RESIZE_BLOCK_RATIO || g_pInputManager->dragMode == MBIND_RESIZE)) {
             g_pKeybindManager->m_bIsMouseBindActive = false;
 
             if (g_pInputManager->currentlyDraggedWindow) {

commit 8df8a2cf96d757329e6a2ef85ab16b6488570f01
Author: vaxerski <vaxry@vaxry.net>
Date:   Sat Jul 27 18:13:41 2024 +0200

    renderer: use session lock alpha for rendering lacking locks

diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index ea0024b3..06d368b8 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -761,8 +761,9 @@ void CHyprRenderer::renderAllClientsForWorkspace(CMonitor* pMonitor, PHLWORKSPAC
 
     if (!g_pCompositor->m_sSeat.exclusiveClient && g_pSessionLockManager->isSessionLocked()) {
         // locked with no exclusive, draw only red
-        CBox boxe = {0, 0, INT16_MAX, INT16_MAX};
-        g_pHyprOpenGL->renderRect(&boxe, CColor(1.0, 0.2, 0.2, 1.0));
+        CBox        boxe = {0, 0, INT16_MAX, INT16_MAX};
+        const float A    = g_pSessionLockManager->getRedScreenAlphaForMonitor(pMonitor->ID);
+        g_pHyprOpenGL->renderRect(&boxe, CColor(1.0, 0.2, 0.2, A));
         return;
     }
 

commit dfe6bf4ac7a96e04fc5f4dd2be681e4061069fb1
Author: atikiNBTW <74009330+atikiNBTW@users.noreply.github.com>
Date:   Mon Jul 29 19:56:50 2024 +0500

    pluginapi: Add force reload of config at the end of plugin initialization (#7099)
    
    * Add force reload of config at the end of plugin load
    
    * Remove unnecessary include

diff --git a/src/plugins/PluginSystem.cpp b/src/plugins/PluginSystem.cpp
index d25d8c7b..a8d761c9 100644
--- a/src/plugins/PluginSystem.cpp
+++ b/src/plugins/PluginSystem.cpp
@@ -80,6 +80,8 @@ CPlugin* CPluginSystem::loadPlugin(const std::string& path) {
     PLUGIN->version     = PLUGINDATA.version;
     PLUGIN->name        = PLUGINDATA.name;
 
+    g_pConfigManager->m_bForceReload = true;
+
     Debug::log(LOG, " [PluginSystem] Plugin {} loaded. Handle: {:x}, path: \"{}\", author: \"{}\", description: \"{}\", version: \"{}\"", PLUGINDATA.name, (uintptr_t)MODULE, path,
                PLUGINDATA.author, PLUGINDATA.description, PLUGINDATA.version);
 

commit c46b3411a2b84592241394a92be1714e73d7edaf
Author: André Silva <123550+andresilva@users.noreply.github.com>
Date:   Wed Jul 31 16:54:07 2024 +0100

    keybinds: handle null monitor in pinActive (#7122)

diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index fa7843c6..1358a798 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -2081,8 +2081,16 @@ void CKeybindManager::pinActive(std::string args) {
     if (!PWINDOW->m_bIsFloating || PWINDOW->m_bIsFullscreen)
         return;
 
-    PWINDOW->m_bPinned    = !PWINDOW->m_bPinned;
-    PWINDOW->m_pWorkspace = g_pCompositor->getMonitorFromID(PWINDOW->m_iMonitorID)->activeWorkspace;
+    PWINDOW->m_bPinned = !PWINDOW->m_bPinned;
+
+    const auto PMONITOR = g_pCompositor->getMonitorFromID(PWINDOW->m_iMonitorID);
+
+    if (!PMONITOR) {
+        Debug::log(ERR, "pin: monitor not found");
+        return;
+    }
+
+    PWINDOW->m_pWorkspace = PMONITOR->activeWorkspace;
 
     PWINDOW->updateDynamicRules();
     g_pCompositor->updateWindowAnimatedDecorationValues(PWINDOW);

commit 54539e95f2b46743258aeebbc58afda643ab2af0
Author: Vaxry <vaxry@vaxry.net>
Date:   Tue Aug 6 16:57:15 2024 +0200

    renderer: fixup crashes on inaccessible files for bg

diff --git a/src/render/OpenGL.cpp b/src/render/OpenGL.cpp
index bd3008b4..5776b005 100644
--- a/src/render/OpenGL.cpp
+++ b/src/render/OpenGL.cpp
@@ -2092,12 +2092,10 @@ void CHyprOpenGLImpl::createBGTextureForMonitor(CMonitor* pMonitor) {
         texPath += ".png";
 
         // check if wallpapers exist
-        if (!std::filesystem::exists(texPath)) {
-            // try local
-            texPath = texPath.substr(0, 5) + "local/" + texPath.substr(5);
-
-            if (!std::filesystem::exists(texPath))
-                return; // the texture will be empty, oh well. We'll clear with a solid color anyways.
+        std::error_code err;
+        if (!std::filesystem::exists(texPath, err)) {
+            Debug::log(ERR, "createBGTextureForMonitor: failed, file doesn't exist or access denied, ec: {}", err.message());
+            return; // the texture will be empty, oh well. We'll clear with a solid color anyways.
         }
     }
 

commit 4c1caa3a49867dc1ef49d0bb96b9ff28bbae0e10
Author: Sami Liedes <sami.liedes@iki.fi>
Date:   Sun Aug 18 10:14:42 2024 +0300

    input: Fix disabling tap-to-click (#7304)
    
    * Allow disabling tap-to-click
    
    * Style fix

diff --git a/src/managers/input/InputManager.cpp b/src/managers/input/InputManager.cpp
index 9487d108..917f9d15 100644
--- a/src/managers/input/InputManager.cpp
+++ b/src/managers/input/InputManager.cpp
@@ -1057,8 +1057,9 @@ void CInputManager::setPointerConfigs() {
                 libinput_device_config_tap_set_drag_lock_enabled(LIBINPUTDEV, LIBINPUT_CONFIG_DRAG_LOCK_ENABLED);
 
             if (libinput_device_config_tap_get_finger_count(LIBINPUTDEV)) // this is for tapping (like on a laptop)
-                if (g_pConfigManager->getDeviceInt(devname, "tap-to-click", "input:touchpad:tap-to-click") == 1)
-                    libinput_device_config_tap_set_enabled(LIBINPUTDEV, LIBINPUT_CONFIG_TAP_ENABLED);
+                libinput_device_config_tap_set_enabled(LIBINPUTDEV,
+                                                       g_pConfigManager->getDeviceInt(devname, "tap-to-click", "input:touchpad:tap-to-click") == 1 ? LIBINPUT_CONFIG_TAP_ENABLED :
+                                                                                                                                                     LIBINPUT_CONFIG_TAP_DISABLED);
 
             if (libinput_device_config_scroll_has_natural_scroll(LIBINPUTDEV)) {
 

commit d8a71173ae6e04629bb6c882cb3d40697d64b297
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Sun Aug 18 21:02:46 2024 +0200

    compositor: update suspendstate on window move (#7396)
    
    hyprctl dispatch -- movetoworkspacesilent x,"^kitty$" where X is the
    current workspace makes kitty stops updating until current workspace is
    changed while it is on the screen. update the suspend state after it has
    been moved.

diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 81627eb4..cdc63ac4 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -2866,6 +2866,7 @@ void CCompositor::moveWindowToWorkspaceSafe(CWindow* pWindow, PHLWORKSPACE pWork
 
     g_pCompositor->updateWorkspaceWindows(pWorkspace->m_iID);
     g_pCompositor->updateWorkspaceWindows(pWindow->workspaceID());
+    g_pCompositor->updateSuspendedStates();
 }
 
 CWindow* CCompositor::getForceFocus() {

commit e27c31ea50ab206ae59ccfcba58046f1842cfead
Author: vaxerski <vaxry@vaxry.net>
Date:   Mon Aug 19 18:36:06 2024 +0200

    monitors: avoid crash on wayland output removal

diff --git a/src/events/Monitors.cpp b/src/events/Monitors.cpp
index a6fd5a4a..c50f8342 100644
--- a/src/events/Monitors.cpp
+++ b/src/events/Monitors.cpp
@@ -204,7 +204,7 @@ void Events::listener_monitorDestroy(void* owner, void* data) {
     if (!pMonitor)
         return;
 
-    Debug::log(LOG, "Destroy called for monitor {}", pMonitor->output->name);
+    Debug::log(LOG, "Destroy called for monitor {}", pMonitor->szName);
 
     pMonitor->onDisconnect(true);
 

commit 0ad0d2a9dad7ab5737aa53aaf70b71ed129895d7
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Tue Aug 27 20:42:30 2024 +0200

    hyprctl: avoid parsing string::npos on invalid cmd (#7544)
    
    * hyprctl: avoid parsing string::npos on invalid cmd
    
    invalid lines passed to hyprctl keyword made the string parsing try to
    parse std::string::npos, avoid that and return an error text instead.
    
    * style
    
    ---------
    
    Co-authored-by: Vaxry <vaxry@vaxry.net>

diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index e09bb445..e7cd842f 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -915,12 +915,26 @@ std::string dispatchRequest(eHyprCtlOutputFormat format, std::string in) {
 }
 
 std::string dispatchKeyword(eHyprCtlOutputFormat format, std::string in) {
-    // get rid of the keyword keyword
-    in = in.substr(in.find_first_of(' ') + 1);
-
-    const auto  COMMAND = in.substr(0, in.find_first_of(' '));
-
-    const auto  VALUE = in.substr(in.find_first_of(' ') + 1);
+    // Find the first space to strip the keyword keyword
+    auto const firstSpacePos = in.find_first_of(' ');
+    if (firstSpacePos == std::string::npos) // Handle the case where there's no space found (invalid input)
+        return "Invalid input: no space found";
+
+    // Strip the keyword
+    in = in.substr(firstSpacePos + 1);
+
+    // Find the next space for the COMMAND and VALUE
+    auto const secondSpacePos = in.find_first_of(' ');
+    if (secondSpacePos == std::string::npos) // Handle the case where there's no second space (invalid input)
+        return "Invalid input: command and value not properly formatted";
+
+    // Extract COMMAND and VALUE
+    const auto COMMAND = in.substr(0, secondSpacePos);
+    const auto VALUE   = in.substr(secondSpacePos + 1);
+
+    // If either COMMAND or VALUE is empty, handle accordingly
+    if (COMMAND.empty() || VALUE.empty())
+        return "Invalid input: command or value is empty";
 
     std::string retval = g_pConfigManager->parseKeyword(COMMAND, VALUE);
 

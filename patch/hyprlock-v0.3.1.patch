commit 481a1f41fd74fb57f7ea81bec55e00fda64b9b06
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Tue Apr 9 12:14:04 2024 +0200

    core: avoid double unlocks with no_fade_out (#257)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index c029ddb..4dccce1 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -358,8 +358,10 @@ void CHyprlock::run() {
 
     g_pRenderer = std::make_unique<CRenderer>();
 
-    const auto CURRENTDESKTOP = getenv("XDG_CURRENT_DESKTOP");
-    const auto SZCURRENTD     = std::string{CURRENTDESKTOP ? CURRENTDESKTOP : ""};
+    const auto         CURRENTDESKTOP = getenv("XDG_CURRENT_DESKTOP");
+    const auto         SZCURRENTD     = std::string{CURRENTDESKTOP ? CURRENTDESKTOP : ""};
+    static auto* const PNOFADEOUT     = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
+    const bool         NOFADEOUT      = **PNOFADEOUT;
 
     Debug::log(LOG, "Running on {}", SZCURRENTD);
 
@@ -452,15 +454,19 @@ void CHyprlock::run() {
 
     m_sLoopState.event = true; // let it process once
 
-    while (1) {
+    while (!m_bTerminate) {
         std::unique_lock lk(m_sLoopState.eventRequestMutex);
         if (m_sLoopState.event == false)
             m_sLoopState.loopCV.wait_for(lk, std::chrono::milliseconds(5000), [this] { return m_sLoopState.event; });
 
-        if (m_bTerminate || (std::chrono::system_clock::now() > m_tFadeEnds && m_bFadeStarted)) {
+        if (!NOFADEOUT && m_bFadeStarted && std::chrono::system_clock::now() > m_tFadeEnds) {
             releaseSessionLock();
             break;
         }
+
+        if (m_bTerminate)
+            break;
+
         std::lock_guard<std::mutex> lg(m_sLoopState.eventLoopMutex);
 
         m_sLoopState.event = false;
@@ -506,7 +512,7 @@ void CHyprlock::run() {
 
         passed.clear();
 
-        if (m_bTerminate || (std::chrono::system_clock::now() > m_tFadeEnds && m_bFadeStarted)) {
+        if (!NOFADEOUT && m_bFadeStarted && std::chrono::system_clock::now() > m_tFadeEnds) {
             releaseSessionLock();
             break;
         }

commit e81b44dd273e6b2de41f0642464c4406e3d6ab29
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Tue Apr 9 12:14:25 2024 +0200

    input-field: also fade in when checkWaiting is true (#265)

diff --git a/src/renderer/widgets/PasswordInputField.cpp b/src/renderer/widgets/PasswordInputField.cpp
index d15ba95..202bc8e 100644
--- a/src/renderer/widgets/PasswordInputField.cpp
+++ b/src/renderer/widgets/PasswordInputField.cpp
@@ -94,15 +94,17 @@ void CPasswordInputField::updateFade() {
         return;
     }
 
-    if (passwordLength > 0 && fade.allowFadeOut)
+    const bool INPUTUSED = passwordLength > 0 || checkWaiting;
+
+    if (INPUTUSED && fade.allowFadeOut)
         fade.allowFadeOut = false;
 
-    if (passwordLength > 0 && fade.fadeOutTimer.get()) {
+    if (INPUTUSED && fade.fadeOutTimer.get()) {
         fade.fadeOutTimer->cancel();
         fade.fadeOutTimer.reset();
     }
 
-    if (passwordLength == 0 && fade.a != 0.0 && (!fade.animated || fade.appearing)) {
+    if (!INPUTUSED && fade.a != 0.0 && (!fade.animated || fade.appearing)) {
         if (fade.allowFadeOut || fadeTimeoutMs == 0) {
             fade.a            = 1.0;
             fade.animated     = true;
@@ -113,7 +115,7 @@ void CPasswordInputField::updateFade() {
             fade.fadeOutTimer = g_pHyprlock->addTimer(std::chrono::milliseconds(fadeTimeoutMs), fadeOutCallback, this);
     }
 
-    if (passwordLength > 0 && fade.a != 1.0 && (!fade.animated || !fade.appearing)) {
+    if (INPUTUSED && fade.a != 1.0 && (!fade.animated || !fade.appearing)) {
         fade.a         = 0.0;
         fade.animated  = true;
         fade.appearing = true;

commit 6e929ab7ff879969660ece79adb5d16c1c3f6d46
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Apr 10 12:28:24 2024 +0200

    core: use --immediate for attemptRestoreOnDeath (#270)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 4dccce1..47d7f4d 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -1049,5 +1049,5 @@ void CHyprlock::attemptRestoreOnDeath() {
     ofs.close();
 
     spawnSync("hyprctl keyword misc:allow_session_lock_restore true");
-    spawnAsync("sleep 2 && hyprlock & disown");
+    spawnAsync("sleep 2 && hyprlock --immediate & disown");
 }

commit 9c0df19a822efaf82b5adcfaaa1d0955c11ceb0f
Author: bvr-yr <130279855+bvr-yr@users.noreply.github.com>
Date:   Wed Apr 10 19:24:17 2024 +0300

    widgets: add Shape + minor image improve (#266)
    
    * widgets: add Shape
    
    * image: minor improvment
    
    * glClear on FB alloc
    
    * add Nix HM
    
    * always create FB if not xray

diff --git a/nix/hm-module.nix b/nix/hm-module.nix
index 4029df6..bb3cdb0 100644
--- a/nix/hm-module.nix
+++ b/nix/hm-module.nix
@@ -179,6 +179,95 @@ in {
       ];
     };
 
+    shapes = mkOption {
+      description = "Shape configurations";
+      type = listOf (submodule {
+        options = {
+          monitor = mkOption {
+            description = "The monitor to draw a shape";
+            type = str;
+            default = "";
+          };
+
+          size = {
+            x = mkOption {
+              description = "Width of the shape";
+              type = int;
+              default = 360;
+            };
+            y = mkOption {
+              description = "Height of the shape";
+              type = int;
+              default = 60;
+            };
+          };
+
+          color = mkOption {
+            description = "Color of the shape";
+            type = str;
+            default = "rgba(22, 17, 17, 1.0)";
+          };
+
+          rounding = mkOption {
+            description = "Rounding of the shape";
+            type = int;
+            default = -1;
+          };
+
+          border_size = mkOption {
+            description = "Size of shape border";
+            type = int;
+            default = 4;
+          };
+
+          border_color = mkOption {
+            description = "Color of shape border";
+            type = str;
+            default = "rgba(0, 207, 230, 1.0)";
+          };
+
+          rotate = mkOption {
+            description = "Shape rotation angle";
+            type = float;
+            default = 0.0;
+          };
+
+          xray = mkOption {
+            description = "Whether to make a transparent \"hole\" in the background";
+            type = bool;
+            default = false;
+          };
+
+          position = {
+            x = mkOption {
+              description = "X position of the shape";
+              type = int;
+              default = 0;
+            };
+            y = mkOption {
+              description = "Y position of the shape";
+              type = int;
+              default = 80;
+            };
+          };
+
+          halign = mkOption {
+            description = "Horizontal alignment of the shape";
+            type = str;
+            default = "center";
+          };
+
+          valign = mkOption {
+            description = "Vertical alignment of the shape";
+            type = str;
+            default = "center";
+          };
+        }
+        // shadow;
+      });
+      default = [];
+    };
+
     images = mkOption {
       description = "Image configurations";
       type = listOf (submodule {
@@ -561,6 +650,24 @@ in {
         '')
         cfg.backgrounds)}
 
+      ${builtins.concatStringsSep "\n" (map (shape: ''
+          shape {
+            monitor = ${shape.monitor}
+            size = ${toString shape.size.x}, ${toString shape.size.y}
+            color = ${shape.color}
+            rounding = ${toString shape.rounding}
+            border_size = ${toString shape.border_size}
+            border_color = ${shape.border_color}
+            rotate = ${toString shape.rotate}
+            xray = ${boolToString shape.xray}
+
+            position = ${toString shape.position.x}, ${toString shape.position.y}
+            halign = ${shape.halign}
+            valign = ${shape.valign}
+          }
+        '')
+        cfg.shapes)}
+
       ${builtins.concatStringsSep "\n" (map (image: ''
           image {
             monitor = ${image.monitor}
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 4c8d8a8..394c003 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -62,6 +62,20 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("background", "vibrancy", Hyprlang::FLOAT{0.1686});
     m_config.addSpecialConfigValue("background", "vibrancy_darkness", Hyprlang::FLOAT{0.05});
 
+    m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+    m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
+    m_config.addSpecialConfigValue("shape", "size", Hyprlang::VEC2{100, 100});
+    m_config.addSpecialConfigValue("shape", "rounding", Hyprlang::INT{0});
+    m_config.addSpecialConfigValue("shape", "border_size", Hyprlang::INT{0});
+    m_config.addSpecialConfigValue("shape", "border_color", Hyprlang::INT{0xFF00CFE6});
+    m_config.addSpecialConfigValue("shape", "color", Hyprlang::INT{0xFF111111});
+    m_config.addSpecialConfigValue("shape", "position", Hyprlang::VEC2{0, 80});
+    m_config.addSpecialConfigValue("shape", "halign", Hyprlang::STRING{"center"});
+    m_config.addSpecialConfigValue("shape", "valign", Hyprlang::STRING{"center"});
+    m_config.addSpecialConfigValue("shape", "rotate", Hyprlang::FLOAT{0});
+    m_config.addSpecialConfigValue("shape", "xray", Hyprlang::INT{0});
+    SHADOWABLE("shape");
+
     m_config.addSpecialCategory("image", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
     m_config.addSpecialConfigValue("image", "monitor", Hyprlang::STRING{""});
     m_config.addSpecialConfigValue("image", "path", Hyprlang::STRING{""});
@@ -169,6 +183,30 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
         // clang-format on
     }
 
+    //
+    keys = m_config.listKeysForSpecialCategory("shape");
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            "shape",
+            std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("shape", "monitor", k.c_str())),
+            {
+                {"size", m_config.getSpecialConfigValue("shape", "size", k.c_str())},
+                {"rounding", m_config.getSpecialConfigValue("shape", "rounding", k.c_str())},
+                {"border_size", m_config.getSpecialConfigValue("shape", "border_size", k.c_str())},
+                {"border_color", m_config.getSpecialConfigValue("shape", "border_color", k.c_str())},
+                {"color", m_config.getSpecialConfigValue("shape", "color", k.c_str())},
+                {"position", m_config.getSpecialConfigValue("shape", "position", k.c_str())},
+                {"halign", m_config.getSpecialConfigValue("shape", "halign", k.c_str())},
+                {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
+                {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
+                {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
+                SHADOWABLE("shape"),
+            }
+        });
+        // clang-format on
+    }
+
     //
     keys = m_config.listKeysForSpecialCategory("image");
     for (auto& k : keys) {
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 53ccfc9..b1fdbf1 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -17,6 +17,7 @@
 #include "widgets/Background.hpp"
 #include "widgets/Label.hpp"
 #include "widgets/Image.hpp"
+#include "widgets/Shape.hpp"
 
 inline const float fullVerts[] = {
     1, 0, // top right
@@ -324,6 +325,8 @@ std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CS
                 widgets[surf].emplace_back(std::make_unique<CPasswordInputField>(surf->size, c.values, surf->output->stringPort));
             } else if (c.type == "label") {
                 widgets[surf].emplace_back(std::make_unique<CLabel>(surf->size, c.values, surf->output->stringPort));
+            } else if (c.type == "shape") {
+                widgets[surf].emplace_back(std::make_unique<CShape>(surf->size, c.values));
             } else if (c.type == "image") {
                 const std::string PATH = std::any_cast<Hyprlang::STRING>(c.values.at("path"));
 
diff --git a/src/renderer/widgets/Image.cpp b/src/renderer/widgets/Image.cpp
index 5a9c230..cf416df 100644
--- a/src/renderer/widgets/Image.cpp
+++ b/src/renderer/widgets/Image.cpp
@@ -132,12 +132,14 @@ bool CImage::draw(const SRenderData& data) {
 
     if (!imageFB.isAllocated()) {
 
-        const Vector2D TEXSIZE = asset->texture.m_vSize;
-        const float    SCALEX  = size / TEXSIZE.x;
-        const float    SCALEY  = size / TEXSIZE.y;
+        const Vector2D IMAGEPOS  = {border, border};
+        const Vector2D BORDERPOS = {0.0, 0.0};
+        const Vector2D TEXSIZE   = asset->texture.m_vSize;
+        const float    SCALEX    = size / TEXSIZE.x;
+        const float    SCALEY    = size / TEXSIZE.y;
 
-        // image with borders offset
-        CBox texbox = {{border, border}, TEXSIZE};
+        // image with borders offset, with extra pixel for anti-aliasing when rotated
+        CBox texbox = {angle == 0 ? IMAGEPOS : IMAGEPOS + Vector2D{1.0, 1.0}, TEXSIZE};
 
         texbox.w *= std::max(SCALEX, SCALEY);
         texbox.h *= std::max(SCALEX, SCALEY);
@@ -145,16 +147,19 @@ bool CImage::draw(const SRenderData& data) {
         const bool ALLOWROUND = rounding > -1 && rounding < std::min(texbox.w, texbox.h) / 2.0;
 
         // plus borders if any
-        CBox borderBox = {{}, {texbox.w + border * 2.0, texbox.h + border * 2.0}};
+        CBox borderBox = {angle == 0 ? BORDERPOS : BORDERPOS + Vector2D{1.0, 1.0}, texbox.size() + IMAGEPOS * 2.0};
 
         borderBox.round();
-        imageFB.alloc(borderBox.w, borderBox.h, true);
+
+        const Vector2D FBSIZE = angle == 0 ? borderBox.size() : borderBox.size() + Vector2D{2.0, 2.0};
+
+        imageFB.alloc(FBSIZE.x, FBSIZE.y, true);
         g_pRenderer->pushFb(imageFB.m_iFb);
         glClearColor(0.0, 0.0, 0.0, 0.0);
         glClear(GL_COLOR_BUFFER_BIT);
 
         if (border > 0)
-            g_pRenderer->renderRect(borderBox, color, ALLOWROUND ? rounding : std::min(borderBox.w, borderBox.h) / 2.0);
+            g_pRenderer->renderRect(borderBox, color, ALLOWROUND ? (rounding == 0 ? 0 : rounding + std::round(border / M_PI)) : std::min(borderBox.w, borderBox.h) / 2.0);
 
         texbox.round();
         g_pRenderer->renderTexture(texbox, asset->texture, 1.0, ALLOWROUND ? rounding : std::min(texbox.w, texbox.h) / 2.0, WL_OUTPUT_TRANSFORM_NORMAL);
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index bb06999..d988a6f 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -116,12 +116,13 @@ bool CLabel::draw(const SRenderData& data) {
         }
     }
 
+    shadow.draw(data);
+
     // calc pos
     pos = posFromHVAlign(viewport, asset->texture.m_vSize, configPos, halign, valign, angle);
 
     CBox box = {pos.x, pos.y, asset->texture.m_vSize.x, asset->texture.m_vSize.y};
     box.rot  = angle;
-    shadow.draw(data);
     g_pRenderer->renderTexture(box, asset->texture, data.opacity);
 
     return false;
diff --git a/src/renderer/widgets/Shape.cpp b/src/renderer/widgets/Shape.cpp
new file mode 100644
index 0000000..2ff7553
--- /dev/null
+++ b/src/renderer/widgets/Shape.cpp
@@ -0,0 +1,89 @@
+#include "Shape.hpp"
+#include "../Renderer.hpp"
+#include <cmath>
+
+CShape::CShape(const Vector2D& viewport_, const std::unordered_map<std::string, std::any>& props) : shadow(this, props, viewport_) {
+
+    size        = std::any_cast<Hyprlang::VEC2>(props.at("size"));
+    rounding    = std::any_cast<Hyprlang::INT>(props.at("rounding"));
+    border      = std::any_cast<Hyprlang::INT>(props.at("border_size"));
+    color       = std::any_cast<Hyprlang::INT>(props.at("color"));
+    borderColor = std::any_cast<Hyprlang::INT>(props.at("border_color"));
+    pos         = std::any_cast<Hyprlang::VEC2>(props.at("position"));
+    halign      = std::any_cast<Hyprlang::STRING>(props.at("halign"));
+    valign      = std::any_cast<Hyprlang::STRING>(props.at("valign"));
+    angle       = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
+    xray        = std::any_cast<Hyprlang::INT>(props.at("xray"));
+
+    viewport = viewport_;
+    angle    = angle * M_PI / 180.0;
+
+    const Vector2D VBORDER  = {border, border};
+    const Vector2D REALSIZE = size + VBORDER * 2.0;
+    const Vector2D OFFSET   = angle == 0 ? Vector2D{0.0, 0.0} : Vector2D{1.0, 1.0};
+
+    pos = posFromHVAlign(viewport, xray ? size : REALSIZE + OFFSET * 2.0, pos, halign, valign, xray ? 0 : angle);
+
+    if (xray) {
+        shapeBox  = {pos, size};
+        borderBox = {pos - VBORDER, REALSIZE};
+    } else {
+        shapeBox  = {OFFSET + VBORDER, size};
+        borderBox = {OFFSET, REALSIZE};
+    }
+}
+
+bool CShape::draw(const SRenderData& data) {
+
+    if (firstRender) {
+        firstRender = false;
+        shadow.markShadowDirty();
+    }
+
+    shadow.draw(data);
+
+    const auto MINHALFBORDER = std::min(borderBox.w, borderBox.h) / 2.0;
+
+    if (xray) {
+        if (border > 0) {
+            const int PIROUND   = std::min(MINHALFBORDER, std::round(border * M_PI));
+            CColor    borderCol = borderColor;
+            borderCol.a *= data.opacity;
+            g_pRenderer->renderRect(borderBox, borderCol, rounding == -1 ? PIROUND : std::clamp(rounding, 0, PIROUND));
+        }
+
+        glEnable(GL_SCISSOR_TEST);
+        glScissor(shapeBox.x, shapeBox.y, shapeBox.width, shapeBox.height);
+        glClearColor(0.0, 0.0, 0.0, 0.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glDisable(GL_SCISSOR_TEST);
+
+        return data.opacity < 1.0;
+    }
+
+    if (!shapeFB.isAllocated()) {
+        const auto MINHALFSHAPE = std::min(shapeBox.w, shapeBox.h) / 2.0;
+        const bool ALLOWROUND   = rounding > -1 && rounding < MINHALFSHAPE;
+
+        shapeFB.alloc(borderBox.width + borderBox.x * 2.0, borderBox.height + borderBox.y * 2.0, true);
+        g_pRenderer->pushFb(shapeFB.m_iFb);
+        glClearColor(0.0, 0.0, 0.0, 0.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+
+        if (border > 0)
+            g_pRenderer->renderRect(borderBox, borderColor, ALLOWROUND ? (rounding == 0 ? 0 : rounding + std::round(border / M_PI)) : MINHALFBORDER);
+
+        g_pRenderer->renderRect(shapeBox, color, ALLOWROUND ? rounding : MINHALFSHAPE);
+        g_pRenderer->popFb();
+    }
+
+    CTexture* tex    = &shapeFB.m_cTex;
+    CBox      texbox = {pos, tex->m_vSize};
+
+    texbox.round();
+    texbox.rot = angle;
+
+    g_pRenderer->renderTexture(texbox, *tex, data.opacity, 0, WL_OUTPUT_TRANSFORM_FLIPPED_180);
+
+    return data.opacity < 1.0;
+}
diff --git a/src/renderer/widgets/Shape.hpp b/src/renderer/widgets/Shape.hpp
new file mode 100644
index 0000000..d749d68
--- /dev/null
+++ b/src/renderer/widgets/Shape.hpp
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "IWidget.hpp"
+#include "../../helpers/Vector2D.hpp"
+#include "../../helpers/Color.hpp"
+#include "../../helpers/Box.hpp"
+#include "Shadowable.hpp"
+#include <string>
+#include <unordered_map>
+#include <any>
+
+class CShape : public IWidget {
+  public:
+    CShape(const Vector2D& viewport, const std::unordered_map<std::string, std::any>& props);
+
+    virtual bool draw(const SRenderData& data);
+
+  private:
+    CFramebuffer shapeFB;
+
+    int          rounding;
+    double       border;
+    double       angle;
+    CColor       color;
+    CColor       borderColor;
+    Vector2D     size;
+    Vector2D     pos;
+    CBox         shapeBox;
+    CBox         borderBox;
+    bool         xray;
+
+    std::string  halign, valign;
+
+    bool         firstRender = true;
+
+    Vector2D     viewport;
+    CShadowable  shadow;
+};

commit 5d7e28d1013215be6b6b4cc2cf92c36fdd9ce6b3
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Apr 10 23:41:31 2024 +0200

    auth: implement a full pam conversation (#205)
    
    * auth: implement a full pam conversation
    
    * input-field: fixup failedAttempts and color change
    
    Credits to @bvr-yr
    
    * pam: set default module to hyprland
    
    * input-field: backup previous asset
    
    * auth: restart auth in onPasswordCheckTimer
    
    * auth: immediately switch to waiting when input was submitted
    
    * auth: remove redundant waitingForPamAuth
    
    * auth: add inputRequested and reschedule submitInput
    
    * auth: clear password buffer and handle submitInput before input is requested
    
    * Revert "input-field: backup previous asset"
    
    This reverts commit 89702945be6af4aa43f54688ad34a4ccba994a3e.
    
    Without the backup we avoid rendering the prompt placeholder for one frame when the failText is not available.
    Looks better this way.
    
    * auth: fallback to su if pam_module not in /etc/pam.d
    
    rare occasion where a path check even works on nix
    
    * auth: rename inputSubmitted and resubmit callback
    
    * auth: detach failText from the conversation
    
    * fix rebase mistake
    
    * auth: make sure prompt and failText are not reset when restarting auth
    
    needed for labels
    
    * auth: force update timers when the prompt changes
    
    * auth: remove unused stuff

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 394c003..1de72a4 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -49,6 +49,7 @@ void CConfigManager::init() {
     m_config.addConfigValue("general:no_fade_in", Hyprlang::INT{0});
     m_config.addConfigValue("general:no_fade_out", Hyprlang::INT{0});
     m_config.addConfigValue("general:ignore_empty_input", Hyprlang::INT{0});
+    m_config.addConfigValue("general:pam_module", Hyprlang::STRING{"hyprlock"});
 
     m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
     m_config.addSpecialConfigValue("background", "monitor", Hyprlang::STRING{""});
diff --git a/src/core/Auth.cpp b/src/core/Auth.cpp
new file mode 100644
index 0000000..ea3066f
--- /dev/null
+++ b/src/core/Auth.cpp
@@ -0,0 +1,166 @@
+#include "Auth.hpp"
+#include "hyprlock.hpp"
+#include "../helpers/Log.hpp"
+#include "src/config/ConfigManager.hpp"
+
+#include <filesystem>
+#include <unistd.h>
+#include <pwd.h>
+#include <security/pam_appl.h>
+#if __has_include(<security/pam_misc.h>)
+#include <security/pam_misc.h>
+#endif
+
+#include <cstring>
+#include <thread>
+
+int conv(int num_msg, const struct pam_message** msg, struct pam_response** resp, void* appdata_ptr) {
+    const auto           CONVERSATIONSTATE = (CAuth::SPamConversationState*)appdata_ptr;
+    struct pam_response* pamReply          = (struct pam_response*)calloc(num_msg, sizeof(struct pam_response));
+    bool                 initialPrompt     = true;
+
+    for (int i = 0; i < num_msg; ++i) {
+        switch (msg[i]->msg_style) {
+            case PAM_PROMPT_ECHO_OFF:
+            case PAM_PROMPT_ECHO_ON: {
+                const auto PROMPT        = std::string(msg[i]->msg);
+                const auto PROMPTCHANGED = PROMPT != CONVERSATIONSTATE->prompt;
+                Debug::log(LOG, "PAM_PROMPT: {}", PROMPT);
+
+                if (PROMPTCHANGED)
+                    g_pHyprlock->enqueueForceUpdateTimers();
+
+                // Some pam configurations ask for the password twice for whatever reason (Fedora su for example)
+                // When the prompt is the same as the last one, I guess our answer can be the same.
+                if (initialPrompt || PROMPTCHANGED) {
+                    CONVERSATIONSTATE->prompt = PROMPT;
+                    g_pAuth->waitForInput();
+                }
+
+                // Needed for unlocks via SIGUSR1
+                if (g_pHyprlock->m_bTerminate)
+                    return PAM_CONV_ERR;
+
+                pamReply[i].resp = strdup(CONVERSATIONSTATE->input.c_str());
+                initialPrompt    = false;
+            } break;
+            case PAM_ERROR_MSG: Debug::log(ERR, "PAM: {}", msg[i]->msg); break;
+            case PAM_TEXT_INFO: Debug::log(LOG, "PAM: {}", msg[i]->msg); break;
+        }
+    }
+
+    *resp = pamReply;
+    return PAM_SUCCESS;
+}
+
+CAuth::CAuth() {
+    static auto* const PPAMMODULE = (Hyprlang::STRING*)(g_pConfigManager->getValuePtr("general:pam_module"));
+    m_sPamModule                  = *PPAMMODULE;
+
+    if (!std::filesystem::exists(std::filesystem::path("/etc/pam.d/") / m_sPamModule)) {
+        Debug::log(ERR, "Pam module \"{}\" not found! Falling back to \"su\"", m_sPamModule);
+        m_sPamModule = "su";
+    }
+}
+
+static void passwordCheckTimerCallback(std::shared_ptr<CTimer> self, void* data) {
+    g_pHyprlock->onPasswordCheckTimer();
+}
+
+void CAuth::start() {
+    std::thread([this]() {
+        resetConversation();
+        auth();
+
+        g_pHyprlock->addTimer(std::chrono::milliseconds(1), passwordCheckTimerCallback, nullptr);
+    }).detach();
+}
+
+bool CAuth::auth() {
+    const pam_conv localConv   = {conv, (void*)&m_sConversationState};
+    pam_handle_t*  handle      = NULL;
+    auto           uidPassword = getpwuid(getuid());
+
+    int            ret = pam_start(m_sPamModule.c_str(), uidPassword->pw_name, &localConv, &handle);
+
+    if (ret != PAM_SUCCESS) {
+        m_sConversationState.success  = false;
+        m_sConversationState.failText = "pam_start failed";
+        Debug::log(ERR, "auth: pam_start failed for {}", m_sPamModule);
+        return false;
+    }
+
+    ret = pam_authenticate(handle, 0);
+
+    m_sConversationState.waitingForPamAuth = false;
+
+    if (ret != PAM_SUCCESS) {
+        m_sConversationState.success  = false;
+        m_sConversationState.failText = ret == PAM_AUTH_ERR ? "Authentication failed" : "pam_authenticate failed";
+        Debug::log(ERR, "auth: {} for {}", m_sConversationState.failText, m_sPamModule);
+        return false;
+    }
+
+    ret = pam_end(handle, ret);
+
+    m_sConversationState.success  = true;
+    m_sConversationState.failText = "Successfully authenticated";
+    Debug::log(LOG, "auth: authenticated for {}", m_sPamModule);
+
+    return true;
+}
+
+bool CAuth::didAuthSucceed() {
+    return m_sConversationState.success;
+}
+
+// clearing the input must be done from the main thread
+static void clearInputTimerCallback(std::shared_ptr<CTimer> self, void* data) {
+    g_pHyprlock->clearPasswordBuffer();
+}
+
+void CAuth::waitForInput() {
+    g_pHyprlock->addTimer(std::chrono::milliseconds(1), clearInputTimerCallback, nullptr);
+
+    std::unique_lock<std::mutex> lk(m_sConversationState.inputMutex);
+    m_bBlockInput                          = false;
+    m_sConversationState.waitingForPamAuth = false;
+    m_sConversationState.inputRequested    = true;
+    m_sConversationState.inputSubmittedCondition.wait(lk, [this] { return !m_sConversationState.inputRequested || g_pHyprlock->m_bTerminate; });
+    m_bBlockInput = true;
+}
+
+void CAuth::submitInput(std::string input) {
+    std::unique_lock<std::mutex> lk(m_sConversationState.inputMutex);
+
+    if (!m_sConversationState.inputRequested)
+        Debug::log(ERR, "SubmitInput called, but the auth thread is not waiting for input!");
+
+    m_sConversationState.input             = input;
+    m_sConversationState.inputRequested    = false;
+    m_sConversationState.waitingForPamAuth = true;
+    m_sConversationState.inputSubmittedCondition.notify_all();
+}
+
+std::optional<std::string> CAuth::getLastFailText() {
+    return m_sConversationState.failText.empty() ? std::nullopt : std::optional(m_sConversationState.failText);
+}
+
+std::optional<std::string> CAuth::getLastPrompt() {
+    return m_sConversationState.prompt.empty() ? std::nullopt : std::optional(m_sConversationState.prompt);
+}
+
+bool CAuth::checkWaiting() {
+    return m_bBlockInput || m_sConversationState.waitingForPamAuth;
+}
+
+void CAuth::terminate() {
+    m_sConversationState.inputSubmittedCondition.notify_all();
+}
+
+void CAuth::resetConversation() {
+    m_sConversationState.input             = "";
+    m_sConversationState.waitingForPamAuth = false;
+    m_sConversationState.inputRequested    = false;
+    m_sConversationState.success           = false;
+}
diff --git a/src/core/Auth.hpp b/src/core/Auth.hpp
new file mode 100644
index 0000000..b0fea79
--- /dev/null
+++ b/src/core/Auth.hpp
@@ -0,0 +1,54 @@
+#pragma once
+
+#include <memory>
+#include <optional>
+#include <string>
+#include <mutex>
+#include <condition_variable>
+
+class CAuth {
+  public:
+    struct SPamConversationState {
+        std::string             input    = "";
+        std::string             prompt   = "";
+        std::string             failText = "";
+
+        std::mutex              inputMutex;
+        std::condition_variable inputSubmittedCondition;
+
+        bool                    waitingForPamAuth = false;
+        bool                    inputRequested    = false;
+
+        bool                    success = false;
+    };
+
+    CAuth();
+
+    void                       start();
+    bool                       auth();
+    bool                       didAuthSucceed();
+
+    void                       waitForInput();
+    void                       submitInput(std::string input);
+
+    std::optional<std::string> getLastFailText();
+    std::optional<std::string> getLastPrompt();
+
+    bool                       checkWaiting();
+
+    void                       terminate();
+
+    // Should only be set via the main thread
+    bool m_bDisplayFailText = false;
+
+  private:
+    SPamConversationState m_sConversationState;
+
+    bool                  m_bBlockInput = true;
+
+    std::string           m_sPamModule;
+
+    void                  resetConversation();
+};
+
+inline std::unique_ptr<CAuth> g_pAuth;
diff --git a/src/core/Password.cpp b/src/core/Password.cpp
deleted file mode 100644
index f1c3653..0000000
--- a/src/core/Password.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-#include "Password.hpp"
-#include "hyprlock.hpp"
-#include "../helpers/Log.hpp"
-
-#include <unistd.h>
-#include <pwd.h>
-#include <security/pam_appl.h>
-#if __has_include(<security/pam_misc.h>)
-#include <security/pam_misc.h>
-#endif
-
-#include <cstring>
-#include <thread>
-
-//
-int conv(int num_msg, const struct pam_message** msg, struct pam_response** resp, void* appdata_ptr) {
-    const char*          pass      = static_cast<const char*>(appdata_ptr);
-    struct pam_response* pam_reply = static_cast<struct pam_response*>(calloc(num_msg, sizeof(struct pam_response)));
-
-    for (int i = 0; i < num_msg; ++i) {
-        switch (msg[i]->msg_style) {
-            case PAM_PROMPT_ECHO_OFF:
-            case PAM_PROMPT_ECHO_ON: pam_reply[i].resp = strdup(pass); break;
-            case PAM_ERROR_MSG: Debug::log(ERR, "PAM: {}", msg[i]->msg); break;
-            case PAM_TEXT_INFO: Debug::log(LOG, "PAM: {}", msg[i]->msg); break;
-        }
-    }
-    *resp = pam_reply;
-    return PAM_SUCCESS;
-}
-
-static void passwordCheckTimerCallback(std::shared_ptr<CTimer> self, void* data) {
-    g_pHyprlock->onPasswordCheckTimer();
-}
-
-std::shared_ptr<CPassword::SVerificationResult> CPassword::verify(const std::string& pass) {
-
-    std::shared_ptr<CPassword::SVerificationResult> result = std::make_shared<CPassword::SVerificationResult>(false);
-
-    std::thread([this, result, pass]() {
-        auto auth = [&](std::string auth) -> bool {
-            const pam_conv localConv   = {conv, (void*)pass.c_str()};
-            pam_handle_t*  handle      = NULL;
-            auto           uidPassword = getpwuid(getuid());
-
-            int            ret = pam_start(auth.c_str(), uidPassword->pw_name, &localConv, &handle);
-
-            if (ret != PAM_SUCCESS) {
-                result->success    = false;
-                result->failReason = "pam_start failed";
-                Debug::log(ERR, "auth: pam_start failed for {}", auth);
-                return false;
-            }
-
-            ret = pam_authenticate(handle, 0);
-
-            if (ret != PAM_SUCCESS) {
-                result->success    = false;
-                result->failReason = ret == PAM_AUTH_ERR ? "Authentication failed" : "pam_authenticate failed";
-                Debug::log(ERR, "auth: {} for {}", result->failReason, auth);
-                return false;
-            }
-
-            ret = pam_end(handle, ret);
-
-            result->success    = true;
-            result->failReason = "Successfully authenticated";
-            Debug::log(LOG, "auth: authenticated for {}", auth);
-
-            return true;
-        };
-
-        result->realized = auth("hyprlock") || auth("su") || true;
-        g_pHyprlock->addTimer(std::chrono::milliseconds(1), passwordCheckTimerCallback, nullptr);
-    }).detach();
-
-    return result;
-}
diff --git a/src/core/Password.hpp b/src/core/Password.hpp
deleted file mode 100644
index 74fcbac..0000000
--- a/src/core/Password.hpp
+++ /dev/null
@@ -1,18 +0,0 @@
-#pragma once
-
-#include <memory>
-#include <string>
-#include <atomic>
-
-class CPassword {
-  public:
-    struct SVerificationResult {
-        std::atomic<bool> realized   = false;
-        bool              success    = false;
-        std::string       failReason = "";
-    };
-
-    std::shared_ptr<SVerificationResult> verify(const std::string& pass);
-};
-
-inline std::unique_ptr<CPassword> g_pPassword = std::make_unique<CPassword>();
\ No newline at end of file
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 47d7f4d..61485ec 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -2,7 +2,7 @@
 #include "../helpers/Log.hpp"
 #include "../config/ConfigManager.hpp"
 #include "../renderer/Renderer.hpp"
-#include "Password.hpp"
+#include "Auth.hpp"
 #include "Egl.hpp"
 
 #include <sys/wait.h>
@@ -381,6 +381,9 @@ void CHyprlock::run() {
 
     acquireSessionLock();
 
+    g_pAuth = std::make_unique<CAuth>();
+    g_pAuth->start();
+
     registerSignalAction(SIGUSR1, handleUnlockSignal, SA_RESTART);
     registerSignalAction(SIGUSR2, handleForceUpdateSignal);
     registerSignalAction(SIGRTMIN, handlePollTerminate);
@@ -533,6 +536,8 @@ void CHyprlock::run() {
 
     pthread_kill(pollThr.native_handle(), SIGRTMIN);
 
+    g_pAuth->terminate();
+
     // wait for threads to exit cleanly to avoid a coredump
     pollThr.join();
     timersThr.join();
@@ -737,32 +742,44 @@ static const ext_session_lock_v1_listener sessionLockListener = {
 
 // end session_lock
 
+static void displayFailTextTimerCallback(std::shared_ptr<CTimer> self, void* data) {
+    g_pAuth->m_bDisplayFailText = false;
+
+    for (auto& o : g_pHyprlock->m_vOutputs) {
+        o->sessionLockSurface->render();
+    }
+}
+
 void CHyprlock::onPasswordCheckTimer() {
     // check result
-    if (m_sPasswordState.result->success) {
+    if (g_pAuth->didAuthSucceed()) {
         unlock();
     } else {
-        Debug::log(LOG, "Authentication failed: {}", m_sPasswordState.result->failReason);
-        m_sPasswordState.lastFailReason = m_sPasswordState.result->failReason;
-        m_sPasswordState.passBuffer     = "";
-        m_sPasswordState.failedAttempts += 1;
         Debug::log(LOG, "Failed attempts: {}", m_sPasswordState.failedAttempts);
+
+        m_sPasswordState.passBuffer = "";
+        m_sPasswordState.failedAttempts += 1;
+        g_pAuth->m_bDisplayFailText = true;
         forceUpdateTimers();
 
+        g_pHyprlock->addTimer(/* controls error message duration */ std::chrono::seconds(1), displayFailTextTimerCallback, nullptr);
+
+        g_pAuth->start();
+
         for (auto& o : m_vOutputs) {
             o->sessionLockSurface->render();
         }
     }
-
-    m_sPasswordState.result.reset();
 }
 
-bool CHyprlock::passwordCheckWaiting() {
-    return m_sPasswordState.result.get();
-}
+void CHyprlock::clearPasswordBuffer() {
+    if (m_sPasswordState.passBuffer.empty())
+        return;
 
-std::optional<std::string> CHyprlock::passwordLastFailReason() {
-    return m_sPasswordState.lastFailReason;
+    m_sPasswordState.passBuffer = "";
+    for (auto& o : m_vOutputs) {
+        o->sessionLockSurface->render();
+    }
 }
 
 void CHyprlock::renderOutput(const std::string& stringPort) {
@@ -798,7 +815,7 @@ void CHyprlock::onKey(uint32_t key, bool down) {
     else
         std::erase(m_vPressedKeys, key);
 
-    if (m_sPasswordState.result) {
+    if (g_pAuth->checkWaiting()) {
         for (auto& o : m_vOutputs) {
             o->sessionLockSurface->render();
         }
@@ -826,7 +843,7 @@ void CHyprlock::onKey(uint32_t key, bool down) {
                 return;
             }
 
-            m_sPasswordState.result = g_pPassword->verify(m_sPasswordState.passBuffer);
+            g_pAuth->submitInput(m_sPasswordState.passBuffer);
         } else if (SYM == XKB_KEY_BackSpace) {
             if (m_sPasswordState.passBuffer.length() > 0) {
                 // handle utf-8
@@ -941,6 +958,11 @@ std::vector<std::shared_ptr<CTimer>> CHyprlock::getTimers() {
     return m_vTimers;
 }
 
+void CHyprlock::enqueueForceUpdateTimers() {
+    addTimer(
+        std::chrono::milliseconds(1), [](std::shared_ptr<CTimer> self, void* data) { forceUpdateTimers(); }, nullptr, false);
+}
+
 void CHyprlock::spawnAsync(const std::string& args) {
     Debug::log(LOG, "Executing (async) {}", args);
 
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index cb7c92c..a24df22 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -9,7 +9,7 @@
 #include "Output.hpp"
 #include "CursorShape.hpp"
 #include "Timer.hpp"
-#include "Password.hpp"
+#include "Auth.hpp"
 
 #include <memory>
 #include <vector>
@@ -40,6 +40,8 @@ class CHyprlock {
     std::shared_ptr<CTimer>         addTimer(const std::chrono::system_clock::duration& timeout, std::function<void(std::shared_ptr<CTimer> self, void* data)> cb_, void* data,
                                              bool force = false);
 
+    void                            enqueueForceUpdateTimers();
+
     void                            onLockLocked();
     void                            onLockFinished();
 
@@ -53,6 +55,7 @@ class CHyprlock {
 
     void                            onKey(uint32_t key, bool down);
     void                            onPasswordCheckTimer();
+    void                            clearPasswordBuffer();
     bool                            passwordCheckWaiting();
     std::optional<std::string>      passwordLastFailReason();
 
@@ -129,10 +132,9 @@ class CHyprlock {
     } m_sLockState;
 
     struct {
-        std::string                                     passBuffer = "";
-        std::shared_ptr<CPassword::SVerificationResult> result;
-        std::optional<std::string>                      lastFailReason;
-        size_t                                          failedAttempts = 0;
+        std::string passBuffer      = "";
+        size_t      failedAttempts  = 0;
+        bool        displayFailText = false;
     } m_sPasswordState;
 
     struct {
diff --git a/src/main.cpp b/src/main.cpp
index cf47ac0..8bc156f 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -15,7 +15,7 @@ void help() {
 int main(int argc, char** argv, char** envp) {
     std::string configPath;
     std::string wlDisplay;
-    bool immediate = false;
+    bool        immediate = false;
 
     for (int i = 1; i < argc; ++i) {
         std::string arg = argv[i];
@@ -32,8 +32,7 @@ int main(int argc, char** argv, char** envp) {
         else if (arg == "--display" && i + 1 < argc) {
             wlDisplay = argv[i + 1];
             i++;
-        }
-        else if (arg == "--immediate") {
+        } else if (arg == "--immediate") {
             immediate = true;
         } else if (arg == "--help" || arg == "-h") {
             help();
diff --git a/src/renderer/widgets/IWidget.cpp b/src/renderer/widgets/IWidget.cpp
index 24f9994..b1879fc 100644
--- a/src/renderer/widgets/IWidget.cpp
+++ b/src/renderer/widgets/IWidget.cpp
@@ -131,11 +131,17 @@ IWidget::SFormatResult IWidget::formatString(std::string in) {
     }
 
     if (in.contains("$FAIL")) {
-        const auto FAIL = g_pHyprlock->passwordLastFailReason();
+        const auto FAIL = g_pAuth->getLastFailText();
         replaceAll(in, "$FAIL", FAIL.has_value() ? FAIL.value() : "");
         result.allowForceUpdate = true;
     }
 
+    if (in.contains("$PROMPT")) {
+        const auto PROMPT = g_pAuth->getLastPrompt();
+        replaceAll(in, "$PROMPT", PROMPT.has_value() ? PROMPT.value() : "");
+        result.allowForceUpdate = true;
+    }
+
     if (in.contains("$ATTEMPTS")) {
         replaceAllAttempts(in);
         result.allowForceUpdate = true;
diff --git a/src/renderer/widgets/PasswordInputField.cpp b/src/renderer/widgets/PasswordInputField.cpp
index 202bc8e..4feb778 100644
--- a/src/renderer/widgets/PasswordInputField.cpp
+++ b/src/renderer/widgets/PasswordInputField.cpp
@@ -1,8 +1,19 @@
 #include "PasswordInputField.hpp"
 #include "../Renderer.hpp"
 #include "../../core/hyprlock.hpp"
+#include "src/core/Auth.hpp"
 #include <algorithm>
 
+static void replaceAll(std::string& str, const std::string& from, const std::string& to) {
+    if (from.empty())
+        return;
+    size_t pos = 0;
+    while ((pos = str.find(from, pos)) != std::string::npos) {
+        str.replace(pos, from.length(), to);
+        pos += to.length();
+    }
+}
+
 CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::unordered_map<std::string, std::any>& props, const std::string& output) :
     outputStringPort(output), shadow(this, props, viewport_) {
     size                     = std::any_cast<Hyprlang::VEC2>(props.at("size"));
@@ -15,6 +26,7 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
     fadeTimeoutMs            = std::any_cast<Hyprlang::INT>(props.at("fade_timeout"));
     hiddenInputState.enabled = std::any_cast<Hyprlang::INT>(props.at("hide_input"));
     rounding                 = std::any_cast<Hyprlang::INT>(props.at("rounding"));
+    configPlaceholderText    = std::any_cast<Hyprlang::STRING>(props.at("placeholder_text"));
     configFailText           = std::any_cast<Hyprlang::STRING>(props.at("fail_text"));
     col.transitionMs         = std::any_cast<Hyprlang::INT>(props.at("fail_transition"));
     col.outer                = std::any_cast<Hyprlang::INT>(props.at("outer_color"));
@@ -48,15 +60,17 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
 
     g_pHyprlock->m_bNumLock = col.invertNum;
 
-    std::string placeholderText = std::any_cast<Hyprlang::STRING>(props.at("placeholder_text"));
-
     // Render placeholder if either placeholder_text or fail_text are non-empty
     // as placeholder must be rendered to show fail_text
-    if (!placeholderText.empty() || !configFailText.empty()) {
-        placeholder.resourceID = "placeholder:" + std::to_string((uintptr_t)this);
+    if (!configPlaceholderText.empty() || !configFailText.empty()) {
+        placeholder.currentText = configPlaceholderText;
+
+        replaceAll(placeholder.currentText, "$PROMPT", "");
+
+        placeholder.resourceID = "placeholder:" + placeholder.currentText + std::to_string((uintptr_t)this);
         CAsyncResourceGatherer::SPreloadRequest request;
         request.id                   = placeholder.resourceID;
-        request.asset                = placeholderText;
+        request.asset                = placeholder.currentText;
         request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
         request.props["font_family"] = std::string{"Sans"};
         request.props["color"]       = CColor{1.0 - col.font.r, 1.0 - col.font.g, 1.0 - col.font.b, 0.5};
@@ -65,16 +79,6 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
     }
 }
 
-static void replaceAllFail(std::string& str, const std::string& from, const std::string& to) {
-    if (from.empty())
-        return;
-    size_t pos = 0;
-    while ((pos = str.find(from, pos)) != std::string::npos) {
-        str.replace(pos, from.length(), to);
-        pos += to.length();
-    }
-}
-
 static void fadeOutCallback(std::shared_ptr<CTimer> self, void* data) {
     CPasswordInputField* p = (CPasswordInputField*)data;
 
@@ -173,23 +177,19 @@ bool CPasswordInputField::draw(const SRenderData& data) {
 
     bool forceReload = false;
 
-    if (passwordLength == 0 && g_pHyprlock->getPasswordFailedAttempts() > failedAttempts)
-        forceReload = true;
-
-    failedAttempts = g_pHyprlock->getPasswordFailedAttempts();
     passwordLength = g_pHyprlock->getPasswordBufferDisplayLen();
-    checkWaiting   = g_pHyprlock->passwordCheckWaiting();
+    checkWaiting   = g_pAuth->checkWaiting();
 
     updateFade();
     updateDots();
-    updateFailTex();
+    updatePlaceholder();
     updateColors();
     updateHiddenInputState();
 
     static auto TIMER = std::chrono::system_clock::now();
 
-    if (placeholder.failAsset) {
-        const auto TARGETSIZEX = placeholder.failAsset->texture.m_vSize.x + inputFieldBox.h;
+    if (placeholder.asset) {
+        const auto TARGETSIZEX = placeholder.asset->texture.m_vSize.x + inputFieldBox.h;
 
         if (size.x < TARGETSIZEX) {
             const auto DELTA = std::clamp((int)std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - TIMER).count(), 8000, 20000);
@@ -287,17 +287,10 @@ bool CPasswordInputField::draw(const SRenderData& data) {
     if (passwordLength == 0 && !placeholder.resourceID.empty()) {
         SPreloadedAsset* currAsset = nullptr;
 
-        if (!placeholder.failID.empty()) {
-            if (!placeholder.failAsset)
-                placeholder.failAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(placeholder.failID);
+        if (!placeholder.asset)
+            placeholder.asset = g_pRenderer->asyncResourceGatherer->getAssetByID(placeholder.resourceID);
 
-            currAsset = placeholder.failAsset;
-        } else {
-            if (!placeholder.asset)
-                placeholder.asset = g_pRenderer->asyncResourceGatherer->getAssetByID(placeholder.resourceID);
-
-            currAsset = placeholder.asset;
-        }
+        currAsset = placeholder.asset;
 
         if (currAsset) {
             Vector2D pos = outerBox.pos() + outerBox.size() / 2.f;
@@ -311,41 +304,53 @@ bool CPasswordInputField::draw(const SRenderData& data) {
     return dots.currentAmount != passwordLength || fade.animated || col.animated || redrawShadow || data.opacity < 1.0 || forceReload;
 }
 
-void CPasswordInputField::updateFailTex() {
-    const auto FAIL = g_pHyprlock->passwordLastFailReason();
+void CPasswordInputField::updatePlaceholder() {
+    if (passwordLength != 0) {
+        if (placeholder.asset && /* keep prompt asset cause it is likely to be used again */ placeholder.isFailText) {
+            std::erase(placeholder.registeredResourceIDs, placeholder.resourceID);
+            g_pRenderer->asyncResourceGatherer->unloadAsset(placeholder.asset);
+            placeholder.asset      = nullptr;
+            placeholder.resourceID = "";
+            redrawShadow           = true;
+        }
+        return;
+    }
 
-    if (checkWaiting)
-        placeholder.canGetNewFail = true;
+    const auto AUTHFEEDBACK = g_pAuth->m_bDisplayFailText ? g_pAuth->getLastFailText().value_or("Ups, no fail text?") : g_pAuth->getLastPrompt().value_or("Ups, no prompt?");
 
-    if (passwordLength != 0 || (checkWaiting && passwordLength == 0)) {
-        if (placeholder.failAsset) {
-            g_pRenderer->asyncResourceGatherer->unloadAsset(placeholder.failAsset);
-            placeholder.failAsset = nullptr;
-            placeholder.failID    = "";
-            redrawShadow          = true;
-        }
+    if (placeholder.lastAuthFeedback == AUTHFEEDBACK && g_pHyprlock->getPasswordFailedAttempts() == placeholder.failedAttempts)
         return;
+
+    placeholder.failedAttempts   = g_pHyprlock->getPasswordFailedAttempts();
+    placeholder.isFailText       = g_pAuth->m_bDisplayFailText;
+    placeholder.lastAuthFeedback = AUTHFEEDBACK;
+
+    placeholder.asset = nullptr;
+
+    if (placeholder.isFailText) {
+        placeholder.currentText = configFailText;
+        replaceAll(placeholder.currentText, "$FAIL", AUTHFEEDBACK);
+        replaceAll(placeholder.currentText, "$ATTEMPTS", std::to_string(placeholder.failedAttempts));
+    } else {
+        placeholder.currentText = configPlaceholderText;
+        replaceAll(placeholder.currentText, "$PROMPT", AUTHFEEDBACK);
     }
 
-    if (!FAIL.has_value() || !placeholder.canGetNewFail)
+    placeholder.resourceID = "placeholder:" + placeholder.currentText + std::to_string((uintptr_t)this);
+    if (std::find(placeholder.registeredResourceIDs.begin(), placeholder.registeredResourceIDs.end(), placeholder.resourceID) != placeholder.registeredResourceIDs.end())
         return;
 
-    placeholder.failText = configFailText;
-    replaceAllFail(placeholder.failText, "$FAIL", FAIL.value());
-    replaceAllFail(placeholder.failText, "$ATTEMPTS", std::to_string(failedAttempts));
+    placeholder.registeredResourceIDs.push_back(placeholder.resourceID);
 
     // query
     CAsyncResourceGatherer::SPreloadRequest request;
-    request.id                   = "input-error:" + std::to_string((uintptr_t)this) + ",time:" + std::to_string(time(nullptr));
-    placeholder.failID           = request.id;
-    request.asset                = placeholder.failText;
+    request.id                   = placeholder.resourceID;
+    request.asset                = placeholder.currentText;
     request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
     request.props["font_family"] = std::string{"Sans"};
-    request.props["color"]       = col.fail;
+    request.props["color"]       = (placeholder.isFailText) ? col.fail : col.font;
     request.props["font_size"]   = (int)size.y / 4;
     g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
-
-    placeholder.canGetNewFail = false;
 }
 
 void CPasswordInputField::updateHiddenInputState() {
@@ -425,7 +430,7 @@ void CPasswordInputField::updateColors() {
     col.stateNum  = col.invertNum ? !g_pHyprlock->m_bNumLock : g_pHyprlock->m_bNumLock;
     col.stateCaps = g_pHyprlock->m_bCapsLock;
 
-    if (placeholder.failID.empty()) {
+    if (!placeholder.isFailText || passwordLength > 0 || (passwordLength == 0 && checkWaiting)) {
         if (g_pHyprlock->m_bFadeStarted) {
             if (TARGET == col.check)
                 SOURCE = BORDERLESS ? col.inner : col.outer;
diff --git a/src/renderer/widgets/PasswordInputField.hpp b/src/renderer/widgets/PasswordInputField.hpp
index e78a601..a85f0a2 100644
--- a/src/renderer/widgets/PasswordInputField.hpp
+++ b/src/renderer/widgets/PasswordInputField.hpp
@@ -22,7 +22,7 @@ class CPasswordInputField : public IWidget {
   private:
     void        updateDots();
     void        updateFade();
-    void        updateFailTex();
+    void        updatePlaceholder();
     void        updateHiddenInputState();
     void        updateColors();
 
@@ -31,7 +31,6 @@ class CPasswordInputField : public IWidget {
     bool        checkWaiting = false;
 
     size_t      passwordLength = 0;
-    size_t      failedAttempts = 0;
 
     Vector2D    size;
     Vector2D    pos;
@@ -39,7 +38,7 @@ class CPasswordInputField : public IWidget {
     Vector2D    configPos;
     Vector2D    configSize;
 
-    std::string halign, valign, configFailText, outputStringPort;
+    std::string halign, valign, configFailText, outputStringPort, configPlaceholderText;
 
     int         outThick, rounding;
 
@@ -63,13 +62,18 @@ class CPasswordInputField : public IWidget {
     } fade;
 
     struct {
-        std::string      resourceID = "";
-        SPreloadedAsset* asset      = nullptr;
+        std::string              resourceID = "";
+        SPreloadedAsset*         asset      = nullptr;
+
+        std::string              currentText    = "";
+        size_t                   failedAttempts = 0;
+        bool                     canGetNewText  = true;
+        bool                     isFailText     = false;
+
+        std::string              lastAuthFeedback;
+
+        std::vector<std::string> registeredResourceIDs;
 
-        std::string      failID        = "";
-        SPreloadedAsset* failAsset     = nullptr;
-        bool             canGetNewFail = true;
-        std::string      failText      = "";
     } placeholder;
 
     struct {

commit cab06236bb9fe308c9f88ad6c5283b07e143121a
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Apr 10 22:42:54 2024 +0100

    pam: always install pam file

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e4d73c4..3cc75f1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -83,9 +83,4 @@ protocol("unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml" "linux-dmabuf-unst
 # Installation
 install(TARGETS hyprlock)
 
-install(CODE "
-    if (NOT EXISTS \"${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d/hyprlock\")
-        install(FILES \"${CMAKE_SOURCE_DIR}/pam/hyprlock\" DESTINATION \"${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d\")
-    endif()
-")
-
+install(FILES ${CMAKE_SOURCE_DIR}/pam/hyprlock DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d)

commit df18bef62dab627954ec2ce5a14a1d4303d77434
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Thu Apr 11 20:57:46 2024 +0200

    input-field: increase default fade_timeout (#276)

diff --git a/nix/hm-module.nix b/nix/hm-module.nix
index bb3cdb0..b048eba 100644
--- a/nix/hm-module.nix
+++ b/nix/hm-module.nix
@@ -437,7 +437,7 @@ in {
             fade_timeout = mkOption {
               description = "Milliseconds before the input field should be faded (0 to fade immediately)";
               type = int;
-              default = 1000;
+              default = 2000;
             };
 
             placeholder_text = mkOption {
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 1de72a4..ffb8483 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -103,7 +103,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("input-field", "dots_spacing", Hyprlang::FLOAT{0.2});
     m_config.addSpecialConfigValue("input-field", "dots_rounding", Hyprlang::INT{-1});
     m_config.addSpecialConfigValue("input-field", "fade_on_empty", Hyprlang::INT{1});
-    m_config.addSpecialConfigValue("input-field", "fade_timeout", Hyprlang::INT{1000});
+    m_config.addSpecialConfigValue("input-field", "fade_timeout", Hyprlang::INT{2000});
     m_config.addSpecialConfigValue("input-field", "font_color", Hyprlang::INT{0xFF000000});
     m_config.addSpecialConfigValue("input-field", "halign", Hyprlang::STRING{"center"});
     m_config.addSpecialConfigValue("input-field", "valign", Hyprlang::STRING{"center"});

commit 4dbbaa9f7e9eb21284721f92b85f3f79b784ba11
Author: bvr-yr <130279855+bvr-yr@users.noreply.github.com>
Date:   Sat Apr 13 16:38:06 2024 +0300

    label: add `text_align` option for multi-line text (#278)

diff --git a/nix/hm-module.nix b/nix/hm-module.nix
index b048eba..9d0ae8a 100644
--- a/nix/hm-module.nix
+++ b/nix/hm-module.nix
@@ -561,6 +561,12 @@ in {
               default = "Hi there, $USER";
             };
 
+            text_align = mkOption {
+              description = "Horizontal alignment of multi-line text";
+              type = str;
+              default = "";
+            };
+
             color = mkOption {
               description = "Color of the label";
               type = str;
@@ -729,6 +735,7 @@ in {
           label {
             monitor = ${label.monitor}
             text = ${label.text}
+            text_align = ${label.text_align}
             color = ${label.color}
             font_size = ${toString label.font_size}
             font_family = ${label.font_family}
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index ffb8483..d4d0f50 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -132,6 +132,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("label", "halign", Hyprlang::STRING{"none"});
     m_config.addSpecialConfigValue("label", "valign", Hyprlang::STRING{"none"});
     m_config.addSpecialConfigValue("label", "rotate", Hyprlang::FLOAT{0});
+    m_config.addSpecialConfigValue("label", "text_align", Hyprlang::STRING{""});
     SHADOWABLE("label");
 
     m_config.registerHandler(&::handleSource, "source", {false});
@@ -288,6 +289,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"halign", m_config.getSpecialConfigValue("label", "halign", k.c_str())},
                 {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
                 {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
+                {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
                 SHADOWABLE("label"),
             }
         });
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 1233879..914292e 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -244,6 +244,17 @@ void CAsyncResourceGatherer::renderText(const SPreloadRequest& rq) {
     pango_layout_set_font_description(layout, fontDesc);
     pango_font_description_free(fontDesc);
 
+    if (rq.props.contains("text_align")) {
+        const std::string TEXTALIGN = std::any_cast<std::string>(rq.props.at("text_align"));
+        PangoAlignment    align     = PANGO_ALIGN_LEFT;
+        if (TEXTALIGN == "center")
+            align = PANGO_ALIGN_CENTER;
+        else if (TEXTALIGN == "right")
+            align = PANGO_ALIGN_RIGHT;
+
+        pango_layout_set_alignment(layout, align);
+    }
+
     PangoAttrList* attrList = nullptr;
     GError*        gError   = nullptr;
     char*          buf      = nullptr;
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index d988a6f..11cf82d 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -61,6 +61,7 @@ void CLabel::plantTimer() {
 CLabel::CLabel(const Vector2D& viewport_, const std::unordered_map<std::string, std::any>& props, const std::string& output) :
     outputStringPort(output), shadow(this, props, viewport_) {
     labelPreFormat         = std::any_cast<Hyprlang::STRING>(props.at("text"));
+    std::string textAlign  = std::any_cast<Hyprlang::STRING>(props.at("text_align"));
     std::string fontFamily = std::any_cast<Hyprlang::STRING>(props.at("font_family"));
     CColor      labelColor = std::any_cast<Hyprlang::INT>(props.at("color"));
     int         fontSize   = std::any_cast<Hyprlang::INT>(props.at("font_size"));
@@ -76,6 +77,9 @@ CLabel::CLabel(const Vector2D& viewport_, const std::unordered_map<std::string,
     request.props["font_size"]   = fontSize;
     request.props["cmd"]         = label.cmd;
 
+    if (!textAlign.empty())
+        request.props["text_align"] = textAlign;
+
     g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
 
     auto POS__ = std::any_cast<Hyprlang::VEC2>(props.at("position"));

commit 74547e15f7bb33142f37081a702f3520d0d84674
Author: Andr Silva <123550+andresilva@users.noreply.github.com>
Date:   Fri Apr 19 19:48:11 2024 +0100

    core: fix initialization issues in LockSurface (#285)
    
    * LockSurface: handle uninitialized eglWindow in destructor
    
    * LockSurface: don't render before configuration

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 3223049..d0acd5f 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -28,7 +28,10 @@ CSessionLockSurface::~CSessionLockSurface() {
         wp_viewport_destroy(viewport);
         wp_fractional_scale_v1_destroy(fractional);
     }
-    wl_egl_window_destroy(eglWindow);
+
+    if (eglWindow)
+        wl_egl_window_destroy(eglWindow);
+
     ext_session_lock_surface_v1_destroy(lockSurface);
     wl_surface_destroy(surface);
     if (frameCallback)
@@ -116,7 +119,7 @@ static const wl_callback_listener callbackListener = {
 void CSessionLockSurface::render() {
     Debug::log(TRACE, "render lock");
 
-    if (frameCallback)
+    if (frameCallback || !readyForFrame)
         return;
 
     const auto FEEDBACK = g_pRenderer->renderLock(*this);
@@ -129,7 +132,6 @@ void CSessionLockSurface::render() {
 }
 
 void CSessionLockSurface::onCallback() {
-    readyForFrame = true;
     frameCallback = nullptr;
 
     if (needsFrame && !g_pHyprlock->m_bTerminate && g_pEGL)

commit 7418cdb11c07b5d5c4d1a881baab18020458fc8b
Author: Vaxry <vaxry@vaxry.net>
Date:   Mon Apr 22 10:12:42 2024 +0100

    image: fix build with libc++
    
    fixes #289

diff --git a/src/renderer/widgets/Image.cpp b/src/renderer/widgets/Image.cpp
index cf416df..f2d475f 100644
--- a/src/renderer/widgets/Image.cpp
+++ b/src/renderer/widgets/Image.cpp
@@ -52,7 +52,7 @@ void CImage::onTimerUpdate() {
     if (!pendingResourceID.empty())
         return;
 
-    request.id        = std::string{"image:"} + path + ",time:" + std::to_string(modificationTime.time_since_epoch().count());
+    request.id        = std::string{"image:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
     pendingResourceID = request.id;
     request.asset     = path;
     request.type      = CAsyncResourceGatherer::eTargetType::TARGET_IMAGE;

commit 10ebbe6e5b8c60aaacdc3b1f2e25874c6c2105c8
Author: Daniel Mensinger <daniel@mensinger-ka.de>
Date:   Wed Apr 24 19:06:14 2024 +0200

    core: Add support for JPEG and WEBP background images (#286)
    
    * Add KDevelop files to the .gitignore
    
    * Add support for JPEG and WEBP background images
    
    Most of the code is copy-pasted from hyprpaper
    
    * Try doing nix stuff
    
    * Do not use brackets for short ifs

diff --git a/.gitignore b/.gitignore
index 03bade0..068ac23 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,3 +6,4 @@ build/
 compile_commands.json
 protocols/*.c
 protocols/*.h
+*.kdev4
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3cc75f1..9246428 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -35,7 +35,7 @@ message(STATUS "Checking deps...")
 find_package(Threads REQUIRED)
 find_package(PkgConfig REQUIRED)
 find_package(OpenGL REQUIRED)
-pkg_check_modules(deps REQUIRED IMPORTED_TARGET wayland-client wayland-protocols wayland-egl hyprlang>=0.4.0 egl opengl xkbcommon cairo pangocairo libdrm gbm)
+pkg_check_modules(deps REQUIRED IMPORTED_TARGET wayland-client wayland-protocols wayland-egl hyprlang>=0.4.0 egl opengl xkbcommon libjpeg libwebp libmagic cairo pangocairo libdrm gbm)
 
 file(GLOB_RECURSE SRCFILES CONFIGURE_DEPENDS "src/*.cpp")
 add_executable(hyprlock ${SRCFILES})
diff --git a/nix/default.nix b/nix/default.nix
index 0cc8496..211a7dc 100644
--- a/nix/default.nix
+++ b/nix/default.nix
@@ -4,8 +4,11 @@
   cmake,
   pkg-config,
   cairo,
+  file,
   libdrm,
   libGL,
+  libjpeg,
+  libwebp,
   libxkbcommon,
   mesa,
   hyprlang,
@@ -33,8 +36,11 @@ stdenv.mkDerivation {
 
   buildInputs = [
     cairo
+    file
     libdrm
     libGL
+    libjpeg
+    libwebp
     libxkbcommon
     mesa
     hyprlang
diff --git a/src/helpers/Jpeg.cpp b/src/helpers/Jpeg.cpp
new file mode 100644
index 0000000..c9ad08d
--- /dev/null
+++ b/src/helpers/Jpeg.cpp
@@ -0,0 +1,75 @@
+#include "Jpeg.hpp"
+#include "Log.hpp"
+
+#include <jpeglib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+cairo_surface_t* JPEG::createSurfaceFromJPEG(const std::filesystem::path& path) {
+
+    if (!std::filesystem::exists(path)) {
+        Debug::log(ERR, "createSurfaceFromJPEG: file doesn't exist??");
+        return nullptr;
+    }
+
+    if (__BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__) {
+        Debug::log(CRIT, "tried to load a jpeg on a big endian system! ping vaxry he is lazy.");
+        return nullptr;
+    }
+
+    void*       imageRawData;
+    struct stat fileInfo = {};
+    const auto  FD       = open(path.c_str(), O_RDONLY);
+
+    fstat(FD, &fileInfo);
+
+    imageRawData = malloc(fileInfo.st_size);
+
+    read(FD, imageRawData, fileInfo.st_size);
+    close(FD);
+
+    // now the JPEG is in the memory
+
+    jpeg_decompress_struct decompressStruct = {};
+    jpeg_error_mgr         errorManager     = {};
+
+    decompressStruct.err = jpeg_std_error(&errorManager);
+    jpeg_create_decompress(&decompressStruct);
+    jpeg_mem_src(&decompressStruct, (const unsigned char*)imageRawData, fileInfo.st_size);
+    jpeg_read_header(&decompressStruct, true);
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    decompressStruct.out_color_space = JCS_EXT_BGRA;
+#else
+    decompressStruct.out_color_space = JCS_EXT_ARGB;
+#endif
+
+    // decompress
+    jpeg_start_decompress(&decompressStruct);
+
+    auto cairoSurface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, decompressStruct.output_width, decompressStruct.output_height);
+
+    if (cairo_surface_status(cairoSurface) != CAIRO_STATUS_SUCCESS) {
+        Debug::log(ERR, "createSurfaceFromJPEG: Cairo Failed (?)");
+        return nullptr;
+    }
+
+    const auto CAIRODATA   = cairo_image_surface_get_data(cairoSurface);
+    const auto CAIROSTRIDE = cairo_image_surface_get_stride(cairoSurface);
+    JSAMPROW   rowRead;
+
+    while (decompressStruct.output_scanline < decompressStruct.output_height) {
+        const auto PROW = CAIRODATA + (decompressStruct.output_scanline * CAIROSTRIDE);
+        rowRead         = PROW;
+        jpeg_read_scanlines(&decompressStruct, &rowRead, 1);
+    }
+
+    cairo_surface_mark_dirty(cairoSurface);
+    cairo_surface_set_mime_data(cairoSurface, CAIRO_MIME_TYPE_JPEG, (const unsigned char*)imageRawData, fileInfo.st_size, free, imageRawData);
+    jpeg_finish_decompress(&decompressStruct);
+    jpeg_destroy_decompress(&decompressStruct);
+
+    return cairoSurface;
+}
diff --git a/src/helpers/Jpeg.hpp b/src/helpers/Jpeg.hpp
new file mode 100644
index 0000000..58a6e8b
--- /dev/null
+++ b/src/helpers/Jpeg.hpp
@@ -0,0 +1,8 @@
+#pragma once
+
+#include <filesystem>
+#include <cairo/cairo.h>
+
+namespace JPEG {
+    cairo_surface_t* createSurfaceFromJPEG(const std::filesystem::path&);
+};
diff --git a/src/helpers/Webp.cpp b/src/helpers/Webp.cpp
new file mode 100644
index 0000000..08d1ada
--- /dev/null
+++ b/src/helpers/Webp.cpp
@@ -0,0 +1,85 @@
+#include "Webp.hpp"
+#include "Log.hpp"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <webp/decode.h>
+
+cairo_surface_t* WEBP::createSurfaceFromWEBP(const std::filesystem::path& path) {
+
+    if (!std::filesystem::exists(path)) {
+        Debug::log(ERR, "createSurfaceFromWEBP: file doesn't exist??");
+        return nullptr;
+    }
+
+    void* imageRawData;
+
+    struct stat fileInfo = {};
+
+    const auto FD = open(path.c_str(), O_RDONLY);
+
+    fstat(FD, &fileInfo);
+
+    imageRawData = malloc(fileInfo.st_size);
+
+    read(FD, imageRawData, fileInfo.st_size);
+    close(FD);
+
+    // now the WebP is in the memory
+
+    WebPDecoderConfig config;
+    if (!WebPInitDecoderConfig(&config)) {
+        Debug::log(CRIT, "WebPInitDecoderConfig Failed");
+        return nullptr;
+    }
+
+    if (WebPGetFeatures((const unsigned char*)imageRawData, fileInfo.st_size, &config.input) != VP8_STATUS_OK) {
+        Debug::log(ERR, "createSurfaceFromWEBP: file is not webp format");
+        free(imageRawData);
+        return nullptr;
+    }
+
+    const auto HEIGHT = config.input.height;
+    const auto WIDTH = config.input.width;
+
+    auto cairoSurface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, WIDTH, HEIGHT);
+    if (cairo_surface_status(cairoSurface) != CAIRO_STATUS_SUCCESS) {
+        Debug::log(CRIT, "createSurfaceFromWEBP: Cairo Failed (?)");
+        cairo_surface_destroy(cairoSurface);
+        return nullptr;
+    }
+
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    config.output.colorspace = MODE_bgrA;
+#else
+    config.output.colorspace = MODE_Argb;
+#endif
+
+    const auto CAIRODATA = cairo_image_surface_get_data(cairoSurface);
+    const auto CAIROSTRIDE = cairo_image_surface_get_stride(cairoSurface);
+
+    config.options.no_fancy_upsampling = 1;
+    config.output.u.RGBA.rgba = CAIRODATA;
+    config.output.u.RGBA.stride = CAIROSTRIDE;
+    config.output.u.RGBA.size = CAIROSTRIDE * HEIGHT;
+    config.output.is_external_memory = 1;
+    config.output.width = WIDTH;
+    config.output.height = HEIGHT;
+
+    if (WebPDecode((const unsigned char*)imageRawData, fileInfo.st_size, &config) != VP8_STATUS_OK) {
+        Debug::log(CRIT, "createSurfaceFromWEBP: WebP Decode Failed (?)");
+        return nullptr;
+    }
+
+    cairo_surface_mark_dirty(cairoSurface);
+    cairo_surface_set_mime_data(cairoSurface, CAIRO_MIME_TYPE_PNG, (const unsigned char*)imageRawData, fileInfo.st_size, free, imageRawData);
+
+    WebPFreeDecBuffer(&config.output);
+
+    return cairoSurface;
+
+}
diff --git a/src/helpers/Webp.hpp b/src/helpers/Webp.hpp
new file mode 100644
index 0000000..3fc4790
--- /dev/null
+++ b/src/helpers/Webp.hpp
@@ -0,0 +1,8 @@
+#pragma once
+
+#include <filesystem>
+#include <cairo/cairo.h>
+
+namespace WEBP {
+    cairo_surface_t* createSurfaceFromWEBP(const std::filesystem::path&);
+};
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 914292e..1859774 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -2,10 +2,14 @@
 #include "../config/ConfigManager.hpp"
 #include "../core/Egl.hpp"
 #include <cairo/cairo.h>
+#include <magic.h>
 #include <pango/pangocairo.h>
 #include <algorithm>
+#include <filesystem>
 #include "../core/hyprlock.hpp"
 #include "../helpers/MiscFunctions.hpp"
+#include "../helpers/Jpeg.hpp"
+#include "../helpers/Webp.hpp"
 
 std::mutex cvmtx;
 
@@ -105,6 +109,13 @@ SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {
     return nullptr;
 }
 
+enum class FileType {
+    PNG,
+    JPEG,
+    WEBP,
+    UNKNOWN,
+};
+
 void CAsyncResourceGatherer::gather() {
     const auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
 
@@ -131,11 +142,50 @@ void CAsyncResourceGatherer::gather() {
             if (path.empty() || path == "screenshot")
                 continue;
 
-            std::string id           = (c.type == "background" ? std::string{"background:"} : std::string{"image:"}) + path;
-            const auto  ABSOLUTEPATH = absolutePath(path, "");
+            std::string           id = (c.type == "background" ? std::string{"background:"} : std::string{"image:"}) + path;
+            std::filesystem::path ABSOLUTEPATH(absolutePath(path, ""));
+
+            // determine the file type
+            std::string ext = ABSOLUTEPATH.extension().string();
+            // convert the extension to lower case
+            std::transform(ext.begin(), ext.end(), ext.begin(), [](char c) { return c <= 'Z' && c >= 'A' ? c - ('Z' - 'z') : c; });
+
+            FileType ft = FileType::UNKNOWN;
+            Debug::log(WARN, "Extension: {}", ext);
+            if (ext == ".png")
+                ft = FileType::PNG;
+            else if (ext == ".jpg" || ext == ".jpeg")
+                ft = FileType::JPEG;
+            else if (ext == ".webp")
+                ft = FileType::WEBP;
+            else {
+                // magic is slow, so only use it when no recognized extension is found
+                auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS);
+                magic_load(handle, nullptr);
+
+                const auto type_str   = std::string(magic_file(handle, path.c_str()));
+                const auto first_word = type_str.substr(0, type_str.find(" "));
+                magic_close(handle);
+
+                if (first_word == "PNG")
+                    ft = FileType::PNG;
+                else if (first_word == "JPEG")
+                    ft = FileType::JPEG;
+                else if (first_word == "RIFF" && type_str.find("Web/P image") != std::string::npos)
+                    ft = FileType::WEBP;
+            }
 
             // preload bg img
-            const auto CAIROISURFACE = cairo_image_surface_create_from_png(ABSOLUTEPATH.c_str());
+            cairo_surface_t* CAIROISURFACE = nullptr;
+            switch (ft) {
+                case FileType::PNG: CAIROISURFACE = cairo_image_surface_create_from_png(ABSOLUTEPATH.c_str()); break;
+                case FileType::JPEG: CAIROISURFACE = JPEG::createSurfaceFromJPEG(ABSOLUTEPATH); break;
+                case FileType::WEBP: CAIROISURFACE = WEBP::createSurfaceFromWEBP(ABSOLUTEPATH); break;
+                default: Debug::log(ERR, "unrecognized image format of {}", path.c_str()); continue;
+            }
+
+            if (CAIROISURFACE == nullptr)
+                continue;
 
             const auto CAIRO = cairo_create(CAIROISURFACE);
             cairo_scale(CAIRO, 1, 1);

commit 1413923880e338be7c32da9e555201af51cf8661
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu May 2 15:17:04 2024 +0100

    core: update renderer on late scale changes
    
    ref https://github.com/hyprwm/Hyprland/issues/5842, in case a compositor sends the scale after configure

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index d0acd5f..8446354 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -17,6 +17,9 @@ static void handlePreferredScale(void* data, wp_fractional_scale_v1* wp_fraction
     const auto PSURF       = (CSessionLockSurface*)data;
     PSURF->fractionalScale = scale / 120.0;
     Debug::log(LOG, "got fractional {}", PSURF->fractionalScale);
+
+    if (PSURF->readyForFrame)
+        PSURF->onScaleUpdate();
 }
 
 static const wp_fractional_scale_v1_listener fsListener = {
@@ -103,6 +106,10 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     render();
 }
 
+void CSessionLockSurface::onScaleUpdate() {
+    configure(size, serial);
+}
+
 static void handleDone(void* data, wl_callback* wl_callback, uint32_t callback_data) {
     const auto PSURF = (CSessionLockSurface*)data;
 
diff --git a/src/core/LockSurface.hpp b/src/core/LockSurface.hpp
index 2f93521..046b971 100644
--- a/src/core/LockSurface.hpp
+++ b/src/core/LockSurface.hpp
@@ -24,6 +24,7 @@ class CSessionLockSurface {
 
     void  render();
     void  onCallback();
+    void  onScaleUpdate();
 
   private:
     COutput*                     output      = nullptr;

commit d45c670767933ed4774d7d368252cfc233a29a0d
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu May 2 15:18:17 2024 +0100

    core: avoid sending duplicate acks for ls

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 8446354..853356d 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -69,13 +69,16 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
 void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     Debug::log(LOG, "configure with serial {}", serial_);
 
+    const bool sameSerial = serial == serial_;
+
     serial      = serial_;
     size        = (size_ * fractionalScale).floor();
     logicalSize = size_;
 
     Debug::log(LOG, "Configuring surface for logical {} and pixel {}", logicalSize, size);
 
-    ext_session_lock_surface_v1_ack_configure(lockSurface, serial);
+    if (!sameSerial)
+        ext_session_lock_surface_v1_ack_configure(lockSurface, serial);
 
     if (fractional)
         wp_viewport_set_destination(viewport, logicalSize.x, logicalSize.y);

commit cc1e0558896ff048d22c161cf507e483c32402cb
Author: Vaxry <vaxry@vaxry.net>
Date:   Fri May 3 13:21:51 2024 +0100

    session-lock: use logicalSize in late configure
    
    ooops
    
    ref #303

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 853356d..755269e 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -110,7 +110,7 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
 }
 
 void CSessionLockSurface::onScaleUpdate() {
-    configure(size, serial);
+    configure(logicalSize, serial);
 }
 
 static void handleDone(void* data, wl_callback* wl_callback, uint32_t callback_data) {

commit 822bea38872195536d9955da56393de5bf1e6639
Author: Yoni Firroloni <pro@yoni-firroloni.com>
Date:   Fri May 3 02:22:48 2024 +0000

    readme: add new line for clarity

diff --git a/README.md b/README.md
index d1b01fa..ecfda76 100644
--- a/README.md
+++ b/README.md
@@ -29,6 +29,7 @@ And the development libraries for the following
 - xkbcommon
 - pam
 - hyprlang >= 0.4
+
 Development libraries are usually suffixed with `-devel` or `-dev` in most distro repos.
 
 You also need to install `mesa-libgbm-devel` on some distros like RPM based ones where its not

commit 7dde20b7d1df8c0507c3a664c1022b227a2598e2
Author: Antonio Cheong <teapotv8@proton.me>
Date:   Fri May 3 23:11:56 2024 +0000

    README: add libmagic dependency (#307)

diff --git a/README.md b/README.md
index ecfda76..24beccf 100644
--- a/README.md
+++ b/README.md
@@ -29,6 +29,7 @@ And the development libraries for the following
 - xkbcommon
 - pam
 - hyprlang >= 0.4
+- libmagic (file-devel on Fedora)
 
 Development libraries are usually suffixed with `-devel` or `-dev` in most distro repos.
 

commit bab77a37a08324d2c638a28581d22f98fd1cbbb3
Author: davc0n <dconti.dev@gmail.com>
Date:   Sat May 4 17:18:27 2024 +0000

    renderer: add text trim with option to disable (#310)
    
    * renderer: add text trim with option to disable
    
    * refactor: format CAsyncResourceGatherer::renderText
    
    * config: change disable_text_trim to text_trim

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index d4d0f50..fe60f91 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -44,6 +44,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue(name, "shadow_boost", Hyprlang::FLOAT{1.2});
 
     m_config.addConfigValue("general:disable_loading_bar", Hyprlang::INT{0});
+    m_config.addConfigValue("general:text_trim", Hyprlang::INT{1});
     m_config.addConfigValue("general:hide_cursor", Hyprlang::INT{0});
     m_config.addConfigValue("general:grace", Hyprlang::INT{0});
     m_config.addConfigValue("general:no_fade_in", Hyprlang::INT{0});
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 1859774..2aa5c99 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -277,14 +277,21 @@ void CAsyncResourceGatherer::renderText(const SPreloadRequest& rq) {
     target.type = TARGET_IMAGE; /* text is just an image lol */
     target.id   = rq.id;
 
-    const int         FONTSIZE   = rq.props.contains("font_size") ? std::any_cast<int>(rq.props.at("font_size")) : 16;
-    const CColor      FONTCOLOR  = rq.props.contains("color") ? std::any_cast<CColor>(rq.props.at("color")) : CColor(1.0, 1.0, 1.0, 1.0);
-    const std::string FONTFAMILY = rq.props.contains("font_family") ? std::any_cast<std::string>(rq.props.at("font_family")) : "Sans";
-    const bool        ISCMD      = rq.props.contains("cmd") ? std::any_cast<bool>(rq.props.at("cmd")) : false;
-    const std::string TEXT       = ISCMD ? g_pHyprlock->spawnSync(rq.asset) : rq.asset;
-
-    auto              CAIROSURFACE = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1920, 1080 /* dummy value */);
-    auto              CAIRO        = cairo_create(CAIROSURFACE);
+    const int          FONTSIZE   = rq.props.contains("font_size") ? std::any_cast<int>(rq.props.at("font_size")) : 16;
+    const CColor       FONTCOLOR  = rq.props.contains("color") ? std::any_cast<CColor>(rq.props.at("color")) : CColor(1.0, 1.0, 1.0, 1.0);
+    const std::string  FONTFAMILY = rq.props.contains("font_family") ? std::any_cast<std::string>(rq.props.at("font_family")) : "Sans";
+    const bool         ISCMD      = rq.props.contains("cmd") ? std::any_cast<bool>(rq.props.at("cmd")) : false;
+
+    static auto* const TRIM = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:text_trim");
+    std::string        TEXT = ISCMD ? g_pHyprlock->spawnSync(rq.asset) : rq.asset;
+
+    if (**TRIM) {
+        TEXT.erase(0, TEXT.find_first_not_of(" \n\r\t"));
+        TEXT.erase(TEXT.find_last_not_of(" \n\r\t") + 1);
+    }
+
+    auto CAIROSURFACE = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1920, 1080 /* dummy value */);
+    auto CAIRO        = cairo_create(CAIROSURFACE);
 
     // draw title using Pango
     PangoLayout*          layout = pango_cairo_create_layout(CAIRO);

commit b8f9bb310f8d833d83446f77a6ea5383224c095a
Author: bvr-yr <bvr.yr.b@gmail.com>
Date:   Sun May 12 12:28:59 2024 +0300

    gatherer: use absolute path in magic guess

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 2aa5c99..70f9ec8 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -163,7 +163,7 @@ void CAsyncResourceGatherer::gather() {
                 auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS);
                 magic_load(handle, nullptr);
 
-                const auto type_str   = std::string(magic_file(handle, path.c_str()));
+                const auto type_str   = std::string(magic_file(handle, ABSOLUTEPATH.c_str()));
                 const auto first_word = type_str.substr(0, type_str.find(" "));
                 magic_close(handle);
 

commit 3276e6b89d5ef3d401a28ae622bc37004c11efbd
Author: Daniel Horton <dhorton8443@gmail.com>
Date:   Mon May 13 15:21:54 2024 +0100

    readme: Fixed getconf command in build instructions (#326)
    
    getconf NPROCESSORS_CONF isn't a valid command. The correct command is getconf _NPROCESSORS_CONF.

diff --git a/README.md b/README.md
index 24beccf..45d886e 100644
--- a/README.md
+++ b/README.md
@@ -41,7 +41,7 @@ bundled with the mesa package.
 Building:
 ```sh
 cmake --no-warn-unused-cli -DCMAKE_BUILD_TYPE:STRING=Release -S . -B ./build
-cmake --build ./build --config Release --target hyprlock -j`nproc 2>/dev/null || getconf NPROCESSORS_CONF`
+cmake --build ./build --config Release --target hyprlock -j`nproc 2>/dev/null || getconf _NPROCESSORS_CONF`
 ```
 
 Installation:

commit 3b7f8c34e4d273d1228612c37c55917928f97932
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Tue May 14 17:11:45 2024 +0200

    core: add key repeat for backspace and make del clear the input (#277)
    
    * core: add support for repeating backspace when held
    
    * core: move keysym handling to a seperate function in order to reuse it for key repeat
    
    * core: get keyboard repeat info from wayland
    
    * core: defaults for keyboard repeat and delay

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 61485ec..ba157c5 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -695,7 +695,8 @@ static void handleKeyboardModifiers(void* data, wl_keyboard* wl_keyboard, uint s
 }
 
 static void handleRepeatInfo(void* data, struct wl_keyboard* wl_keyboard, int32_t rate, int32_t delay) {
-    ;
+    g_pHyprlock->m_iKeebRepeatRate  = rate;
+    g_pHyprlock->m_iKeebRepeatDelay = delay;
 }
 
 inline const wl_keyboard_listener keyboardListener = {
@@ -793,6 +794,35 @@ void CHyprlock::renderOutput(const std::string& stringPort) {
     PMONITOR->sessionLockSurface->render();
 }
 
+void CHyprlock::startKeyRepeat(xkb_keysym_t sym) {
+    if (m_pKeyRepeatTimer) {
+        m_pKeyRepeatTimer->cancel();
+        m_pKeyRepeatTimer.reset();
+    }
+
+    if (m_iKeebRepeatDelay <= 0)
+        return;
+
+    m_pKeyRepeatTimer = addTimer(
+        std::chrono::milliseconds(m_iKeebRepeatDelay), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
+}
+
+void CHyprlock::repeatKey(xkb_keysym_t sym) {
+    if (m_iKeebRepeatRate <= 0)
+        return;
+
+    handleKeySym(sym);
+
+    // This condition is for backspace and delete keys, but should also be ok for other keysyms since our buffer won't be empty anyways
+    if (bool CONTINUE = m_sPasswordState.passBuffer.length() > 0; CONTINUE)
+        m_pKeyRepeatTimer = addTimer(
+            std::chrono::milliseconds(m_iKeebRepeatRate), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
+
+    for (auto& o : m_vOutputs) {
+        o->sessionLockSurface->render();
+    }
+}
+
 void CHyprlock::onKey(uint32_t key, bool down) {
     if (m_bFadeStarted)
         return;
@@ -812,8 +842,13 @@ void CHyprlock::onKey(uint32_t key, bool down) {
 
     if (down)
         m_vPressedKeys.push_back(key);
-    else
+    else {
         std::erase(m_vPressedKeys, key);
+        if (m_pKeyRepeatTimer) {
+            m_pKeyRepeatTimer->cancel();
+            m_pKeyRepeatTimer.reset();
+        }
+    }
 
     if (g_pAuth->checkWaiting()) {
         for (auto& o : m_vOutputs) {
@@ -829,42 +864,49 @@ void CHyprlock::onKey(uint32_t key, bool down) {
         m_bNumLock  = xkb_state_mod_name_is_active(g_pHyprlock->m_pXKBState, XKB_MOD_NAME_NUM, XKB_STATE_MODS_LOCKED);
         m_bCtrl     = xkb_state_mod_name_is_active(m_pXKBState, XKB_MOD_NAME_CTRL, XKB_STATE_MODS_EFFECTIVE);
 
-        if (SYM == XKB_KEY_Escape || (m_bCtrl && (SYM == XKB_KEY_u || SYM == XKB_KEY_BackSpace))) {
-            Debug::log(LOG, "Clearing password buffer");
+        handleKeySym(SYM);
+        if (SYM == XKB_KEY_BackSpace || SYM == XKB_KEY_Delete) // keys allowed to repeat
+            startKeyRepeat(SYM);
+    }
 
-            m_sPasswordState.passBuffer = "";
-        } else if (SYM == XKB_KEY_Return || SYM == XKB_KEY_KP_Enter) {
-            Debug::log(LOG, "Authenticating");
+    for (auto& o : m_vOutputs) {
+        o->sessionLockSurface->render();
+    }
+}
 
-            static auto* const PIGNOREEMPTY = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:ignore_empty_input");
+void CHyprlock::handleKeySym(xkb_keysym_t sym) {
+    const auto SYM = sym;
+    if (SYM == XKB_KEY_Escape || (m_bCtrl && (SYM == XKB_KEY_u || SYM == XKB_KEY_BackSpace))) {
+        Debug::log(LOG, "Clearing password buffer");
 
-            if (m_sPasswordState.passBuffer.empty() && **PIGNOREEMPTY) {
-                Debug::log(LOG, "Ignoring empty input");
-                return;
-            }
+        m_sPasswordState.passBuffer = "";
+    } else if (SYM == XKB_KEY_Return || SYM == XKB_KEY_KP_Enter) {
+        Debug::log(LOG, "Authenticating");
 
-            g_pAuth->submitInput(m_sPasswordState.passBuffer);
-        } else if (SYM == XKB_KEY_BackSpace) {
-            if (m_sPasswordState.passBuffer.length() > 0) {
-                // handle utf-8
-                while ((m_sPasswordState.passBuffer.back() & 0xc0) == 0x80)
-                    m_sPasswordState.passBuffer.pop_back();
-                m_sPasswordState.passBuffer = m_sPasswordState.passBuffer.substr(0, m_sPasswordState.passBuffer.length() - 1);
-            }
-        } else if (SYM == XKB_KEY_Caps_Lock) {
-            m_bCapsLock = !m_bCapsLock;
-        } else if (SYM == XKB_KEY_Num_Lock) {
-            m_bNumLock = !m_bNumLock;
-        } else {
-            char buf[16] = {0};
-            int  len     = xkb_keysym_to_utf8(SYM, buf, 16);
-            if (len > 1)
-                m_sPasswordState.passBuffer += std::string{buf, len - 1};
+        static auto* const PIGNOREEMPTY = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:ignore_empty_input");
+
+        if (m_sPasswordState.passBuffer.empty() && **PIGNOREEMPTY) {
+            Debug::log(LOG, "Ignoring empty input");
+            return;
         }
-    }
 
-    for (auto& o : m_vOutputs) {
-        o->sessionLockSurface->render();
+        g_pAuth->submitInput(m_sPasswordState.passBuffer);
+    } else if (SYM == XKB_KEY_BackSpace || SYM == XKB_KEY_Delete) {
+        if (m_sPasswordState.passBuffer.length() > 0) {
+            // handle utf-8
+            while ((m_sPasswordState.passBuffer.back() & 0xc0) == 0x80)
+                m_sPasswordState.passBuffer.pop_back();
+            m_sPasswordState.passBuffer = m_sPasswordState.passBuffer.substr(0, m_sPasswordState.passBuffer.length() - 1);
+        }
+    } else if (SYM == XKB_KEY_Caps_Lock) {
+        m_bCapsLock = !m_bCapsLock;
+    } else if (SYM == XKB_KEY_Num_Lock) {
+        m_bNumLock = !m_bNumLock;
+    } else {
+        char buf[16] = {0};
+        int  len     = xkb_keysym_to_utf8(SYM, buf, 16);
+        if (len > 1)
+            m_sPasswordState.passBuffer += std::string{buf, len - 1};
     }
 }
 
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index a24df22..192c286 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -54,6 +54,9 @@ class CHyprlock {
     std::string                     spawnSync(const std::string& cmd);
 
     void                            onKey(uint32_t key, bool down);
+    void                            handleKeySym(xkb_keysym_t sym);
+    void                            startKeyRepeat(xkb_keysym_t sym);
+    void                            repeatKey(xkb_keysym_t sym);
     void                            onPasswordCheckTimer();
     void                            clearPasswordBuffer();
     bool                            passwordCheckWaiting();
@@ -82,6 +85,9 @@ class CHyprlock {
     xkb_keymap*                     m_pXKBKeymap  = nullptr;
     xkb_state*                      m_pXKBState   = nullptr;
 
+    int32_t                         m_iKeebRepeatRate  = 25;
+    int32_t                         m_iKeebRepeatDelay = 600;
+
     xkb_layout_index_t              m_uiActiveLayout = 0;
 
     bool                            m_bTerminate = false;
@@ -97,6 +103,8 @@ class CHyprlock {
     std::chrono::system_clock::time_point m_tFadeEnds;
     Vector2D                              m_vLastEnterCoords = {};
 
+    std::shared_ptr<CTimer>               m_pKeyRepeatTimer = nullptr;
+
     std::vector<std::unique_ptr<COutput>> m_vOutputs;
     std::vector<std::shared_ptr<CTimer>>  getTimers();
 

commit b00f274eb9adb8600ade46db5cc35506136c7d0b
Author: shezdy <77217897+shezdy@users.noreply.github.com>
Date:   Fri May 17 12:29:05 2024 -0600

    core: add zindex option to widgets (#334)
    
    * add zheight
    
    * move sort to renderer
    
    * fix format
    
    * change name to zindex

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index fe60f91..c42e574 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -63,6 +63,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("background", "brightness", Hyprlang::FLOAT{0.8172});
     m_config.addSpecialConfigValue("background", "vibrancy", Hyprlang::FLOAT{0.1686});
     m_config.addSpecialConfigValue("background", "vibrancy_darkness", Hyprlang::FLOAT{0.05});
+    m_config.addSpecialConfigValue("background", "zindex", Hyprlang::INT{-1});
 
     m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
     m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
@@ -76,6 +77,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("shape", "valign", Hyprlang::STRING{"center"});
     m_config.addSpecialConfigValue("shape", "rotate", Hyprlang::FLOAT{0});
     m_config.addSpecialConfigValue("shape", "xray", Hyprlang::INT{0});
+    m_config.addSpecialConfigValue("shape", "zindex", Hyprlang::INT{0});
     SHADOWABLE("shape");
 
     m_config.addSpecialCategory("image", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
@@ -91,6 +93,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("image", "rotate", Hyprlang::FLOAT{0});
     m_config.addSpecialConfigValue("image", "reload_time", Hyprlang::INT{-1});
     m_config.addSpecialConfigValue("image", "reload_cmd", Hyprlang::STRING{""});
+    m_config.addSpecialConfigValue("image", "zindex", Hyprlang::INT{0});
     SHADOWABLE("image");
 
     m_config.addSpecialCategory("input-field", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
@@ -121,6 +124,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("input-field", "bothlock_color", Hyprlang::INT{-1});
     m_config.addSpecialConfigValue("input-field", "invert_numlock", Hyprlang::INT{0});
     m_config.addSpecialConfigValue("input-field", "swap_font_color", Hyprlang::INT{0});
+    m_config.addSpecialConfigValue("input-field", "zindex", Hyprlang::INT{0});
     SHADOWABLE("input-field");
 
     m_config.addSpecialCategory("label", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
@@ -134,6 +138,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("label", "valign", Hyprlang::STRING{"none"});
     m_config.addSpecialConfigValue("label", "rotate", Hyprlang::FLOAT{0});
     m_config.addSpecialConfigValue("label", "text_align", Hyprlang::STRING{""});
+    m_config.addSpecialConfigValue("label", "zindex", Hyprlang::INT{0});
     SHADOWABLE("label");
 
     m_config.registerHandler(&::handleSource, "source", {false});
@@ -181,6 +186,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"vibrancy", m_config.getSpecialConfigValue("background", "vibrancy", k.c_str())},
                 {"brightness", m_config.getSpecialConfigValue("background", "brightness", k.c_str())},
                 {"vibrancy_darkness", m_config.getSpecialConfigValue("background", "vibrancy_darkness", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("background", "zindex", k.c_str())},
             }
         });
         // clang-format on
@@ -204,6 +210,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
                 {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
                 {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("shape", "zindex", k.c_str())},
                 SHADOWABLE("shape"),
             }
         });
@@ -229,6 +236,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"rotate", m_config.getSpecialConfigValue("image", "rotate", k.c_str())},
                 {"reload_time", m_config.getSpecialConfigValue("image", "reload_time", k.c_str())},
                 {"reload_cmd", m_config.getSpecialConfigValue("image", "reload_cmd", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("image", "zindex", k.c_str())},
                 SHADOWABLE("image"),
             }
         });
@@ -269,6 +277,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"bothlock_color", m_config.getSpecialConfigValue("input-field", "bothlock_color", k.c_str())},
                 {"invert_numlock", m_config.getSpecialConfigValue("input-field", "invert_numlock", k.c_str())},
                 {"swap_font_color", m_config.getSpecialConfigValue("input-field", "swap_font_color", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("input-field", "zindex", k.c_str())},
                 SHADOWABLE("input-field"),
             }
         });
@@ -291,6 +300,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
                 {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
                 {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("label", "zindex", k.c_str())},
                 SHADOWABLE("label"),
             }
         });
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index b1fdbf1..463f353 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -304,7 +304,11 @@ void CRenderer::renderTexture(const CBox& box, const CTexture& tex, float a, int
 std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CSessionLockSurface* surf) {
     if (!widgets.contains(surf)) {
 
-        const auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
+        auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
+
+        std::sort(CWIDGETS.begin(), CWIDGETS.end(), [](CConfigManager::SWidgetConfig& a, CConfigManager::SWidgetConfig& b) {
+            return std::any_cast<Hyprlang::INT>(a.values.at("zindex")) < std::any_cast<Hyprlang::INT>(b.values.at("zindex"));
+        });
 
         for (auto& c : CWIDGETS) {
             if (!c.monitor.empty() && c.monitor != surf->output->stringPort && !surf->output->stringDesc.starts_with(c.monitor))

commit 72b33c1182c52718c8e22ac0e305bd14631b000e
Author: giskard <rtgiskard@gmail.com>
Date:   Tue May 21 06:00:28 2024 +0800

    cmake: macro-prefix-map, compile_commands.json (#338)
    
    * cmake: position independent build for `__FILE__`
    
    * cmake: generate compile_commands.json, coder-friendly

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9246428..cfab691 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,6 +8,7 @@ project(hyprlock
 )
 
 set(CMAKE_MESSAGE_LOG_LEVEL "STATUS")
+set(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)
 
 if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES DEBUG)
     message(STATUS "Configuring hyprlock in Debug with CMake")
@@ -27,7 +28,10 @@ include(GNUInstallDirs)
 # configure
 set(CMAKE_CXX_STANDARD 23)
 add_compile_options(-Wall -Wextra -Wno-unused-parameter -Wno-unused-value
-	-Wno-missing-field-initializers -Wno-narrowing)
+    -Wno-missing-field-initializers -Wno-narrowing)
+
+# position independent build: __FILE__
+add_compile_options(-fmacro-prefix-map=${CMAKE_SOURCE_DIR}/=)
 
 # dependencies
 message(STATUS "Checking deps...")

commit 267ed3c36c379f2907c80a05cd80632d024ab42d
Author: Vaxry <vaxry@vaxry.net>
Date:   Thu May 23 12:58:54 2024 +0200

    restore: move to runtime dir and check his
    
    fixes #346

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index ba157c5..2325666 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -1083,10 +1083,16 @@ void CHyprlock::attemptRestoreOnDeath() {
     if (m_bTerminate)
         return;
 
+    const auto XDG_RUNTIME_DIR = getenv("XDG_RUNTIME_DIR");
+    const auto HIS             = getenv("HYPRLAND_INSTANCE_SIGNATURE");
+
+    if (!XDG_RUNTIME_DIR || !HIS)
+        return;
+
     // dirty hack
-    uint64_t              timeNowMs = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - std::chrono::system_clock::from_time_t({0})).count();
+    uint64_t   timeNowMs = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - std::chrono::system_clock::from_time_t({0})).count();
 
-    constexpr const char* LASTRESTARTPATH = "/tmp/hypr/.hyprlockrestart";
+    const auto LASTRESTARTPATH = std::string{XDG_RUNTIME_DIR} + "/.hyprlockrestart";
 
     if (std::filesystem::exists(LASTRESTARTPATH)) {
         std::ifstream ifs(LASTRESTARTPATH);
diff --git a/src/helpers/Webp.cpp b/src/helpers/Webp.cpp
index 08d1ada..c42047f 100644
--- a/src/helpers/Webp.cpp
+++ b/src/helpers/Webp.cpp
@@ -15,11 +15,11 @@ cairo_surface_t* WEBP::createSurfaceFromWEBP(const std::filesystem::path& path)
         return nullptr;
     }
 
-    void* imageRawData;
+    void*       imageRawData;
 
     struct stat fileInfo = {};
 
-    const auto FD = open(path.c_str(), O_RDONLY);
+    const auto  FD = open(path.c_str(), O_RDONLY);
 
     fstat(FD, &fileInfo);
 
@@ -43,32 +43,31 @@ cairo_surface_t* WEBP::createSurfaceFromWEBP(const std::filesystem::path& path)
     }
 
     const auto HEIGHT = config.input.height;
-    const auto WIDTH = config.input.width;
+    const auto WIDTH  = config.input.width;
 
-    auto cairoSurface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, WIDTH, HEIGHT);
+    auto       cairoSurface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, WIDTH, HEIGHT);
     if (cairo_surface_status(cairoSurface) != CAIRO_STATUS_SUCCESS) {
         Debug::log(CRIT, "createSurfaceFromWEBP: Cairo Failed (?)");
         cairo_surface_destroy(cairoSurface);
         return nullptr;
     }
 
-
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     config.output.colorspace = MODE_bgrA;
 #else
     config.output.colorspace = MODE_Argb;
 #endif
 
-    const auto CAIRODATA = cairo_image_surface_get_data(cairoSurface);
+    const auto CAIRODATA   = cairo_image_surface_get_data(cairoSurface);
     const auto CAIROSTRIDE = cairo_image_surface_get_stride(cairoSurface);
 
     config.options.no_fancy_upsampling = 1;
-    config.output.u.RGBA.rgba = CAIRODATA;
-    config.output.u.RGBA.stride = CAIROSTRIDE;
-    config.output.u.RGBA.size = CAIROSTRIDE * HEIGHT;
-    config.output.is_external_memory = 1;
-    config.output.width = WIDTH;
-    config.output.height = HEIGHT;
+    config.output.u.RGBA.rgba          = CAIRODATA;
+    config.output.u.RGBA.stride        = CAIROSTRIDE;
+    config.output.u.RGBA.size          = CAIROSTRIDE * HEIGHT;
+    config.output.is_external_memory   = 1;
+    config.output.width                = WIDTH;
+    config.output.height               = HEIGHT;
 
     if (WebPDecode((const unsigned char*)imageRawData, fileInfo.st_size, &config) != VP8_STATUS_OK) {
         Debug::log(CRIT, "createSurfaceFromWEBP: WebP Decode Failed (?)");
@@ -81,5 +80,4 @@ cairo_surface_t* WEBP::createSurfaceFromWEBP(const std::filesystem::path& path)
     WebPFreeDecBuffer(&config.output);
 
     return cairoSurface;
-
 }
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 463f353..08a15c9 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -204,7 +204,8 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
             bga = 1.0;
 
         if (g_pHyprlock->m_bFadeStarted && !**PNOFADEOUT) {
-            bga = std::clamp(std::chrono::duration_cast<std::chrono::microseconds>(g_pHyprlock->m_tFadeEnds - std::chrono::system_clock::now()).count() / 500000.0 - 0.02, 0.0, 1.0);
+            bga =
+                std::clamp(std::chrono::duration_cast<std::chrono::microseconds>(g_pHyprlock->m_tFadeEnds - std::chrono::system_clock::now()).count() / 500000.0 - 0.02, 0.0, 1.0);
             // - 0.02 so that the fade ends a little earlier than the final second
         }
         // render widgets

commit 0ba33e6a0751c96de581cb70a38c177c9a83e81f
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Sat May 25 20:05:37 2024 +0200

    core: fix a few reported leaks by asan (#349)
    
    * widgets: add missing virtual destructor
    
    destructor is missing and as a consequence all sub classes gets wrongly
    destructed reported as "new-delete-type-mismatch" by asan.
    
    * gatherer: free memory allocated by pango
    
    with pango_parse_markup its up to the caller of the function to free the
    pointer to the text returned stored in this buf.
    
    * core: add destructor and free devices
    
    add a destructor and free both drmDevice and gbmDevice, leaks reported
    by asan.
    
    * core: free xkb allocated state and keymap
    
    free xkb state and keymap on destruction to prevent leak on exit and
    less asan spam.
    
    * locksurface: destroy the surface frame on done
    
    the callback was never being destroyed and is leaking on each
    frameCallback creation, call wl_callback_destroy in onCallback() and
    free the memory. reported with asan.

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 755269e..3ffe2a4 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -142,6 +142,7 @@ void CSessionLockSurface::render() {
 }
 
 void CSessionLockSurface::onCallback() {
+    wl_callback_destroy(frameCallback);
     frameCallback = nullptr;
 
     if (needsFrame && !g_pHyprlock->m_bTerminate && g_pEGL)
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 2325666..d4c11d3 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -39,6 +39,17 @@ CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate) {
     }
 }
 
+CHyprlock::~CHyprlock() {
+    if (g_pHyprlock->dma.gbmDevice)
+        gbm_device_destroy(g_pHyprlock->dma.gbmDevice);
+
+    if (g_pHyprlock->m_pXKBState)
+        xkb_state_unref(g_pHyprlock->m_pXKBState);
+
+    if (g_pHyprlock->m_pXKBKeymap)
+        xkb_keymap_unref(g_pHyprlock->m_pXKBKeymap);
+}
+
 // wl_seat
 
 static void                   handleCapabilities(void* data, wl_seat* wl_seat, uint32_t capabilities);
@@ -82,6 +93,7 @@ static void dmabufFeedbackMainDevice(void* data, zwp_linux_dmabuf_feedback_v1* f
     }
 
     g_pHyprlock->dma.gbmDevice = g_pHyprlock->createGBMDevice(drmDev);
+    drmFreeDevice(&drmDev);
 }
 
 static void dmabufFeedbackFormatTable(void* data, zwp_linux_dmabuf_feedback_v1* feedback, int fd, uint32_t size) {
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 192c286..52344b9 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -29,6 +29,7 @@ struct SDMABUFModifier {
 class CHyprlock {
   public:
     CHyprlock(const std::string& wlDisplay, const bool immediate);
+    ~CHyprlock();
 
     void                            run();
 
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 70f9ec8..f7f46ee 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -326,6 +326,9 @@ void CAsyncResourceGatherer::renderText(const SPreloadRequest& rq) {
     if (!attrList)
         attrList = pango_attr_list_new();
 
+    if (buf)
+        free(buf);
+
     pango_attr_list_insert(attrList, pango_attr_scale_new(1));
     pango_layout_set_attributes(layout, attrList);
     pango_attr_list_unref(attrList);
diff --git a/src/renderer/widgets/IWidget.hpp b/src/renderer/widgets/IWidget.hpp
index ca1a519..8f65b79 100644
--- a/src/renderer/widgets/IWidget.hpp
+++ b/src/renderer/widgets/IWidget.hpp
@@ -8,6 +8,7 @@ class IWidget {
     struct SRenderData {
         float opacity = 1;
     };
+    virtual ~IWidget() = default;
 
     virtual bool     draw(const SRenderData& data) = 0;
 

commit fa9256732c9b53a8252a85127e839a87c916a60c
Author: Andr Silva <123550+andresilva@users.noreply.github.com>
Date:   Sun May 26 18:46:53 2024 +0200

    core: handle null timers in destructors (#350)

diff --git a/src/renderer/widgets/Image.cpp b/src/renderer/widgets/Image.cpp
index f2d475f..f5d1412 100644
--- a/src/renderer/widgets/Image.cpp
+++ b/src/renderer/widgets/Image.cpp
@@ -5,8 +5,10 @@
 #include <cmath>
 
 CImage::~CImage() {
-    imageTimer->cancel();
-    imageTimer.reset();
+    if (imageTimer) {
+        imageTimer->cancel();
+        imageTimer.reset();
+    }
 }
 
 static void onTimer(std::shared_ptr<CTimer> self, void* data) {
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index 11cf82d..79665b9 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -6,8 +6,10 @@
 #include "../../core/hyprlock.hpp"
 
 CLabel::~CLabel() {
-    labelTimer->cancel();
-    labelTimer.reset();
+    if (labelTimer) {
+        labelTimer->cancel();
+        labelTimer.reset();
+    }
 }
 
 static void onTimer(std::shared_ptr<CTimer> self, void* data) {

commit 4529a8b5f1652ee7106b25212b78145924374a1f
Author: Florian Walter <fw@florian-walter.ch>
Date:   Tue Jun 25 13:46:58 2024 +0200

     core: fix second instance of hyprlock unlocking session (#376)
    
    * fix second instance of hyprlock unlocking session
    
    * fix segfault when lock cannot be acquired
    
    * improve ordering of display roundtrips

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index d4c11d3..eedc963 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -926,6 +926,9 @@ void CHyprlock::acquireSessionLock() {
     Debug::log(LOG, "Locking session");
     m_sLockState.lock = ext_session_lock_manager_v1_lock(m_sWaylandState.sessionLock);
     ext_session_lock_v1_add_listener(m_sLockState.lock, &sessionLockListener, nullptr);
+
+    // wait for wayland to signal whether the session lock has been acquired
+    wl_display_roundtrip(m_sWaylandState.display);
 }
 
 void CHyprlock::releaseSessionLock() {
@@ -958,8 +961,8 @@ void CHyprlock::onLockLocked() {
 
 void CHyprlock::onLockFinished() {
     Debug::log(LOG, "onLockFinished called. Seems we got yeeten. Is another lockscreen running?");
-    ext_session_lock_v1_unlock_and_destroy(m_sLockState.lock);
-    m_sLockState.lock = nullptr;
+    g_pRenderer = nullptr;
+    exit(1);
 }
 
 ext_session_lock_manager_v1* CHyprlock::getSessionLockMgr() {

commit 80bc399c19d4a24146ea3bf4cb4d0db7a851d67a
Author: Jasson Cordones <Jasson.cordones@hotmail.com>
Date:   Tue Jun 25 14:09:52 2024 -0400

    core: Inproved error handling and arg parsing (#380)
    
    * Inproved error handling and arg parsing
    
    * Removed duplicated lines
    
    * Remove curly braces from short ifs, used c-style casts, used contains instead of find to parse exception, applied clang formating
    
    * Fix Formatting

diff --git a/src/main.cpp b/src/main.cpp
index 8bc156f..547b849 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,6 +1,7 @@
 
 #include "config/ConfigManager.hpp"
 #include "core/hyprlock.hpp"
+#include <cstddef>
 
 void help() {
     std::cout << "Usage: hyprlock [options]\n\n"
@@ -12,13 +13,26 @@ void help() {
                  "  --immediate              - Lock immediately, ignoring any configured grace period\n"
                  "  -h, --help               - Show this help message\n";
 }
+
+std::optional<std::string> parseArg(const std::vector<std::string>& args, const std::string& flag, std::size_t& i) {
+    if (i + 1 < args.size()) {
+        return args[++i];
+    } else {
+        std::cerr << "Error: Missing value for " << flag << " option.\n";
+        return std::nullopt;
+    }
+}
+
 int main(int argc, char** argv, char** envp) {
-    std::string configPath;
-    std::string wlDisplay;
-    bool        immediate = false;
+    std::string              configPath;
+    std::string              wlDisplay;
+    bool                     immediate = false;
+    bool                     showHelp  = false;
 
-    for (int i = 1; i < argc; ++i) {
-        std::string arg = argv[i];
+    std::vector<std::string> args(argv, argv + argc);
+
+    for (std::size_t i = 1; i < args.size(); ++i) {
+        const std::string arg = argv[i];
 
         if (arg == "--verbose" || arg == "-v")
             Debug::verbose = true;
@@ -26,33 +40,57 @@ int main(int argc, char** argv, char** envp) {
         else if (arg == "--quiet" || arg == "-q")
             Debug::quiet = true;
 
-        else if ((arg == "--config" || arg == "-c") && i + 1 < argc)
-            configPath = argv[++i];
+        else if ((arg == "--config" || arg == "-c") && i + 1 < (std::size_t)argc) {
+            if (auto value = parseArg(args, arg, i); value)
+                configPath = *value;
+            else
+                return 1;
+
+        } else if (arg == "--display" && i + 1 < (std::size_t)argc) {
+            if (auto value = parseArg(args, arg, i); value)
+                wlDisplay = *value;
+            else
+                return 1;
 
-        else if (arg == "--display" && i + 1 < argc) {
-            wlDisplay = argv[i + 1];
-            i++;
-        } else if (arg == "--immediate") {
+        } else if (arg == "--immediate")
             immediate = true;
-        } else if (arg == "--help" || arg == "-h") {
+
+        else if (arg == "--help" || arg == "-h") {
+            showHelp = true;
+            break;
+
+        } else {
+            std::cerr << "Unknown option: " << arg << "\n";
             help();
-            return 0;
+            return 1;
         }
     }
 
+    if (showHelp) {
+        help();
+        return 0;
+    }
+
     try {
-        g_pConfigManager = std::make_unique<CConfigManager>(configPath);
-        g_pConfigManager->init();
-    } catch (const char* err) {
-        Debug::log(CRIT, "ConfigManager threw: {}", err);
-        std::string strerr = err;
-        if (strerr.contains("File does not exist"))
+        auto configManager = std::make_unique<CConfigManager>(configPath);
+        configManager->init();
+        g_pConfigManager = std::move(configManager);
+    } catch (const std::exception& ex) {
+        Debug::log(CRIT, "ConfigManager threw: {}", ex.what());
+        if (std::string(ex.what()).contains("File does not exist"))
             Debug::log(NONE, "           Make sure you have a config.");
+
         return 1;
     }
 
-    g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate);
-    g_pHyprlock->run();
+    try {
+        auto hyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate);
+        g_pHyprlock   = std::move(hyprlock);
+        g_pHyprlock->run();
+    } catch (const std::exception& ex) {
+        Debug::log(CRIT, "Hyprlock threw: {}", ex.what());
+        return 1;
+    }
 
     return 0;
 }

commit dbe8883476f1c278c72258b917e4d9aa641e8bd8
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Jun 26 20:31:15 2024 +0200

    core: stabilize label updates and revision locking in the asyncResourceGatherer (#384)
    
    * core: handle rerendering when frameCallback is pending
    
    * core: log when skipping label updates
    
    * asyncResourceGatherer: remove busy and use loopMutex
    
    Makes getAssetById fail less often and thus labels get more stable
    updates
    
    * asyncResourceGatherer: revision locking
    
    `assetsMutex` was not needed, since `apply` only gets called from the
    main thread and resources are also only aquired via the main thread.
    
    `preloadTargets`, previously kinda guarded by the `busy` flag are now
    locked as suggested in #367 (but via a copy of `peloadTargets`).
    
    `apply` now returns a boolean so that the locking of preloadTargets in
    combination with checking `preloadTargets.empty()` is a bit nicer.
    
    * asyncResourceGatherer: remove explicit template arg for unique lock

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 3ffe2a4..beb522b 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -129,8 +129,10 @@ static const wl_callback_listener callbackListener = {
 void CSessionLockSurface::render() {
     Debug::log(TRACE, "render lock");
 
-    if (frameCallback || !readyForFrame)
+    if (frameCallback || !readyForFrame) {
+        needsFrame = true;
         return;
+    }
 
     const auto FEEDBACK = g_pRenderer->renderLock(*this);
     frameCallback       = wl_surface_frame(surface);
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index f7f46ee..465511c 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -11,8 +11,6 @@
 #include "../helpers/Jpeg.hpp"
 #include "../helpers/Webp.hpp"
 
-std::mutex cvmtx;
-
 CAsyncResourceGatherer::CAsyncResourceGatherer() {
     asyncLoopThread = std::thread([this]() {
         this->gather(); /* inital gather */
@@ -83,23 +81,17 @@ void CAsyncResourceGatherer::recheckDMAFramesFor(COutput* output) {
 }
 
 SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {
-    if (asyncLoopState.busy)
-        return nullptr;
-
-    std::lock_guard<std::mutex> lg(asyncLoopState.loopMutex);
-
     for (auto& a : assets) {
         if (a.first == id)
             return &a.second;
     }
 
-    if (!preloadTargets.empty()) {
-        apply();
+    if (apply()) {
         for (auto& a : assets) {
             if (a.first == id)
                 return &a.second;
         }
-    }
+    };
 
     for (auto& dma : dmas) {
         if (id == "dma:" + dma->name)
@@ -210,18 +202,27 @@ void CAsyncResourceGatherer::gather() {
     ready = true;
 }
 
-void CAsyncResourceGatherer::apply() {
+bool CAsyncResourceGatherer::apply() {
+    preloadTargetsMutex.lock();
+
+    if (preloadTargets.empty()) {
+        preloadTargetsMutex.unlock();
+        return false;
+    }
+
+    auto currentPreloadTargets = preloadTargets;
+    preloadTargets.clear();
+    preloadTargetsMutex.unlock();
 
-    for (auto& t : preloadTargets) {
+    for (auto& t : currentPreloadTargets) {
         if (t.type == TARGET_IMAGE) {
-            std::lock_guard<std::mutex> lg(asyncLoopState.assetsMutex);
-            const auto                  ASSET = &assets[t.id];
+            const auto  ASSET = &assets[t.id];
 
-            const auto                  SURFACESTATUS = cairo_surface_status((cairo_surface_t*)t.cairosurface);
-            const auto                  CAIROFORMAT   = cairo_image_surface_get_format((cairo_surface_t*)t.cairosurface);
-            const GLint                 glIFormat     = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_RGB32F : GL_RGBA;
-            const GLint                 glFormat      = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_RGB : GL_RGBA;
-            const GLint                 glType        = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_FLOAT : GL_UNSIGNED_BYTE;
+            const auto  SURFACESTATUS = cairo_surface_status((cairo_surface_t*)t.cairosurface);
+            const auto  CAIROFORMAT   = cairo_image_surface_get_format((cairo_surface_t*)t.cairosurface);
+            const GLint glIFormat     = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_RGB32F : GL_RGBA;
+            const GLint glFormat      = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_RGB : GL_RGBA;
+            const GLint glType        = CAIROFORMAT == CAIRO_FORMAT_RGB96F ? GL_FLOAT : GL_UNSIGNED_BYTE;
 
             if (SURFACESTATUS != CAIRO_STATUS_SUCCESS) {
                 Debug::log(ERR, "Resource {} invalid ({})", t.id, cairo_status_to_string(SURFACESTATUS));
@@ -248,9 +249,8 @@ void CAsyncResourceGatherer::apply() {
         }
     }
 
-    preloadTargets.clear();
-
     applied = true;
+    return true;
 }
 
 void CAsyncResourceGatherer::renderImage(const SPreloadRequest& rq) {
@@ -269,6 +269,7 @@ void CAsyncResourceGatherer::renderImage(const SPreloadRequest& rq) {
     target.data         = cairo_image_surface_get_data(CAIROISURFACE);
     target.size         = {(double)cairo_image_surface_get_width(CAIROISURFACE), (double)cairo_image_surface_get_height(CAIROISURFACE)};
 
+    std::lock_guard lg{preloadTargetsMutex};
     preloadTargets.push_back(target);
 }
 
@@ -363,6 +364,7 @@ void CAsyncResourceGatherer::renderText(const SPreloadRequest& rq) {
     target.data         = cairo_image_surface_get_data(CAIROSURFACE);
     target.size         = {layoutWidth / PANGO_SCALE, layoutHeight / PANGO_SCALE};
 
+    std::lock_guard lg{preloadTargetsMutex};
     preloadTargets.push_back(target);
 }
 
@@ -380,27 +382,23 @@ static void timerCallback(std::shared_ptr<CTimer> self, void* data_) {
 void CAsyncResourceGatherer::asyncAssetSpinLock() {
     while (!g_pHyprlock->m_bTerminate) {
 
-        std::unique_lock lk(cvmtx);
+        std::unique_lock lk(asyncLoopState.requestsMutex);
         if (asyncLoopState.pending == false) // avoid a lock if a thread managed to request something already since we .unlock()ed
-            asyncLoopState.loopGuard.wait_for(lk, std::chrono::seconds(5), [this] { return asyncLoopState.pending; }); // wait for events
-
-        asyncLoopState.requestMutex.lock();
+            asyncLoopState.requestsCV.wait_for(lk, std::chrono::seconds(5), [this] { return asyncLoopState.pending; }); // wait for events
 
         asyncLoopState.pending = false;
 
         if (asyncLoopState.requests.empty()) {
-            asyncLoopState.requestMutex.unlock();
+            lk.unlock();
             continue;
         }
 
         auto requests = asyncLoopState.requests;
         asyncLoopState.requests.clear();
 
-        asyncLoopState.requestMutex.unlock();
+        lk.unlock();
 
         // process requests
-
-        asyncLoopState.busy = true;
         for (auto& r : requests) {
             if (r.type == TARGET_TEXT) {
                 renderText(r);
@@ -415,29 +413,26 @@ void CAsyncResourceGatherer::asyncAssetSpinLock() {
             if (r.callback)
                 g_pHyprlock->addTimer(std::chrono::milliseconds(0), timerCallback, new STimerCallbackData{r.callback, r.callbackData});
         }
-
-        asyncLoopState.busy = false;
     }
 
     dmas.clear();
 }
 
 void CAsyncResourceGatherer::requestAsyncAssetPreload(const SPreloadRequest& request) {
-    std::lock_guard<std::mutex> lg(asyncLoopState.requestMutex);
+    std::lock_guard<std::mutex> lg(asyncLoopState.requestsMutex);
     asyncLoopState.requests.push_back(request);
     asyncLoopState.pending = true;
-    asyncLoopState.loopGuard.notify_all();
+    asyncLoopState.requestsCV.notify_all();
 }
 
 void CAsyncResourceGatherer::unloadAsset(SPreloadedAsset* asset) {
-    std::lock_guard<std::mutex> lg(asyncLoopState.assetsMutex);
-
     std::erase_if(assets, [asset](const auto& a) { return &a.second == asset; });
 }
 
 void CAsyncResourceGatherer::notify() {
+    std::lock_guard<std::mutex> lg(asyncLoopState.requestsMutex);
     asyncLoopState.pending = true;
-    asyncLoopState.loopGuard.notify_all();
+    asyncLoopState.requestsCV.notify_all();
 }
 
 void CAsyncResourceGatherer::await() {
diff --git a/src/renderer/AsyncResourceGatherer.hpp b/src/renderer/AsyncResourceGatherer.hpp
index 2fa81a8..d94cb85 100644
--- a/src/renderer/AsyncResourceGatherer.hpp
+++ b/src/renderer/AsyncResourceGatherer.hpp
@@ -24,7 +24,7 @@ class CAsyncResourceGatherer {
     /* only call from ogl thread */
     SPreloadedAsset* getAssetByID(const std::string& id);
 
-    void             apply();
+    bool             apply();
 
     enum eTargetType {
         TARGET_IMAGE = 0,
@@ -59,12 +59,8 @@ class CAsyncResourceGatherer {
     void        renderImage(const SPreloadRequest& rq);
 
     struct {
-        std::condition_variable      loopGuard;
-        std::mutex                   loopMutex;
-
-        std::mutex                   requestMutex;
-
-        std::mutex                   assetsMutex;
+        std::condition_variable      requestsCV;
+        std::mutex                   requestsMutex;
 
         std::vector<SPreloadRequest> requests;
         bool                         pending = false;
@@ -86,6 +82,8 @@ class CAsyncResourceGatherer {
     std::vector<std::unique_ptr<CDMAFrame>>          dmas;
 
     std::vector<SPreloadTarget>                      preloadTargets;
+    std::mutex                                       preloadTargetsMutex;
+
     std::unordered_map<std::string, SPreloadedAsset> assets;
 
     void                                             gather();
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index 79665b9..29c335b 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -39,8 +39,10 @@ void CLabel::onTimerUpdate() {
     if (label.formatted == oldFormatted && !label.alwaysUpdate)
         return;
 
-    if (!pendingResourceID.empty())
-        return; // too many updates, we'll miss some. Shouldn't happen tbh
+    if (!pendingResourceID.empty()) {
+        Debug::log(WARN, "Trying to update label, but resource {} is still pending! Skipping update.", pendingResourceID);
+        return;
+    }
 
     // request new
     request.id        = getUniqueResourceId();
@@ -141,7 +143,4 @@ static void onAssetCallbackTimer(std::shared_ptr<CTimer> self, void* data) {
 
 void CLabel::renderSuper() {
     g_pHyprlock->renderOutput(outputStringPort);
-
-    if (!pendingResourceID.empty()) /* did not consume the pending resource */
-        g_pHyprlock->addTimer(std::chrono::milliseconds(100), onAssetCallbackTimer, this);
 }

commit b98d90c5df7f1858a545c1ba7e82c47c84e762a5
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Fri Jun 28 18:57:38 2024 +0200

    core: fix sourcing config files (#387)
    
    * core: fix sourcing config files
    
    The `handleSource` handle relies on `g_pConfigManager`, which therefore
    needs to be moved before `init`.
    
    * core: remove unnecessary unique pointer moves

diff --git a/src/main.cpp b/src/main.cpp
index 547b849..6273a3b 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -72,9 +72,8 @@ int main(int argc, char** argv, char** envp) {
     }
 
     try {
-        auto configManager = std::make_unique<CConfigManager>(configPath);
-        configManager->init();
-        g_pConfigManager = std::move(configManager);
+        g_pConfigManager = std::make_unique<CConfigManager>(configPath);
+        g_pConfigManager->init();
     } catch (const std::exception& ex) {
         Debug::log(CRIT, "ConfigManager threw: {}", ex.what());
         if (std::string(ex.what()).contains("File does not exist"))
@@ -84,8 +83,7 @@ int main(int argc, char** argv, char** envp) {
     }
 
     try {
-        auto hyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate);
-        g_pHyprlock   = std::move(hyprlock);
+        g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate);
         g_pHyprlock->run();
     } catch (const std::exception& ex) {
         Debug::log(CRIT, "Hyprlock threw: {}", ex.what());

commit 7f6d7a4845f1ed3306bdc8a97b0db73ec1474ff9
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Tue Jul 2 00:45:06 2024 +0200

    core: improve dynamic output handling (#386)
    
    * core: check for sessionLockSurface before calling render
    
    This is needed, because when a new monitor is added via `onGlobal` the
    order of the events is not guaranteed. Meaning that render for a
    particular monitor might get called before a `CSessionLockSurface` for
    that monitor exists.
    
    * renderer: remove widgets for destroyed lockSurfaces
    
    * asyncResourceGatherer: don't create duplicate dma frames for a specific stringPort
    
    * core: remove renderer widgets in ~CSessionLockSurface instead of in onGlobalRemoved
    
    * Revert "core: remove renderer widgets in ~CSessionLockSurface instead of in onGlobalRemoved"
    
    This reverts commit 405aa42de883a7080d3e02200e91e76484b3a97b.
    
    Because of destruction order, it is safer to do it in `onGlobalRemoved`.
    
    * core: ditch dynamic DMAFrame generation
    
    * core: identify DMAFrames via output size and stringPort
    
    * core: fallback to background color for dynamic outputs with background:path=screenshot
    
    * core: remove output pointer from DMAFrame

diff --git a/src/core/Output.cpp b/src/core/Output.cpp
index 2282e5c..3b0a8a4 100644
--- a/src/core/Output.cpp
+++ b/src/core/Output.cpp
@@ -25,11 +25,9 @@ static void handleDone(void* data, wl_output* output) {
     const auto POUTPUT = (COutput*)data;
     Debug::log(LOG, "output {} done", POUTPUT->name);
     if (g_pHyprlock->m_bLocked && !POUTPUT->sessionLockSurface) {
-        // if we are already locked, create a surface dynamically after a small timeout
-        // we also need to request a dma frame for screenshots
+        // if we are already locked, create a surface dynamically
         Debug::log(LOG, "Creating a surface dynamically for output as we are already locked");
         POUTPUT->sessionLockSurface = std::make_unique<CSessionLockSurface>(POUTPUT);
-        g_pRenderer->asyncResourceGatherer->recheckDMAFramesFor(POUTPUT);
     }
 }
 
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index eedc963..05eda53 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -300,7 +300,11 @@ void CHyprlock::onGlobal(void* data, struct wl_registry* registry, uint32_t name
 
 void CHyprlock::onGlobalRemoved(void* data, struct wl_registry* registry, uint32_t name) {
     Debug::log(LOG, "  | removed iface {}", name);
-    std::erase_if(m_vOutputs, [name](const auto& other) { return other->name == name; });
+    auto outputIt = std::find_if(m_vOutputs.begin(), m_vOutputs.end(), [name](const auto& other) { return other->name == name; });
+    if (outputIt != m_vOutputs.end()) {
+        g_pRenderer->removeWidgetsFor(outputIt->get()->sessionLockSurface.get());
+        m_vOutputs.erase(outputIt);
+    }
 }
 
 // end wl_registry
@@ -570,9 +574,7 @@ void CHyprlock::unlock() {
     m_tFadeEnds    = std::chrono::system_clock::now() + std::chrono::milliseconds(500);
     m_bFadeStarted = true;
 
-    for (auto& o : m_vOutputs) {
-        o->sessionLockSurface->render();
-    }
+    renderAllOutputs();
 }
 
 // wl_seat
@@ -758,9 +760,7 @@ static const ext_session_lock_v1_listener sessionLockListener = {
 static void displayFailTextTimerCallback(std::shared_ptr<CTimer> self, void* data) {
     g_pAuth->m_bDisplayFailText = false;
 
-    for (auto& o : g_pHyprlock->m_vOutputs) {
-        o->sessionLockSurface->render();
-    }
+    g_pHyprlock->renderAllOutputs();
 }
 
 void CHyprlock::onPasswordCheckTimer() {
@@ -779,9 +779,7 @@ void CHyprlock::onPasswordCheckTimer() {
 
         g_pAuth->start();
 
-        for (auto& o : m_vOutputs) {
-            o->sessionLockSurface->render();
-        }
+        renderAllOutputs();
     }
 }
 
@@ -790,9 +788,8 @@ void CHyprlock::clearPasswordBuffer() {
         return;
 
     m_sPasswordState.passBuffer = "";
-    for (auto& o : m_vOutputs) {
-        o->sessionLockSurface->render();
-    }
+
+    renderAllOutputs();
 }
 
 void CHyprlock::renderOutput(const std::string& stringPort) {
@@ -803,9 +800,21 @@ void CHyprlock::renderOutput(const std::string& stringPort) {
 
     const auto PMONITOR = MON->get();
 
+    if (!PMONITOR->sessionLockSurface)
+        return;
+
     PMONITOR->sessionLockSurface->render();
 }
 
+void CHyprlock::renderAllOutputs() {
+    for (auto& o : m_vOutputs) {
+        if (!o->sessionLockSurface)
+            continue;
+
+        o->sessionLockSurface->render();
+    }
+}
+
 void CHyprlock::startKeyRepeat(xkb_keysym_t sym) {
     if (m_pKeyRepeatTimer) {
         m_pKeyRepeatTimer->cancel();
@@ -830,9 +839,7 @@ void CHyprlock::repeatKey(xkb_keysym_t sym) {
         m_pKeyRepeatTimer = addTimer(
             std::chrono::milliseconds(m_iKeebRepeatRate), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
 
-    for (auto& o : m_vOutputs) {
-        o->sessionLockSurface->render();
-    }
+    renderAllOutputs();
 }
 
 void CHyprlock::onKey(uint32_t key, bool down) {
@@ -863,9 +870,7 @@ void CHyprlock::onKey(uint32_t key, bool down) {
     }
 
     if (g_pAuth->checkWaiting()) {
-        for (auto& o : m_vOutputs) {
-            o->sessionLockSurface->render();
-        }
+        renderAllOutputs();
         return;
     }
 
@@ -881,9 +886,7 @@ void CHyprlock::onKey(uint32_t key, bool down) {
             startKeyRepeat(SYM);
     }
 
-    for (auto& o : m_vOutputs) {
-        o->sessionLockSurface->render();
-    }
+    renderAllOutputs();
 }
 
 void CHyprlock::handleKeySym(xkb_keysym_t sym) {
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 52344b9..5a2efb7 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -64,6 +64,7 @@ class CHyprlock {
     std::optional<std::string>      passwordLastFailReason();
 
     void                            renderOutput(const std::string& stringPort);
+    void                            renderAllOutputs();
 
     size_t                          getPasswordBufferLen();
     size_t                          getPasswordBufferDisplayLen();
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 465511c..19781d8 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -56,30 +56,6 @@ CAsyncResourceGatherer::CAsyncResourceGatherer() {
     }
 }
 
-void CAsyncResourceGatherer::recheckDMAFramesFor(COutput* output) {
-    const auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
-
-    bool       shouldMake = false;
-
-    for (auto& c : CWIDGETS) {
-        if (c.type != "background")
-            continue;
-
-        if (std::string{std::any_cast<Hyprlang::STRING>(c.values.at("path"))} != "screenshot")
-            continue;
-
-        if (c.monitor.empty() || c.monitor == output->stringPort || output->stringDesc.starts_with(c.monitor)) {
-            shouldMake = true;
-            break;
-        }
-    }
-
-    if (!shouldMake)
-        return;
-
-    dmas.emplace_back(std::make_unique<CDMAFrame>(output));
-}
-
 SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {
     for (auto& a : assets) {
         if (a.first == id)
@@ -94,7 +70,7 @@ SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {
     };
 
     for (auto& dma : dmas) {
-        if (id == "dma:" + dma->name)
+        if (id == dma->resourceID)
             return dma->asset.ready ? &dma->asset : nullptr;
     }
 
diff --git a/src/renderer/AsyncResourceGatherer.hpp b/src/renderer/AsyncResourceGatherer.hpp
index d94cb85..8e8f5a1 100644
--- a/src/renderer/AsyncResourceGatherer.hpp
+++ b/src/renderer/AsyncResourceGatherer.hpp
@@ -49,7 +49,6 @@ class CAsyncResourceGatherer {
     void unloadAsset(SPreloadedAsset* asset);
     void notify();
     void await();
-    void recheckDMAFramesFor(COutput* output);
 
   private:
     std::thread asyncLoopThread;
diff --git a/src/renderer/DMAFrame.cpp b/src/renderer/DMAFrame.cpp
index 08d9ff9..c67c6ac 100644
--- a/src/renderer/DMAFrame.cpp
+++ b/src/renderer/DMAFrame.cpp
@@ -86,7 +86,12 @@ static const zwlr_screencopy_frame_v1_listener wlrFrameListener = {
     .buffer_done  = wlrOnBufferDone,
 };
 
-CDMAFrame::CDMAFrame(COutput* output_) : output(output_) {
+std::string CDMAFrame::getResourceId(COutput* output) {
+    return std::format("dma:{}-{}x{}", output->stringPort, output->size.x, output->size.y);
+}
+
+CDMAFrame::CDMAFrame(COutput* output_) {
+    resourceID = getResourceId(output_);
 
     if (!glEGLImageTargetTexture2DOES) {
         glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
@@ -100,13 +105,11 @@ CDMAFrame::CDMAFrame(COutput* output_) : output(output_) {
         eglQueryDmaBufModifiersEXT = (PFNEGLQUERYDMABUFMODIFIERSEXTPROC)eglGetProcAddress("eglQueryDmaBufModifiersEXT");
 
     // firstly, plant a listener for the frame
-    frameCb = zwlr_screencopy_manager_v1_capture_output(g_pHyprlock->getScreencopy(), false, output->output);
+    frameCb = zwlr_screencopy_manager_v1_capture_output(g_pHyprlock->getScreencopy(), false, output_->output);
 
     scdata.frame = this;
 
     zwlr_screencopy_frame_v1_add_listener(frameCb, &wlrFrameListener, &scdata);
-
-    name = output->stringPort;
 }
 
 CDMAFrame::~CDMAFrame() {
diff --git a/src/renderer/DMAFrame.hpp b/src/renderer/DMAFrame.hpp
index cb13d24..7309432 100644
--- a/src/renderer/DMAFrame.hpp
+++ b/src/renderer/DMAFrame.hpp
@@ -19,6 +19,8 @@ struct SScreencopyData {
 
 class CDMAFrame {
   public:
+    static std::string getResourceId(COutput* output);
+
     CDMAFrame(COutput* mon);
     ~CDMAFrame();
 
@@ -27,7 +29,7 @@ class CDMAFrame {
 
     wl_buffer*      wlBuffer = nullptr;
 
-    std::string     name;
+    std::string     resourceID;
 
     SPreloadedAsset asset;
 
@@ -42,7 +44,5 @@ class CDMAFrame {
     zwlr_screencopy_frame_v1* frameCb = nullptr;
     SScreencopyData           scdata;
 
-    COutput*                  output = nullptr;
-
     EGLImage                  image = nullptr;
 };
\ No newline at end of file
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 08a15c9..bd19238 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -4,6 +4,7 @@
 #include "../helpers/Color.hpp"
 #include "../core/Output.hpp"
 #include "../core/hyprlock.hpp"
+#include "../renderer/DMAFrame.hpp"
 #include "mtx.hpp"
 
 #include <GLES3/gl32.h>
@@ -320,9 +321,15 @@ std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CS
                 const std::string PATH = std::any_cast<Hyprlang::STRING>(c.values.at("path"));
 
                 std::string       resourceID = "";
-                if (PATH == "screenshot")
-                    resourceID = "dma:" + surf->output->stringPort;
-                else if (!PATH.empty())
+                if (PATH == "screenshot") {
+                    resourceID = CDMAFrame::getResourceId(surf->output);
+                    // When the initial gather of the asyncResourceGatherer is completed (ready), all DMAFrames are available.
+                    // Dynamic ones are tricky, because a screencopy would copy hyprlock itself.
+                    if (asyncResourceGatherer->ready) {
+                        if (!asyncResourceGatherer->getAssetByID(resourceID))
+                            resourceID = ""; // Fallback to solid color (background:color)
+                    }
+                } else if (!PATH.empty())
                     resourceID = "background:" + PATH;
 
                 widgets[surf].emplace_back(std::make_unique<CBackground>(surf->size, surf->output, resourceID, c.values, PATH == "screenshot"));
@@ -512,3 +519,7 @@ void CRenderer::popFb() {
     boundFBs.pop_back();
     glBindFramebuffer(GL_DRAW_FRAMEBUFFER, boundFBs.empty() ? 0 : boundFBs.back());
 }
+
+void CRenderer::removeWidgetsFor(const CSessionLockSurface* surf) {
+    widgets.erase(surf);
+}
diff --git a/src/renderer/Renderer.hpp b/src/renderer/Renderer.hpp
index 6599740..d3fc2b6 100644
--- a/src/renderer/Renderer.hpp
+++ b/src/renderer/Renderer.hpp
@@ -41,6 +41,8 @@ class CRenderer {
     void                                    pushFb(GLint fb);
     void                                    popFb();
 
+    void                                    removeWidgetsFor(const CSessionLockSurface* surf);
+
   private:
     widgetMap_t                            widgets;
 

commit 490a4541335703c5b9a5d2417abe9b795ee49355
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Jul 3 19:31:16 2024 +0200

    asyncResourceGatherer: add dma frames before starting the asyncLoopThread (#394)

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 19781d8..c73308c 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -12,12 +12,6 @@
 #include "../helpers/Webp.hpp"
 
 CAsyncResourceGatherer::CAsyncResourceGatherer() {
-    asyncLoopThread = std::thread([this]() {
-        this->gather(); /* inital gather */
-        this->asyncAssetSpinLock();
-    });
-    asyncLoopThread.detach();
-
     // some things can't be done async :(
     // gather background textures when needed
 
@@ -54,6 +48,12 @@ CAsyncResourceGatherer::CAsyncResourceGatherer() {
 
         dmas.emplace_back(std::make_unique<CDMAFrame>(PMONITOR));
     }
+
+    asyncLoopThread = std::thread([this]() {
+        this->gather(); /* inital gather */
+        this->asyncAssetSpinLock();
+    });
+    asyncLoopThread.detach();
 }
 
 SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {

commit 704b0c6e1b443ac1f9aaf2518a68be49ddc78b0c
Author: davc0n <dconti.dev@gmail.com>
Date:   Wed Jul 3 23:50:07 2024 +0200

    config: Remove dupe input-field rounding from listKeysForSpecialCategory (#395)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index c42e574..6ec4d7f 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -267,7 +267,6 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"placeholder_text", m_config.getSpecialConfigValue("input-field", "placeholder_text", k.c_str())},
                 {"hide_input", m_config.getSpecialConfigValue("input-field", "hide_input", k.c_str())},
                 {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
-                {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
                 {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
                 {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
                 {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},

commit 26614f31694748220e68e0f2aa74a88db4291d33
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Thu Jul 4 18:04:45 2024 +0200

    label: do not error when using cmd[] for a static label cmd (#396)

diff --git a/src/renderer/widgets/IWidget.cpp b/src/renderer/widgets/IWidget.cpp
index b1879fc..31b4ad1 100644
--- a/src/renderer/widgets/IWidget.cpp
+++ b/src/renderer/widgets/IWidget.cpp
@@ -154,7 +154,7 @@ IWidget::SFormatResult IWidget::formatString(std::string in) {
 
     if (in.starts_with("cmd[") && in.contains("]")) {
         // this is a command
-        CVarList vars(in.substr(4, in.find_first_of(']') - 4));
+        CVarList vars(in.substr(4, in.find_first_of(']') - 4), 0, ',', true);
 
         for (const auto& v : vars) {
             if (v.starts_with("update:")) {

commit e2c19bfdcb4827b9ef72bd2d5449f549c516cb9e
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Fri Jul 5 22:41:03 2024 +0200

    config: don't crash when getenv HOME returns null (#398)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 6ec4d7f..2f1c00e 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -23,7 +23,12 @@ static std::string getConfigDir() {
     if (xdgConfigHome && std::filesystem::path(xdgConfigHome).is_absolute())
         return xdgConfigHome;
 
-    return getenv("HOME") + std::string("/.config");
+    static const char* home = getenv("HOME");
+
+    if (!home)
+        throw std::runtime_error("Neither HOME nor XDG_CONFIG_HOME is set in the environment. Cannot determine config directory.");
+
+    return home + std::string("/.config");
 }
 
 static std::string getMainConfigPath() {

commit 3830b9ef00c3c94cc8b27868dd0d3291237fec66
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Fri Jul 5 22:54:40 2024 +0200

    auth: pam fallback log message and always call pam_end after pam_authenticate (#399)
    
    * auth: make the fallback to sudo error more descriptive
    
    * auth: always call pam_end after pam_authenticate

diff --git a/src/core/Auth.cpp b/src/core/Auth.cpp
index ea3066f..a4ca2f1 100644
--- a/src/core/Auth.cpp
+++ b/src/core/Auth.cpp
@@ -58,7 +58,7 @@ CAuth::CAuth() {
     m_sPamModule                  = *PPAMMODULE;
 
     if (!std::filesystem::exists(std::filesystem::path("/etc/pam.d/") / m_sPamModule)) {
-        Debug::log(ERR, "Pam module \"{}\" not found! Falling back to \"su\"", m_sPamModule);
+        Debug::log(ERR, "Pam module \"/etc/pam.d/{}\" does not exist! Falling back to \"/etc/pam.d/su\"", m_sPamModule);
         m_sPamModule = "su";
     }
 }
@@ -91,6 +91,8 @@ bool CAuth::auth() {
     }
 
     ret = pam_authenticate(handle, 0);
+    pam_end(handle, ret);
+    handle = nullptr;
 
     m_sConversationState.waitingForPamAuth = false;
 
@@ -101,8 +103,6 @@ bool CAuth::auth() {
         return false;
     }
 
-    ret = pam_end(handle, ret);
-
     m_sConversationState.success  = true;
     m_sConversationState.failText = "Successfully authenticated";
     Debug::log(LOG, "auth: authenticated for {}", m_sPamModule);

commit 2685ae06c81b68047eaea07d4b12313c2f150640
Author: daywalker-dev <144274661+daywalker-dev@users.noreply.github.com>
Date:   Fri Jul 5 14:58:45 2024 -0600

    helpers: fix jpeg and webp OOM error (#401)
    
    * Update Jpeg.cpp
    
    * Update Webp.cpp

diff --git a/src/helpers/Jpeg.cpp b/src/helpers/Jpeg.cpp
index c9ad08d..3616744 100644
--- a/src/helpers/Jpeg.cpp
+++ b/src/helpers/Jpeg.cpp
@@ -66,6 +66,7 @@ cairo_surface_t* JPEG::createSurfaceFromJPEG(const std::filesystem::path& path)
         jpeg_read_scanlines(&decompressStruct, &rowRead, 1);
     }
 
+    cairo_surface_flush(cairoSurface);
     cairo_surface_mark_dirty(cairoSurface);
     cairo_surface_set_mime_data(cairoSurface, CAIRO_MIME_TYPE_JPEG, (const unsigned char*)imageRawData, fileInfo.st_size, free, imageRawData);
     jpeg_finish_decompress(&decompressStruct);
diff --git a/src/helpers/Webp.cpp b/src/helpers/Webp.cpp
index c42047f..6941502 100644
--- a/src/helpers/Webp.cpp
+++ b/src/helpers/Webp.cpp
@@ -74,6 +74,7 @@ cairo_surface_t* WEBP::createSurfaceFromWEBP(const std::filesystem::path& path)
         return nullptr;
     }
 
+    cairo_surface_flush(cairoSurface);
     cairo_surface_mark_dirty(cairoSurface);
     cairo_surface_set_mime_data(cairoSurface, CAIRO_MIME_TYPE_PNG, (const unsigned char*)imageRawData, fileInfo.st_size, free, imageRawData);
 

commit aa47dced484d928bffb4767e80e8004dfe1f5815
Author: Tom Englund <tomenglund26@gmail.com>
Date:   Sat Jul 6 12:24:29 2024 +0200

    hyprlock: ensure members are accessed direct (#404)
    
    if the unique_ptr is reset directly accessing it from the destructor
    causes crashes on Clang/libc++, just access the members directly.

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 05eda53..7d07272 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -40,14 +40,14 @@ CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate) {
 }
 
 CHyprlock::~CHyprlock() {
-    if (g_pHyprlock->dma.gbmDevice)
-        gbm_device_destroy(g_pHyprlock->dma.gbmDevice);
+    if (dma.gbmDevice)
+        gbm_device_destroy(dma.gbmDevice);
 
-    if (g_pHyprlock->m_pXKBState)
-        xkb_state_unref(g_pHyprlock->m_pXKBState);
+    if (m_pXKBState)
+        xkb_state_unref(m_pXKBState);
 
-    if (g_pHyprlock->m_pXKBKeymap)
-        xkb_keymap_unref(g_pHyprlock->m_pXKBKeymap);
+    if (m_pXKBKeymap)
+        xkb_keymap_unref(m_pXKBKeymap);
 }
 
 // wl_seat

commit f9f18f7fea081eb808cddadc842430f4d7db33ba
Author: Jasson <Jasson.cordones@hotmail.com>
Date:   Sun Jul 7 11:55:59 2024 -0400

    core: minor bugfixes (#405)

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index beb522b..162946b 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -16,7 +16,7 @@ static const ext_session_lock_surface_v1_listener lockListener = {
 static void handlePreferredScale(void* data, wp_fractional_scale_v1* wp_fractional_scale_v1, uint32_t scale) {
     const auto PSURF       = (CSessionLockSurface*)data;
     PSURF->fractionalScale = scale / 120.0;
-    Debug::log(LOG, "got fractional {}", PSURF->fractionalScale);
+    Debug::log(LOG, "Got fractional scale: {}", PSURF->fractionalScale);
 
     if (PSURF->readyForFrame)
         PSURF->onScaleUpdate();
@@ -35,8 +35,12 @@ CSessionLockSurface::~CSessionLockSurface() {
     if (eglWindow)
         wl_egl_window_destroy(eglWindow);
 
-    ext_session_lock_surface_v1_destroy(lockSurface);
-    wl_surface_destroy(surface);
+    if (lockSurface)
+        ext_session_lock_surface_v1_destroy(lockSurface);
+
+    if (surface)
+        wl_surface_destroy(surface);
+
     if (frameCallback)
         wl_callback_destroy(frameCallback);
 }
@@ -58,7 +62,7 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
 
     lockSurface = ext_session_lock_v1_get_lock_surface(g_pHyprlock->getSessionLock(), surface, output->output);
 
-    if (!surface) {
+    if (!lockSurface) {
         Debug::log(CRIT, "Couldn't create ext_session_lock_surface_v1");
         exit(1);
     }
@@ -72,36 +76,41 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     const bool sameSerial = serial == serial_;
 
     serial      = serial_;
-    size        = (size_ * fractionalScale).floor();
     logicalSize = size_;
 
+    if (fractional) {
+        size = (size_ * fractionalScale).floor();
+        wp_viewport_set_destination(viewport, logicalSize.x, logicalSize.y);
+    } else {
+        size = size_;
+    }
+
     Debug::log(LOG, "Configuring surface for logical {} and pixel {}", logicalSize, size);
 
     if (!sameSerial)
         ext_session_lock_surface_v1_ack_configure(lockSurface, serial);
 
-    if (fractional)
-        wp_viewport_set_destination(viewport, logicalSize.x, logicalSize.y);
-
     wl_surface_set_buffer_scale(surface, 1);
     wl_surface_damage_buffer(surface, 0, 0, 0xFFFF, 0xFFFF);
 
-    if (!eglWindow)
+    if (!eglWindow) {
         eglWindow = wl_egl_window_create(surface, size.x, size.y);
-    else
+        if (!eglWindow) {
+            Debug::log(CRIT, "Couldn't create eglWindow");
+            exit(1);
+        }
+    } else
         wl_egl_window_resize(eglWindow, size.x, size.y, 0, 0);
 
-    if (!eglWindow) {
-        Debug::log(CRIT, "Couldn't create eglWindow");
-        exit(1);
-    }
-
-    if (!eglSurface)
-        eglSurface = g_pEGL->eglCreatePlatformWindowSurfaceEXT(g_pEGL->eglDisplay, g_pEGL->eglConfig, eglWindow, nullptr);
-
     if (!eglSurface) {
-        Debug::log(CRIT, "Couldn't create eglSurface: {}", (int)glGetError());
-        exit(1);
+        eglSurface = g_pEGL->eglCreatePlatformWindowSurfaceEXT(g_pEGL->eglDisplay, g_pEGL->eglConfig, eglWindow, nullptr);
+        if (!eglSurface) {
+            Debug::log(CRIT, "Couldn't create eglSurface: {}", (int)eglGetError());
+            // Clean up resources to prevent leaks
+            wl_egl_window_destroy(eglWindow);
+            eglWindow = nullptr;
+            exit(1); // Consider graceful exit or fallback
+        }
     }
 
     readyForFrame = true;
@@ -147,6 +156,8 @@ void CSessionLockSurface::onCallback() {
     wl_callback_destroy(frameCallback);
     frameCallback = nullptr;
 
-    if (needsFrame && !g_pHyprlock->m_bTerminate && g_pEGL)
+    if (needsFrame && !g_pHyprlock->m_bTerminate && g_pEGL) {
+        needsFrame = false;
         render();
+    }
 }
\ No newline at end of file

commit 2c1a5ee28f45ed26cf8e5abc2c36657405209020
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Sun Jul 7 18:43:17 2024 +0200

    core: add option to render solid background immediatly when bg assets are not ready (#407)
    
    * asyncResourceGatherer: start the asyncLoop at the same time as gather
    
    This is a prerequesit for labels beeing drawn, while backgrounds are
    note ready yet.
    
    * core: allow immediate rendering even when backgrounds are not gathered yet
    
    Note:
    We don't really need to call `asyncResourceGatherer::apply` in the
    `renderLock` function, since it will get called by a call to
    `asyncResourceGatherer::getAssetById` anyways.
    
    * background: render color rectangle when asset is not ready yet
    
    * config: add general:immediate_render config option
    
    * core: use the --immediate-render flag in attemptRestoreOnDeath

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 2f1c00e..990bfe5 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -55,6 +55,7 @@ void CConfigManager::init() {
     m_config.addConfigValue("general:no_fade_in", Hyprlang::INT{0});
     m_config.addConfigValue("general:no_fade_out", Hyprlang::INT{0});
     m_config.addConfigValue("general:ignore_empty_input", Hyprlang::INT{0});
+    m_config.addConfigValue("general:immediate_render", Hyprlang::INT{0});
     m_config.addConfigValue("general:pam_module", Hyprlang::STRING{"hyprlock"});
 
     m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 7d07272..7b3e856 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -18,7 +18,7 @@
 #include <fstream>
 #include <algorithm>
 
-CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate) {
+CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender) {
     m_sWaylandState.display = wl_display_connect(wlDisplay.empty() ? nullptr : wlDisplay.c_str());
     if (!m_sWaylandState.display) {
         Debug::log(CRIT, "Couldn't connect to a wayland compositor");
@@ -32,11 +32,14 @@ CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate) {
         Debug::log(ERR, "Failed to create xkb context");
 
     if (!immediate) {
-        const auto GRACE = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:grace");
-        m_tGraceEnds     = **GRACE ? std::chrono::system_clock::now() + std::chrono::seconds(**GRACE) : std::chrono::system_clock::from_time_t(0);
+        const auto PGRACE = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:grace");
+        m_tGraceEnds      = **PGRACE ? std::chrono::system_clock::now() + std::chrono::seconds(**PGRACE) : std::chrono::system_clock::from_time_t(0);
     } else {
         m_tGraceEnds = std::chrono::system_clock::from_time_t(0);
     }
+
+    const auto PIMMEDIATERENDER = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:immediate_render");
+    m_bImmediateRender          = immediateRender || **PIMMEDIATERENDER;
 }
 
 CHyprlock::~CHyprlock() {
@@ -383,7 +386,7 @@ void CHyprlock::run() {
 
     // Hyprland violates the protocol a bit to allow for this.
     if (SZCURRENTD != "Hyprland") {
-        while (!g_pRenderer->asyncResourceGatherer->ready) {
+        while (!g_pRenderer->asyncResourceGatherer->gathered) {
             wl_display_flush(m_sWaylandState.display);
             if (wl_display_prepare_read(m_sWaylandState.display) == 0) {
                 wl_display_read_events(m_sWaylandState.display);
@@ -1137,5 +1140,5 @@ void CHyprlock::attemptRestoreOnDeath() {
     ofs.close();
 
     spawnSync("hyprctl keyword misc:allow_session_lock_restore true");
-    spawnAsync("sleep 2 && hyprlock --immediate & disown");
+    spawnAsync("sleep 2 && hyprlock --immediate --immediate-render & disown");
 }
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 5a2efb7..67a4d37 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -28,7 +28,7 @@ struct SDMABUFModifier {
 
 class CHyprlock {
   public:
-    CHyprlock(const std::string& wlDisplay, const bool immediate);
+    CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender);
     ~CHyprlock();
 
     void                            run();
@@ -100,6 +100,8 @@ class CHyprlock {
     bool                            m_bNumLock     = false;
     bool                            m_bCtrl        = false;
     bool                            m_bFadeStarted = false;
+
+    bool                            m_bImmediateRender = false;
     //
     std::chrono::system_clock::time_point m_tGraceEnds;
     std::chrono::system_clock::time_point m_tFadeEnds;
diff --git a/src/main.cpp b/src/main.cpp
index 6273a3b..2cf92b7 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -11,6 +11,7 @@ void help() {
                  "  -c FILE, --config FILE   - Specify config file to use\n"
                  "  --display (display)      - Specify the Wayland display to connect to\n"
                  "  --immediate              - Lock immediately, ignoring any configured grace period\n"
+                 "  --immediate-render       - Do not wait for resources before drawing the background\n"
                  "  -h, --help               - Show this help message\n";
 }
 
@@ -26,8 +27,9 @@ std::optional<std::string> parseArg(const std::vector<std::string>& args, const
 int main(int argc, char** argv, char** envp) {
     std::string              configPath;
     std::string              wlDisplay;
-    bool                     immediate = false;
-    bool                     showHelp  = false;
+    bool                     immediate       = false;
+    bool                     immediateRender = false;
+    bool                     showHelp        = false;
 
     std::vector<std::string> args(argv, argv + argc);
 
@@ -55,6 +57,9 @@ int main(int argc, char** argv, char** envp) {
         } else if (arg == "--immediate")
             immediate = true;
 
+        else if (arg == "--immediate-render")
+            immediateRender = true;
+
         else if (arg == "--help" || arg == "-h") {
             showHelp = true;
             break;
@@ -83,7 +88,7 @@ int main(int argc, char** argv, char** envp) {
     }
 
     try {
-        g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate);
+        g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate, immediateRender);
         g_pHyprlock->run();
     } catch (const std::exception& ex) {
         Debug::log(CRIT, "Hyprlock threw: {}", ex.what());
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index c73308c..df98349 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -49,10 +49,10 @@ CAsyncResourceGatherer::CAsyncResourceGatherer() {
         dmas.emplace_back(std::make_unique<CDMAFrame>(PMONITOR));
     }
 
-    asyncLoopThread = std::thread([this]() {
-        this->gather(); /* inital gather */
-        this->asyncAssetSpinLock();
-    });
+    initialGatherThread = std::thread([this]() { this->gather(); });
+    initialGatherThread.detach();
+
+    asyncLoopThread = std::thread([this]() { this->asyncAssetSpinLock(); });
     asyncLoopThread.detach();
 }
 
@@ -158,16 +158,19 @@ void CAsyncResourceGatherer::gather() {
             const auto CAIRO = cairo_create(CAIROISURFACE);
             cairo_scale(CAIRO, 1, 1);
 
-            const auto TARGET = &preloadTargets.emplace_back(CAsyncResourceGatherer::SPreloadTarget{});
+            {
+                std::lock_guard lg{preloadTargetsMutex};
+                const auto      TARGET = &preloadTargets.emplace_back(CAsyncResourceGatherer::SPreloadTarget{});
 
-            TARGET->size = {cairo_image_surface_get_width(CAIROISURFACE), cairo_image_surface_get_height(CAIROISURFACE)};
-            TARGET->type = TARGET_IMAGE;
-            TARGET->id   = id;
+                TARGET->size = {cairo_image_surface_get_width(CAIROISURFACE), cairo_image_surface_get_height(CAIROISURFACE)};
+                TARGET->type = TARGET_IMAGE;
+                TARGET->id   = id;
 
-            const auto DATA      = cairo_image_surface_get_data(CAIROISURFACE);
-            TARGET->cairo        = CAIRO;
-            TARGET->cairosurface = CAIROISURFACE;
-            TARGET->data         = DATA;
+                const auto DATA      = cairo_image_surface_get_data(CAIROISURFACE);
+                TARGET->cairo        = CAIRO;
+                TARGET->cairosurface = CAIROISURFACE;
+                TARGET->data         = DATA;
+            }
         }
     }
 
@@ -175,7 +178,7 @@ void CAsyncResourceGatherer::gather() {
         std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
 
-    ready = true;
+    gathered = true;
 }
 
 bool CAsyncResourceGatherer::apply() {
@@ -225,7 +228,6 @@ bool CAsyncResourceGatherer::apply() {
         }
     }
 
-    applied = true;
     return true;
 }
 
@@ -414,4 +416,6 @@ void CAsyncResourceGatherer::notify() {
 void CAsyncResourceGatherer::await() {
     if (asyncLoopThread.joinable())
         asyncLoopThread.join();
+    if (initialGatherThread.joinable())
+        initialGatherThread.join();
 }
diff --git a/src/renderer/AsyncResourceGatherer.hpp b/src/renderer/AsyncResourceGatherer.hpp
index 8e8f5a1..19defd3 100644
--- a/src/renderer/AsyncResourceGatherer.hpp
+++ b/src/renderer/AsyncResourceGatherer.hpp
@@ -16,8 +16,7 @@
 class CAsyncResourceGatherer {
   public:
     CAsyncResourceGatherer();
-    std::atomic<bool>  ready   = false;
-    std::atomic<bool>  applied = false;
+    std::atomic<bool>  gathered = false;
 
     std::atomic<float> progress = 0;
 
@@ -52,6 +51,7 @@ class CAsyncResourceGatherer {
 
   private:
     std::thread asyncLoopThread;
+    std::thread initialGatherThread;
 
     void        asyncAssetSpinLock();
     void        renderText(const SPreloadRequest& rq);
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index bd19238..560ceae 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -159,7 +159,8 @@ CRenderer::CRenderer() {
     asyncResourceGatherer = std::make_unique<CAsyncResourceGatherer>();
 }
 
-static int frames = 0;
+static int  frames         = 0;
+static bool firstFullFrame = false;
 
 //
 CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf) {
@@ -183,12 +184,11 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
 
     SRenderFeedback feedback;
+    float           bga           = 0.0;
+    const bool      WAITFORASSETS = !g_pHyprlock->m_bImmediateRender && !asyncResourceGatherer->gathered;
 
-    float           bga = asyncResourceGatherer->applied ?
-                  std::clamp(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - gatheredAt).count() / 500000.0, 0.0, 1.0) :
-                  0.0;
+    if (WAITFORASSETS) {
 
-    if (!asyncResourceGatherer->ready) {
         // render status
         if (!**PDISABLEBAR) {
             CBox progress = {0, 0, asyncResourceGatherer->progress * surf.size.x, 2};
@@ -196,11 +196,13 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
         }
     } else {
 
-        if (!asyncResourceGatherer->applied) {
-            asyncResourceGatherer->apply();
-            gatheredAt = std::chrono::system_clock::now();
+        if (!firstFullFrame) {
+            firstFullFrameTime = std::chrono::system_clock::now();
+            firstFullFrame     = true;
         }
 
+        bga = std::clamp(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - firstFullFrameTime).count() / 500000.0, 0.0, 1.0);
+
         if (**PNOFADEIN)
             bga = 1.0;
 
@@ -220,7 +222,7 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
 
     Debug::log(TRACE, "frame {}", frames);
 
-    feedback.needsFrame = feedback.needsFrame || !asyncResourceGatherer->ready || bga < 1.0;
+    feedback.needsFrame = feedback.needsFrame || !asyncResourceGatherer->gathered || bga < 1.0;
 
     glDisable(GL_BLEND);
 
@@ -325,7 +327,7 @@ std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CS
                     resourceID = CDMAFrame::getResourceId(surf->output);
                     // When the initial gather of the asyncResourceGatherer is completed (ready), all DMAFrames are available.
                     // Dynamic ones are tricky, because a screencopy would copy hyprlock itself.
-                    if (asyncResourceGatherer->ready) {
+                    if (asyncResourceGatherer->gathered) {
                         if (!asyncResourceGatherer->getAssetByID(resourceID))
                             resourceID = ""; // Fallback to solid color (background:color)
                     }
diff --git a/src/renderer/Renderer.hpp b/src/renderer/Renderer.hpp
index d3fc2b6..07de9bc 100644
--- a/src/renderer/Renderer.hpp
+++ b/src/renderer/Renderer.hpp
@@ -36,7 +36,7 @@ class CRenderer {
     void                                    blurFB(const CFramebuffer& outfb, SBlurParams params);
 
     std::unique_ptr<CAsyncResourceGatherer> asyncResourceGatherer;
-    std::chrono::system_clock::time_point   gatheredAt;
+    std::chrono::system_clock::time_point   firstFullFrameTime;
 
     void                                    pushFb(GLint fb);
     void                                    popFb();
diff --git a/src/renderer/widgets/Background.cpp b/src/renderer/widgets/Background.cpp
index 9a53bae..f3601c8 100644
--- a/src/renderer/widgets/Background.cpp
+++ b/src/renderer/widgets/Background.cpp
@@ -15,21 +15,29 @@ CBackground::CBackground(const Vector2D& viewport_, COutput* output_, const std:
     contrast          = std::any_cast<Hyprlang::FLOAT>(props.at("contrast"));
 }
 
+void CBackground::renderRect(CColor color) {
+    CBox monbox = {0, 0, viewport.x, viewport.y};
+    g_pRenderer->renderRect(monbox, color, 0);
+}
+
 bool CBackground::draw(const SRenderData& data) {
 
     if (resourceID.empty()) {
-        CBox   monbox = {0, 0, viewport.x, viewport.y};
-        CColor col    = color;
+        CColor col = color;
         col.a *= data.opacity;
-        g_pRenderer->renderRect(monbox, col, 0);
+        renderRect(col);
         return data.opacity < 1.0;
     }
 
     if (!asset)
         asset = g_pRenderer->asyncResourceGatherer->getAssetByID(resourceID);
 
-    if (!asset)
+    if (!asset) {
+        CColor col = color;
+        col.a *= data.opacity;
+        renderRect(col);
         return true;
+    }
 
     if (asset->texture.m_iType == TEXTURE_INVALID) {
         g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
diff --git a/src/renderer/widgets/Background.hpp b/src/renderer/widgets/Background.hpp
index 33fd838..a2a648e 100644
--- a/src/renderer/widgets/Background.hpp
+++ b/src/renderer/widgets/Background.hpp
@@ -16,6 +16,7 @@ class CBackground : public IWidget {
     CBackground(const Vector2D& viewport, COutput* output_, const std::string& resourceID, const std::unordered_map<std::string, std::any>& props, bool ss_);
 
     virtual bool draw(const SRenderData& data);
+    void         renderRect(CColor color);
 
   private:
     // if needed

commit 67d27089d06182c00ad216c3363ebdd801ca7bb4
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Sun Jul 7 21:44:53 2024 +0200

    core: handle missing wayland protocol support (#408)
    
    * core: check support of wp_factional_scale_manager_v1 and wp_viewporter
    
    * core: check support of zwlr_screencopy_manager_v1

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 162946b..006a2eb 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -53,12 +53,20 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
         exit(1);
     }
 
-    fractional = wp_fractional_scale_manager_v1_get_fractional_scale(g_pHyprlock->getFractionalMgr(), surface);
-    if (fractional) {
-        wp_fractional_scale_v1_add_listener(fractional, &fsListener, this);
-        viewport = wp_viewporter_get_viewport(g_pHyprlock->getViewporter(), surface);
-    } else
+    const auto PFRACTIONALMGR = g_pHyprlock->getFractionalMgr();
+    const auto PVIEWPORTER    = g_pHyprlock->getViewporter();
+    if (PFRACTIONALMGR && PVIEWPORTER) {
+        fractional = wp_fractional_scale_manager_v1_get_fractional_scale(PFRACTIONALMGR, surface);
+        if (fractional) {
+            wp_fractional_scale_v1_add_listener(fractional, &fsListener, this);
+            viewport = wp_viewporter_get_viewport(PVIEWPORTER, surface);
+        }
+    }
+
+    if (!PFRACTIONALMGR || !fractional)
         Debug::log(LOG, "No fractional-scale support! Oops, won't be able to scale!");
+    if (!PVIEWPORTER)
+        Debug::log(LOG, "No viewporter support! Oops, won't be able to scale!");
 
     lockSurface = ext_session_lock_v1_get_lock_surface(g_pHyprlock->getSessionLock(), surface, output->output);
 
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index df98349..e43392a 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -12,6 +12,17 @@
 #include "../helpers/Webp.hpp"
 
 CAsyncResourceGatherer::CAsyncResourceGatherer() {
+    if (g_pHyprlock->getScreencopy())
+        enqueueDMAFrames();
+
+    initialGatherThread = std::thread([this]() { this->gather(); });
+    initialGatherThread.detach();
+
+    asyncLoopThread = std::thread([this]() { this->asyncAssetSpinLock(); });
+    asyncLoopThread.detach();
+}
+
+void CAsyncResourceGatherer::enqueueDMAFrames() {
     // some things can't be done async :(
     // gather background textures when needed
 
@@ -48,12 +59,6 @@ CAsyncResourceGatherer::CAsyncResourceGatherer() {
 
         dmas.emplace_back(std::make_unique<CDMAFrame>(PMONITOR));
     }
-
-    initialGatherThread = std::thread([this]() { this->gather(); });
-    initialGatherThread.detach();
-
-    asyncLoopThread = std::thread([this]() { this->asyncAssetSpinLock(); });
-    asyncLoopThread.detach();
 }
 
 SPreloadedAsset* CAsyncResourceGatherer::getAssetByID(const std::string& id) {
diff --git a/src/renderer/AsyncResourceGatherer.hpp b/src/renderer/AsyncResourceGatherer.hpp
index 19defd3..ff4bb5d 100644
--- a/src/renderer/AsyncResourceGatherer.hpp
+++ b/src/renderer/AsyncResourceGatherer.hpp
@@ -86,4 +86,5 @@ class CAsyncResourceGatherer {
     std::unordered_map<std::string, SPreloadedAsset> assets;
 
     void                                             gather();
+    void                                             enqueueDMAFrames();
 };
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 560ceae..26fae5d 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -331,6 +331,12 @@ std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CS
                         if (!asyncResourceGatherer->getAssetByID(resourceID))
                             resourceID = ""; // Fallback to solid color (background:color)
                     }
+
+                    if (!g_pHyprlock->getScreencopy()) {
+                        Debug::log(ERR, "No screencopy support! path=screenshot won't work. Falling back to background color.");
+                        resourceID = "";
+                    }
+
                 } else if (!PATH.empty())
                     resourceID = "background:" + PATH;
 

commit f1b1874f3bda8bd01cf3efe11979d3d45942f9cd
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Mon Jul 8 14:25:06 2024 +0200

    auth: don't start pam conversation before the initial input happens (#409)
    
    After realizing that pam modules sometimes implement a timeout, i think
    it is not worth starting the convo it right away.
    Now you won't get the initial PAM_PROMPT any more.
    Prompt will be initialized to "Password: ", which is most commonly what
    you get from pam. Subsequent prompts (e.g. 2fa) will be handled however.

diff --git a/src/core/Auth.cpp b/src/core/Auth.cpp
index a4ca2f1..90857c6 100644
--- a/src/core/Auth.cpp
+++ b/src/core/Auth.cpp
@@ -32,7 +32,7 @@ int conv(int num_msg, const struct pam_message** msg, struct pam_response** resp
 
                 // Some pam configurations ask for the password twice for whatever reason (Fedora su for example)
                 // When the prompt is the same as the last one, I guess our answer can be the same.
-                if (initialPrompt || PROMPTCHANGED) {
+                if (!initialPrompt && PROMPTCHANGED) {
                     CONVERSATIONSTATE->prompt = PROMPT;
                     g_pAuth->waitForInput();
                 }
@@ -70,6 +70,8 @@ static void passwordCheckTimerCallback(std::shared_ptr<CTimer> self, void* data)
 void CAuth::start() {
     std::thread([this]() {
         resetConversation();
+        m_sConversationState.prompt = "Password: ";
+        waitForInput();
         auth();
 
         g_pHyprlock->addTimer(std::chrono::milliseconds(1), passwordCheckTimerCallback, nullptr);

commit 43be6b4089d9e6ea540352a8a72a6a8f56d3da4d
Author: Jasson <Jasson.cordones@hotmail.com>
Date:   Tue Jul 9 05:32:49 2024 -0400

    core: Label exception handling + Frambuffer checks + headers (#413)
    
    * Added exception handling in label constructor
    
    * Framebuffer fix + moved headers
    
    * added optional header

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 990bfe5..013d4a5 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -1,5 +1,6 @@
 #include "ConfigManager.hpp"
 #include "../helpers/MiscFunctions.hpp"
+#include "src/helpers/Log.hpp"
 #include <filesystem>
 #include <glob.h>
 #include <cstring>
diff --git a/src/config/ConfigManager.hpp b/src/config/ConfigManager.hpp
index 8b2f373..eedf85c 100644
--- a/src/config/ConfigManager.hpp
+++ b/src/config/ConfigManager.hpp
@@ -1,9 +1,7 @@
 #pragma once
 
-#include "../helpers/Log.hpp"
-
 #include <hyprlang.hpp>
-
+#include <optional>
 #include <vector>
 #include <memory>
 #include <unordered_map>
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 7b3e856..5d0fb2b 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -4,7 +4,7 @@
 #include "../renderer/Renderer.hpp"
 #include "Auth.hpp"
 #include "Egl.hpp"
-
+#include "linux-dmabuf-unstable-v1-protocol.h"
 #include <sys/wait.h>
 #include <sys/poll.h>
 #include <sys/mman.h>
@@ -1111,7 +1111,7 @@ void CHyprlock::attemptRestoreOnDeath() {
         return;
 
     // dirty hack
-    uint64_t   timeNowMs = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - std::chrono::system_clock::from_time_t({0})).count();
+    uint64_t   timeNowMs = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - std::chrono::system_clock::from_time_t(0)).count();
 
     const auto LASTRESTARTPATH = std::string{XDG_RUNTIME_DIR} + "/.hyprlockrestart";
 
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 67a4d37..97b1680 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -3,14 +3,11 @@
 #include <wayland-client.h>
 #include "ext-session-lock-v1-protocol.h"
 #include "fractional-scale-v1-protocol.h"
-#include "linux-dmabuf-unstable-v1-protocol.h"
 #include "wlr-screencopy-unstable-v1-protocol.h"
 #include "viewporter-protocol.h"
 #include "Output.hpp"
 #include "CursorShape.hpp"
 #include "Timer.hpp"
-#include "Auth.hpp"
-
 #include <memory>
 #include <vector>
 #include <condition_variable>
diff --git a/src/helpers/Box.cpp b/src/helpers/Box.cpp
index 9b88218..44f43a9 100644
--- a/src/helpers/Box.cpp
+++ b/src/helpers/Box.cpp
@@ -1,5 +1,5 @@
 #include "Box.hpp"
-
+#include <cmath>
 #include <limits>
 #include <algorithm>
 
diff --git a/src/helpers/Box.hpp b/src/helpers/Box.hpp
index c5f30d3..c9ce977 100644
--- a/src/helpers/Box.hpp
+++ b/src/helpers/Box.hpp
@@ -1,5 +1,4 @@
 #pragma once
-
 #include "Vector2D.hpp"
 
 class CBox {
diff --git a/src/helpers/Jpeg.cpp b/src/helpers/Jpeg.cpp
index 3616744..d63e802 100644
--- a/src/helpers/Jpeg.cpp
+++ b/src/helpers/Jpeg.cpp
@@ -1,6 +1,5 @@
 #include "Jpeg.hpp"
 #include "Log.hpp"
-
 #include <jpeglib.h>
 #include <sys/stat.h>
 #include <sys/types.h>
diff --git a/src/helpers/Log.hpp b/src/helpers/Log.hpp
index e11da90..d2bf211 100644
--- a/src/helpers/Log.hpp
+++ b/src/helpers/Log.hpp
@@ -19,7 +19,7 @@ enum eLogLevel {
                    std::format(reason, ##__VA_ARGS__), __LINE__,                                                                                                                   \
                    ([]() constexpr -> std::string { return std::string(__FILE__).substr(std::string(__FILE__).find_last_of('/') + 1); })().c_str());                               \
         printf("Assertion failed! See the log in /tmp/hypr/hyprland.log for more info.");                                                                                          \
-        *((int*)nullptr) = 1; /* so that we crash and get a coredump */                                                                                                            \
+        std::abort();                                                                                                         \
     }
 
 #define ASSERT(expr) RASSERT(expr, "?")
diff --git a/src/helpers/MiscFunctions.hpp b/src/helpers/MiscFunctions.hpp
index aaaee3b..bbac1a0 100644
--- a/src/helpers/MiscFunctions.hpp
+++ b/src/helpers/MiscFunctions.hpp
@@ -1,6 +1,6 @@
 #pragma once
 
 #include <string>
-#include <optional>
+
 
 std::string absolutePath(const std::string&, const std::string&);
diff --git a/src/helpers/Vector2D.hpp b/src/helpers/Vector2D.hpp
index 188d4b9..8e19408 100644
--- a/src/helpers/Vector2D.hpp
+++ b/src/helpers/Vector2D.hpp
@@ -1,6 +1,5 @@
 #pragma once
 
-#include <cmath>
 #include <format>
 #include <hyprlang.hpp>
 
diff --git a/src/main.cpp b/src/main.cpp
index 2cf92b7..f97945e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,7 +1,9 @@
 
 #include "config/ConfigManager.hpp"
 #include "core/hyprlock.hpp"
+#include "src/helpers/Log.hpp"
 #include <cstddef>
+#include <iostream>
 
 void help() {
     std::cout << "Usage: hyprlock [options]\n\n"
diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index e43392a..59e593e 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -10,6 +10,8 @@
 #include "../helpers/MiscFunctions.hpp"
 #include "../helpers/Jpeg.hpp"
 #include "../helpers/Webp.hpp"
+#include "src/helpers/Color.hpp"
+#include "src/helpers/Log.hpp"
 
 CAsyncResourceGatherer::CAsyncResourceGatherer() {
     if (g_pHyprlock->getScreencopy())
@@ -345,7 +347,7 @@ void CAsyncResourceGatherer::renderText(const SPreloadRequest& rq) {
     target.cairo        = CAIRO;
     target.cairosurface = CAIROSURFACE;
     target.data         = cairo_image_surface_get_data(CAIROSURFACE);
-    target.size         = {layoutWidth / PANGO_SCALE, layoutHeight / PANGO_SCALE};
+    target.size         = {layoutWidth / (double)PANGO_SCALE, layoutHeight / (double)PANGO_SCALE};
 
     std::lock_guard lg{preloadTargetsMutex};
     preloadTargets.push_back(target);
diff --git a/src/renderer/AsyncResourceGatherer.hpp b/src/renderer/AsyncResourceGatherer.hpp
index ff4bb5d..7046cec 100644
--- a/src/renderer/AsyncResourceGatherer.hpp
+++ b/src/renderer/AsyncResourceGatherer.hpp
@@ -1,10 +1,6 @@
 #pragma once
 
-#include "Shader.hpp"
-#include "../helpers/Box.hpp"
-#include "../helpers/Color.hpp"
 #include "DMAFrame.hpp"
-#include "Texture.hpp"
 #include <thread>
 #include <atomic>
 #include <vector>
diff --git a/src/renderer/DMAFrame.cpp b/src/renderer/DMAFrame.cpp
index c67c6ac..134ad03 100644
--- a/src/renderer/DMAFrame.cpp
+++ b/src/renderer/DMAFrame.cpp
@@ -1,9 +1,9 @@
 #include "DMAFrame.hpp"
+#include "linux-dmabuf-unstable-v1-protocol.h"
 #include "wlr-screencopy-unstable-v1-protocol.h"
 #include "../helpers/Log.hpp"
 #include "../core/hyprlock.hpp"
 #include "../core/Egl.hpp"
-
 #include <EGL/eglext.h>
 #include <libdrm/drm_fourcc.h>
 #include <GLES3/gl32.h>
diff --git a/src/renderer/DMAFrame.hpp b/src/renderer/DMAFrame.hpp
index 7309432..e4b7c66 100644
--- a/src/renderer/DMAFrame.hpp
+++ b/src/renderer/DMAFrame.hpp
@@ -2,7 +2,6 @@
 
 #include "../core/Output.hpp"
 #include <gbm.h>
-#include "Texture.hpp"
 #include "Shared.hpp"
 
 struct zwlr_screencopy_frame_v1;
diff --git a/src/renderer/Framebuffer.cpp b/src/renderer/Framebuffer.cpp
index 75de303..bec5dc3 100644
--- a/src/renderer/Framebuffer.cpp
+++ b/src/renderer/Framebuffer.cpp
@@ -41,14 +41,14 @@ bool CFramebuffer::alloc(int w, int h, bool highres) {
 
     if (firstAlloc || m_vSize != Vector2D(w, h)) {
         glBindTexture(GL_TEXTURE_2D, m_cTex.m_iTexID);
-        glTexImage2D(GL_TEXTURE_2D, 0, glFormat, w, h, 0, GL_RGBA, glType, 0);
+        glTexImage2D(GL_TEXTURE_2D, 0, glFormat, w, h, 0, GL_RGBA, glType, nullptr);
 
         glBindFramebuffer(GL_FRAMEBUFFER, m_iFb);
         glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_cTex.m_iTexID, 0);
 
         if (m_pStencilTex) {
             glBindTexture(GL_TEXTURE_2D, m_pStencilTex->m_iTexID);
-            glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, w, h, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, 0);
+            glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, w, h, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, nullptr);
 
             glBindFramebuffer(GL_FRAMEBUFFER, m_iFb);
 
@@ -73,15 +73,20 @@ bool CFramebuffer::alloc(int w, int h, bool highres) {
 }
 
 void CFramebuffer::addStencil() {
+    if (!m_pStencilTex) {
+        Debug::log(ERR, "No stencil texture allocated.");
+        return;
+    }
+
     glBindTexture(GL_TEXTURE_2D, m_pStencilTex->m_iTexID);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, m_vSize.x, m_vSize.y, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, 0);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, m_vSize.x, m_vSize.y, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, nullptr);
 
     glBindFramebuffer(GL_FRAMEBUFFER, m_iFb);
 
     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, m_pStencilTex->m_iTexID, 0);
 
     auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
-    RASSERT((status == GL_FRAMEBUFFER_COMPLETE), "Failed adding a stencil to fbo!", status);
+    RASSERT((status == GL_FRAMEBUFFER_COMPLETE), "Failed adding a stencil to fbo! (FB status: {})", status);
 
     glBindTexture(GL_TEXTURE_2D, 0);
     glBindFramebuffer(GL_FRAMEBUFFER, 0);
@@ -99,9 +104,13 @@ void CFramebuffer::release() {
     if (m_cTex.m_iTexID)
         glDeleteTextures(1, &m_cTex.m_iTexID);
 
+    if (m_pStencilTex && m_pStencilTex->m_iTexID)
+        glDeleteTextures(1, &m_pStencilTex->m_iTexID);
+
     m_cTex.m_iTexID = 0;
     m_iFb           = -1;
     m_vSize         = Vector2D();
+    m_pStencilTex   = nullptr;
 }
 
 CFramebuffer::~CFramebuffer() {
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 26fae5d..776fc76 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -6,14 +6,11 @@
 #include "../core/hyprlock.hpp"
 #include "../renderer/DMAFrame.hpp"
 #include "mtx.hpp"
-
 #include <GLES3/gl32.h>
 #include <GLES3/gl3ext.h>
-
 #include <algorithm>
-
 #include "Shaders.hpp"
-
+#include "src/helpers/Log.hpp"
 #include "widgets/PasswordInputField.hpp"
 #include "widgets/Background.hpp"
 #include "widgets/Label.hpp"
diff --git a/src/renderer/Renderer.hpp b/src/renderer/Renderer.hpp
index 07de9bc..77c8e73 100644
--- a/src/renderer/Renderer.hpp
+++ b/src/renderer/Renderer.hpp
@@ -3,7 +3,6 @@
 #include <memory>
 #include <chrono>
 #include <optional>
-
 #include "../core/LockSurface.hpp"
 #include "Shader.hpp"
 #include "../helpers/Box.hpp"
diff --git a/src/renderer/widgets/IWidget.cpp b/src/renderer/widgets/IWidget.cpp
index 31b4ad1..88da0f2 100644
--- a/src/renderer/widgets/IWidget.cpp
+++ b/src/renderer/widgets/IWidget.cpp
@@ -2,6 +2,7 @@
 #include "../../helpers/Log.hpp"
 #include "../../helpers/VarList.hpp"
 #include "../../core/hyprlock.hpp"
+#include "src/core/Auth.hpp"
 #include <chrono>
 #include <unistd.h>
 #include <pwd.h>
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index 29c335b..b7f7c7f 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -1,6 +1,7 @@
 #include "Label.hpp"
 #include "../../helpers/Color.hpp"
 #include <hyprlang.hpp>
+#include <stdexcept>
 #include "../Renderer.hpp"
 #include "../../helpers/Log.hpp"
 #include "../../core/hyprlock.hpp"
@@ -13,6 +14,8 @@ CLabel::~CLabel() {
 }
 
 static void onTimer(std::shared_ptr<CTimer> self, void* data) {
+    if (data == nullptr)
+        return;
     const auto PLABEL = (CLabel*)data;
 
     // update label
@@ -64,41 +67,49 @@ void CLabel::plantTimer() {
 
 CLabel::CLabel(const Vector2D& viewport_, const std::unordered_map<std::string, std::any>& props, const std::string& output) :
     outputStringPort(output), shadow(this, props, viewport_) {
-    labelPreFormat         = std::any_cast<Hyprlang::STRING>(props.at("text"));
-    std::string textAlign  = std::any_cast<Hyprlang::STRING>(props.at("text_align"));
-    std::string fontFamily = std::any_cast<Hyprlang::STRING>(props.at("font_family"));
-    CColor      labelColor = std::any_cast<Hyprlang::INT>(props.at("color"));
-    int         fontSize   = std::any_cast<Hyprlang::INT>(props.at("font_size"));
-
-    label = formatString(labelPreFormat);
-
-    request.id                   = getUniqueResourceId();
-    resourceID                   = request.id;
-    request.asset                = label.formatted;
-    request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
-    request.props["font_family"] = fontFamily;
-    request.props["color"]       = labelColor;
-    request.props["font_size"]   = fontSize;
-    request.props["cmd"]         = label.cmd;
-
-    if (!textAlign.empty())
-        request.props["text_align"] = textAlign;
-
-    g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
-
-    auto POS__ = std::any_cast<Hyprlang::VEC2>(props.at("position"));
-    pos        = {POS__.x, POS__.y};
-    configPos  = pos;
-
-    viewport = viewport_;
-
-    halign = std::any_cast<Hyprlang::STRING>(props.at("halign"));
-    valign = std::any_cast<Hyprlang::STRING>(props.at("valign"));
-
-    angle = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
-    angle = angle * M_PI / 180.0;
-
-    plantTimer();
+    try {
+        labelPreFormat         = std::any_cast<Hyprlang::STRING>(props.at("text"));
+        std::string textAlign  = std::any_cast<Hyprlang::STRING>(props.at("text_align"));
+        std::string fontFamily = std::any_cast<Hyprlang::STRING>(props.at("font_family"));
+        CColor      labelColor = std::any_cast<Hyprlang::INT>(props.at("color"));
+        int         fontSize   = std::any_cast<Hyprlang::INT>(props.at("font_size"));
+
+        label = formatString(labelPreFormat);
+
+        request.id                   = getUniqueResourceId();
+        resourceID                   = request.id;
+        request.asset                = label.formatted;
+        request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
+        request.props["font_family"] = fontFamily;
+        request.props["color"]       = labelColor;
+        request.props["font_size"]   = fontSize;
+        request.props["cmd"]         = label.cmd;
+
+        if (!textAlign.empty())
+            request.props["text_align"] = textAlign;
+
+        g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
+
+        auto POS__ = std::any_cast<Hyprlang::VEC2>(props.at("position"));
+        pos        = {POS__.x, POS__.y};
+        configPos  = pos;
+
+        viewport = viewport_;
+
+        halign = std::any_cast<Hyprlang::STRING>(props.at("halign"));
+        valign = std::any_cast<Hyprlang::STRING>(props.at("valign"));
+
+        angle = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
+        angle = angle * M_PI / 180.0;
+
+        plantTimer();
+    } catch (const std::bad_any_cast& e) {
+        Debug::log(ERR, "Failed to construct CLabel: {}", e.what());
+        throw;
+    } catch (const std::out_of_range& e) {
+        Debug::log(ERR, "Missing propperty for CLabel:{}", e.what());
+        throw;
+    }
 }
 
 bool CLabel::draw(const SRenderData& data) {
diff --git a/src/renderer/widgets/Label.hpp b/src/renderer/widgets/Label.hpp
index eb6a775..26b938d 100644
--- a/src/renderer/widgets/Label.hpp
+++ b/src/renderer/widgets/Label.hpp
@@ -42,7 +42,7 @@ class CLabel : public IWidget {
 
     CAsyncResourceGatherer::SPreloadRequest request;
 
-    std::shared_ptr<CTimer>                 labelTimer;
+    std::shared_ptr<CTimer>                 labelTimer = nullptr;
 
     CShadowable                             shadow;
 };
diff --git a/src/renderer/widgets/Shadowable.hpp b/src/renderer/widgets/Shadowable.hpp
index 5dafb68..7e222a8 100644
--- a/src/renderer/widgets/Shadowable.hpp
+++ b/src/renderer/widgets/Shadowable.hpp
@@ -1,7 +1,6 @@
 #pragma once
 
 #include "../Framebuffer.hpp"
-#include "../Texture.hpp"
 #include "../../helpers/Color.hpp"
 #include "IWidget.hpp"
 

commit 67d39756128cdc3bffab1521438a4c43a95ddb6d
Author: davc0n <dconti.dev@gmail.com>
Date:   Tue Jul 9 17:43:31 2024 +0200

    config: add input-field fail_timeout option (#406)
    
    * config: add input-field fail_timeout option
    
    * config: change input-field fail_timeout to milliseconds
    
    * input-field: fix configFailTimeoutMs type and init

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 013d4a5..30d7b9f 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -125,6 +125,7 @@ void CConfigManager::init() {
     m_config.addSpecialConfigValue("input-field", "check_color", Hyprlang::INT{0xFFCC8822});
     m_config.addSpecialConfigValue("input-field", "fail_color", Hyprlang::INT{0xFFCC2222});
     m_config.addSpecialConfigValue("input-field", "fail_text", Hyprlang::STRING{"<i>$FAIL</i>"});
+    m_config.addSpecialConfigValue("input-field", "fail_timeout", Hyprlang::INT{2000});
     m_config.addSpecialConfigValue("input-field", "fail_transition", Hyprlang::INT{300});
     m_config.addSpecialConfigValue("input-field", "capslock_color", Hyprlang::INT{-1});
     m_config.addSpecialConfigValue("input-field", "numlock_color", Hyprlang::INT{-1});
@@ -277,6 +278,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
                 {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
                 {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},
+                {"fail_timeout", m_config.getSpecialConfigValue("input-field", "fail_timeout", k.c_str())},
                 {"fail_transition", m_config.getSpecialConfigValue("input-field", "fail_transition", k.c_str())},
                 {"capslock_color", m_config.getSpecialConfigValue("input-field", "capslock_color", k.c_str())},
                 {"numlock_color", m_config.getSpecialConfigValue("input-field", "numlock_color", k.c_str())},
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 5d0fb2b..1114f87 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -760,12 +760,6 @@ static const ext_session_lock_v1_listener sessionLockListener = {
 
 // end session_lock
 
-static void displayFailTextTimerCallback(std::shared_ptr<CTimer> self, void* data) {
-    g_pAuth->m_bDisplayFailText = false;
-
-    g_pHyprlock->renderAllOutputs();
-}
-
 void CHyprlock::onPasswordCheckTimer() {
     // check result
     if (g_pAuth->didAuthSucceed()) {
@@ -778,8 +772,6 @@ void CHyprlock::onPasswordCheckTimer() {
         g_pAuth->m_bDisplayFailText = true;
         forceUpdateTimers();
 
-        g_pHyprlock->addTimer(/* controls error message duration */ std::chrono::seconds(1), displayFailTextTimerCallback, nullptr);
-
         g_pAuth->start();
 
         renderAllOutputs();
diff --git a/src/renderer/widgets/PasswordInputField.cpp b/src/renderer/widgets/PasswordInputField.cpp
index 4feb778..fab0cab 100644
--- a/src/renderer/widgets/PasswordInputField.cpp
+++ b/src/renderer/widgets/PasswordInputField.cpp
@@ -28,6 +28,7 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
     rounding                 = std::any_cast<Hyprlang::INT>(props.at("rounding"));
     configPlaceholderText    = std::any_cast<Hyprlang::STRING>(props.at("placeholder_text"));
     configFailText           = std::any_cast<Hyprlang::STRING>(props.at("fail_text"));
+    configFailTimeoutMs      = std::any_cast<Hyprlang::INT>(props.at("fail_timeout"));
     col.transitionMs         = std::any_cast<Hyprlang::INT>(props.at("fail_transition"));
     col.outer                = std::any_cast<Hyprlang::INT>(props.at("outer_color"));
     col.inner                = std::any_cast<Hyprlang::INT>(props.at("inner_color"));
@@ -304,6 +305,11 @@ bool CPasswordInputField::draw(const SRenderData& data) {
     return dots.currentAmount != passwordLength || fade.animated || col.animated || redrawShadow || data.opacity < 1.0 || forceReload;
 }
 
+static void failTimeoutCallback(std::shared_ptr<CTimer> self, void* data) {
+    g_pAuth->m_bDisplayFailText = false;
+    g_pHyprlock->renderAllOutputs();
+}
+
 void CPasswordInputField::updatePlaceholder() {
     if (passwordLength != 0) {
         if (placeholder.asset && /* keep prompt asset cause it is likely to be used again */ placeholder.isFailText) {
@@ -328,6 +334,7 @@ void CPasswordInputField::updatePlaceholder() {
     placeholder.asset = nullptr;
 
     if (placeholder.isFailText) {
+        g_pHyprlock->addTimer(std::chrono::milliseconds(configFailTimeoutMs), failTimeoutCallback, nullptr);
         placeholder.currentText = configFailText;
         replaceAll(placeholder.currentText, "$FAIL", AUTHFEEDBACK);
         replaceAll(placeholder.currentText, "$ATTEMPTS", std::to_string(placeholder.failedAttempts));
diff --git a/src/renderer/widgets/PasswordInputField.hpp b/src/renderer/widgets/PasswordInputField.hpp
index a85f0a2..d1bbb73 100644
--- a/src/renderer/widgets/PasswordInputField.hpp
+++ b/src/renderer/widgets/PasswordInputField.hpp
@@ -39,6 +39,7 @@ class CPasswordInputField : public IWidget {
     Vector2D    configSize;
 
     std::string halign, valign, configFailText, outputStringPort, configPlaceholderText;
+    uint64_t    configFailTimeoutMs = 2000;
 
     int         outThick, rounding;
 

commit db3b5ba1635ac12fba5c16c090e27fb267a2988b
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Jul 10 12:05:18 2024 +0200

    asyncResourceGatherer: trace logs and exit behaviour (#414)
    
    * asyncResourceGatherer: add trace logs
    
    useful for debugging label updates
    
    * label: remove unused onAssetCallbackTimer
    
    * asyncResourceGatherer: fix crashes on exit

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 59e593e..18282ff 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -385,6 +385,8 @@ void CAsyncResourceGatherer::asyncAssetSpinLock() {
 
         // process requests
         for (auto& r : requests) {
+            Debug::log(TRACE, "Processing requested resourceID {}", r.id);
+
             if (r.type == TARGET_TEXT) {
                 renderText(r);
             } else if (r.type == TARGET_IMAGE) {
@@ -399,11 +401,11 @@ void CAsyncResourceGatherer::asyncAssetSpinLock() {
                 g_pHyprlock->addTimer(std::chrono::milliseconds(0), timerCallback, new STimerCallbackData{r.callback, r.callbackData});
         }
     }
-
-    dmas.clear();
 }
 
 void CAsyncResourceGatherer::requestAsyncAssetPreload(const SPreloadRequest& request) {
+    Debug::log(TRACE, "Requesting label resource {}", request.id);
+
     std::lock_guard<std::mutex> lg(asyncLoopState.requestsMutex);
     asyncLoopState.requests.push_back(request);
     asyncLoopState.pending = true;
@@ -416,13 +418,14 @@ void CAsyncResourceGatherer::unloadAsset(SPreloadedAsset* asset) {
 
 void CAsyncResourceGatherer::notify() {
     std::lock_guard<std::mutex> lg(asyncLoopState.requestsMutex);
+    asyncLoopState.requests.clear();
     asyncLoopState.pending = true;
     asyncLoopState.requestsCV.notify_all();
 }
 
 void CAsyncResourceGatherer::await() {
-    if (asyncLoopThread.joinable())
-        asyncLoopThread.join();
     if (initialGatherThread.joinable())
         initialGatherThread.join();
+    if (asyncLoopThread.joinable())
+        asyncLoopThread.join();
 }
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index b7f7c7f..adc09ed 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -147,11 +147,6 @@ bool CLabel::draw(const SRenderData& data) {
     return false;
 }
 
-static void onAssetCallbackTimer(std::shared_ptr<CTimer> self, void* data) {
-    const auto PLABEL = (CLabel*)data;
-    PLABEL->renderSuper();
-}
-
 void CLabel::renderSuper() {
     g_pHyprlock->renderOutput(outputStringPort);
 }

commit 01a9b096cbc0ff9737b73790a1d90cf72fc848c7
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Thu Jul 11 16:15:32 2024 +0200

    core: handle ext_session_lock_v1::finished as defined in the protocol (#418)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 1114f87..9359ce0 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -959,8 +959,15 @@ void CHyprlock::onLockLocked() {
 
 void CHyprlock::onLockFinished() {
     Debug::log(LOG, "onLockFinished called. Seems we got yeeten. Is another lockscreen running?");
-    g_pRenderer = nullptr;
-    exit(1);
+    if (m_bLocked)
+        // The `finished` event specifies that whenever the `locked` event has been recieved and the compositor sends `finished`,
+        // `unlock_and_destroy` should be called by the client.
+        // This does not mean the session gets unlocked! That is ultimatly the responsiblity of the compositor.
+        ext_session_lock_v1_unlock_and_destroy(m_sLockState.lock);
+    else
+        ext_session_lock_v1_destroy(m_sLockState.lock);
+
+    m_bTerminate = true;
 }
 
 ext_session_lock_manager_v1* CHyprlock::getSessionLockMgr() {

commit 311f8cc2012526741c1cdded16a01e8cf2cca514
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Sun Jul 14 16:59:06 2024 +0200

    core: immediately create session lock surfaces (#421)
    
    * core: immediately create session lock surfaces
    
    Instead of waiting for the `locked` event, create session lock surfaces
    right away.
    
    * core: don't allow unlock_and_destroy if `locked` has never been recieved

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 9359ce0..727d5c7 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -400,6 +400,9 @@ void CHyprlock::run() {
 
     acquireSessionLock();
 
+    if (m_bTerminate) // Recieved finished
+        exit(1);
+
     g_pAuth = std::make_unique<CAuth>();
     g_pAuth->start();
 
@@ -409,6 +412,8 @@ void CHyprlock::run() {
     registerSignalAction(SIGSEGV, handleCriticalSignal);
     registerSignalAction(SIGABRT, handleCriticalSignal);
 
+    createSessionLockSurfaces();
+
     pollfd pollfds[] = {
         {
             .fd     = wl_display_get_fd(m_sWaylandState.display),
@@ -925,7 +930,7 @@ void CHyprlock::acquireSessionLock() {
     m_sLockState.lock = ext_session_lock_manager_v1_lock(m_sWaylandState.sessionLock);
     ext_session_lock_v1_add_listener(m_sLockState.lock, &sessionLockListener, nullptr);
 
-    // wait for wayland to signal whether the session lock has been acquired
+    // roundtrip in case the compositor sends `finished` right away
     wl_display_roundtrip(m_sWaylandState.display);
 }
 
@@ -936,6 +941,12 @@ void CHyprlock::releaseSessionLock() {
         return;
     }
 
+    if (!m_bLocked) {
+        // Would be a protocol error to allow this
+        Debug::log(ERR, "Trying to unlock the session, but never recieved the locked event!");
+        return;
+    }
+
     ext_session_lock_v1_unlock_and_destroy(m_sLockState.lock);
     m_sLockState.lock = nullptr;
 
@@ -947,12 +958,14 @@ void CHyprlock::releaseSessionLock() {
     wl_display_roundtrip(m_sWaylandState.display);
 }
 
-void CHyprlock::onLockLocked() {
-    Debug::log(LOG, "onLockLocked called");
-
+void CHyprlock::createSessionLockSurfaces() {
     for (auto& o : m_vOutputs) {
         o->sessionLockSurface = std::make_unique<CSessionLockSurface>(o.get());
     }
+}
+
+void CHyprlock::onLockLocked() {
+    Debug::log(LOG, "onLockLocked called");
 
     m_bLocked = true;
 }
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 97b1680..7d34c51 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -46,6 +46,8 @@ class CHyprlock {
     void                            acquireSessionLock();
     void                            releaseSessionLock();
 
+    void                            createSessionLockSurfaces();
+
     void                            attemptRestoreOnDeath();
 
     void                            spawnAsync(const std::string& cmd);

commit b56a9475580435627346f10ded300ec00f407cf2
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Jul 17 15:22:42 2024 +0200

    core: grace unlock improvements and auth fixes for grace/SIGUSR1 unlocks (#424)
    
    * core: check m_bTerminate for grace unlocks
    
    * core: remove reference to the lock object on finished
    
    * core: add isUnlocked
    
    true if m_bFadeStarted or m_bTerminate
    
    * auth: return early on grace or SIGUSR1 unlocks

diff --git a/src/core/Auth.cpp b/src/core/Auth.cpp
index 90857c6..eb7dffa 100644
--- a/src/core/Auth.cpp
+++ b/src/core/Auth.cpp
@@ -38,7 +38,7 @@ int conv(int num_msg, const struct pam_message** msg, struct pam_response** resp
                 }
 
                 // Needed for unlocks via SIGUSR1
-                if (g_pHyprlock->m_bTerminate)
+                if (g_pHyprlock->isUnlocked())
                     return PAM_CONV_ERR;
 
                 pamReply[i].resp = strdup(CONVERSATIONSTATE->input.c_str());
@@ -70,9 +70,21 @@ static void passwordCheckTimerCallback(std::shared_ptr<CTimer> self, void* data)
 void CAuth::start() {
     std::thread([this]() {
         resetConversation();
+
+        // Initial input
         m_sConversationState.prompt = "Password: ";
         waitForInput();
-        auth();
+
+        // For grace or SIGUSR1 unlocks
+        if (g_pHyprlock->isUnlocked())
+            return;
+
+        const auto AUTHENTICATED = auth();
+        m_bAuthenticated         = AUTHENTICATED;
+
+        // For SIGUSR1 unlocks
+        if (g_pHyprlock->isUnlocked())
+            return;
 
         g_pHyprlock->addTimer(std::chrono::milliseconds(1), passwordCheckTimerCallback, nullptr);
     }).detach();
@@ -86,7 +98,6 @@ bool CAuth::auth() {
     int            ret = pam_start(m_sPamModule.c_str(), uidPassword->pw_name, &localConv, &handle);
 
     if (ret != PAM_SUCCESS) {
-        m_sConversationState.success  = false;
         m_sConversationState.failText = "pam_start failed";
         Debug::log(ERR, "auth: pam_start failed for {}", m_sPamModule);
         return false;
@@ -99,21 +110,19 @@ bool CAuth::auth() {
     m_sConversationState.waitingForPamAuth = false;
 
     if (ret != PAM_SUCCESS) {
-        m_sConversationState.success  = false;
         m_sConversationState.failText = ret == PAM_AUTH_ERR ? "Authentication failed" : "pam_authenticate failed";
         Debug::log(ERR, "auth: {} for {}", m_sConversationState.failText, m_sPamModule);
         return false;
     }
 
-    m_sConversationState.success  = true;
     m_sConversationState.failText = "Successfully authenticated";
     Debug::log(LOG, "auth: authenticated for {}", m_sPamModule);
 
     return true;
 }
 
-bool CAuth::didAuthSucceed() {
-    return m_sConversationState.success;
+bool CAuth::isAuthenticated() {
+    return m_bAuthenticated;
 }
 
 // clearing the input must be done from the main thread
@@ -164,5 +173,4 @@ void CAuth::resetConversation() {
     m_sConversationState.input             = "";
     m_sConversationState.waitingForPamAuth = false;
     m_sConversationState.inputRequested    = false;
-    m_sConversationState.success           = false;
 }
diff --git a/src/core/Auth.hpp b/src/core/Auth.hpp
index b0fea79..d480c71 100644
--- a/src/core/Auth.hpp
+++ b/src/core/Auth.hpp
@@ -18,15 +18,13 @@ class CAuth {
 
         bool                    waitingForPamAuth = false;
         bool                    inputRequested    = false;
-
-        bool                    success = false;
     };
 
     CAuth();
 
     void                       start();
     bool                       auth();
-    bool                       didAuthSucceed();
+    bool                       isAuthenticated();
 
     void                       waitForInput();
     void                       submitInput(std::string input);
@@ -44,7 +42,8 @@ class CAuth {
   private:
     SPamConversationState m_sConversationState;
 
-    bool                  m_bBlockInput = true;
+    bool                  m_bBlockInput    = true;
+    bool                  m_bAuthenticated = false;
 
     std::string           m_sPamModule;
 
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 727d5c7..56a6248 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -585,6 +585,10 @@ void CHyprlock::unlock() {
     renderAllOutputs();
 }
 
+bool CHyprlock::isUnlocked() {
+    return m_bFadeStarted || m_bTerminate;
+}
+
 // wl_seat
 
 static void handlePointerEnter(void* data, struct wl_pointer* wl_pointer, uint32_t serial, struct wl_surface* surface, wl_fixed_t surface_x, wl_fixed_t surface_y) {
@@ -610,9 +614,10 @@ static void handlePointerAxis(void* data, wl_pointer* wl_pointer, uint32_t time,
 }
 
 static void handlePointerMotion(void* data, struct wl_pointer* wl_pointer, uint32_t time, wl_fixed_t surface_x, wl_fixed_t surface_y) {
-    if (g_pHyprlock->m_vLastEnterCoords.distance({wl_fixed_to_double(surface_x), wl_fixed_to_double(surface_y)}) > 5 &&
-        std::chrono::system_clock::now() < g_pHyprlock->m_tGraceEnds && !g_pHyprlock->m_bFadeStarted) {
+    if (std::chrono::system_clock::now() > g_pHyprlock->m_tGraceEnds)
+        return;
 
+    if (!g_pHyprlock->isUnlocked() && g_pHyprlock->m_vLastEnterCoords.distance({wl_fixed_to_double(surface_x), wl_fixed_to_double(surface_y)}) > 5) {
         Debug::log(LOG, "In grace and cursor moved more than 5px, unlocking!");
         g_pHyprlock->unlock();
     }
@@ -767,13 +772,13 @@ static const ext_session_lock_v1_listener sessionLockListener = {
 
 void CHyprlock::onPasswordCheckTimer() {
     // check result
-    if (g_pAuth->didAuthSucceed()) {
+    if (g_pAuth->isAuthenticated()) {
         unlock();
     } else {
-        Debug::log(LOG, "Failed attempts: {}", m_sPasswordState.failedAttempts);
-
         m_sPasswordState.passBuffer = "";
         m_sPasswordState.failedAttempts += 1;
+        Debug::log(LOG, "Failed attempts: {}", m_sPasswordState.failedAttempts);
+
         g_pAuth->m_bDisplayFailText = true;
         forceUpdateTimers();
 
@@ -843,7 +848,7 @@ void CHyprlock::repeatKey(xkb_keysym_t sym) {
 }
 
 void CHyprlock::onKey(uint32_t key, bool down) {
-    if (m_bFadeStarted)
+    if (m_bFadeStarted || m_bTerminate)
         return;
 
     if (down && std::chrono::system_clock::now() < m_tGraceEnds) {
@@ -980,7 +985,8 @@ void CHyprlock::onLockFinished() {
     else
         ext_session_lock_v1_destroy(m_sLockState.lock);
 
-    m_bTerminate = true;
+    m_sLockState.lock = nullptr;
+    m_bTerminate      = true;
 }
 
 ext_session_lock_manager_v1* CHyprlock::getSessionLockMgr() {
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 7d34c51..c66d61f 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -31,6 +31,7 @@ class CHyprlock {
     void                            run();
 
     void                            unlock();
+    bool                            isUnlocked();
 
     void                            onGlobal(void* data, struct wl_registry* registry, uint32_t name, const char* interface, uint32_t version);
     void                            onGlobalRemoved(void* data, struct wl_registry* registry, uint32_t name);

commit 14a0e6b5f17f920332eae4872dc88a9a5181eea7
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Fri Jul 19 17:26:38 2024 +0200

    core: make sure m_sLockState.lock is present in onLockFinished and releaseSessionLock (#432)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 56a6248..2dc881c 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -941,11 +941,16 @@ void CHyprlock::acquireSessionLock() {
 
 void CHyprlock::releaseSessionLock() {
     Debug::log(LOG, "Unlocking session");
-    if (m_bTerminate && !m_sLockState.lock) {
+    if (m_bTerminate) {
         Debug::log(ERR, "Unlock already happend?");
         return;
     }
 
+    if (!m_sLockState.lock) {
+        Debug::log(ERR, "Unlock without a lock object!");
+        return;
+    }
+
     if (!m_bLocked) {
         // Would be a protocol error to allow this
         Debug::log(ERR, "Trying to unlock the session, but never recieved the locked event!");
@@ -977,6 +982,12 @@ void CHyprlock::onLockLocked() {
 
 void CHyprlock::onLockFinished() {
     Debug::log(LOG, "onLockFinished called. Seems we got yeeten. Is another lockscreen running?");
+
+    if (!m_sLockState.lock) {
+        Debug::log(ERR, "onLockFinished without a lock object!");
+        return;
+    }
+
     if (m_bLocked)
         // The `finished` event specifies that whenever the `locked` event has been recieved and the compositor sends `finished`,
         // `unlock_and_destroy` should be called by the client.

commit 581f2a04945ca8e6531e3964d57b663bc511ff4f
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Fri Jul 19 23:20:31 2024 +0200

    asyncResourceGatherer: deduplicate image rendering code (#433)
    
    * asyncResourceGatherer: deduplicate image rendering code
    
    Also happens to add support for JPEG and WEBP for image widgets
    
    * asyncResourceGatherer: use a reference for path in getFileType

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 18282ff..17627ed 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -91,6 +91,51 @@ enum class FileType {
     UNKNOWN,
 };
 
+FileType getFileType(const std::filesystem::path& path) {
+    std::string ext = path.extension().string();
+    // convert the extension to lower case
+    std::transform(ext.begin(), ext.end(), ext.begin(), [](char c) { return c <= 'Z' && c >= 'A' ? c - ('Z' - 'z') : c; });
+
+    FileType ft = FileType::UNKNOWN;
+    Debug::log(TRACE, "Extension: {}", ext);
+    if (ext == ".png")
+        ft = FileType::PNG;
+    else if (ext == ".jpg" || ext == ".jpeg")
+        ft = FileType::JPEG;
+    else if (ext == ".webp")
+        ft = FileType::WEBP;
+    else {
+        // magic is slow, so only use it when no recognized extension is found
+        auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS);
+        magic_load(handle, nullptr);
+
+        const auto type_str   = std::string(magic_file(handle, path.c_str()));
+        const auto first_word = type_str.substr(0, type_str.find(" "));
+        magic_close(handle);
+
+        if (first_word == "PNG")
+            ft = FileType::PNG;
+        else if (first_word == "JPEG")
+            ft = FileType::JPEG;
+        else if (first_word == "RIFF" && type_str.find("Web/P image") != std::string::npos)
+            ft = FileType::WEBP;
+    }
+
+    return ft;
+}
+
+cairo_surface_t* getCairoSurfaceFromImageFile(const std::filesystem::path& path) {
+    cairo_surface_t* cairoSurface = nullptr;
+    switch (getFileType(path)) {
+        case FileType::PNG: cairoSurface = cairo_image_surface_create_from_png(path.c_str()); break;
+        case FileType::JPEG: cairoSurface = JPEG::createSurfaceFromJPEG(path); break;
+        case FileType::WEBP: cairoSurface = WEBP::createSurfaceFromWEBP(path); break;
+        default: Debug::log(ERR, "unrecognized image format of {}", path.c_str());
+    }
+
+    return cairoSurface;
+}
+
 void CAsyncResourceGatherer::gather() {
     const auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
 
@@ -117,67 +162,15 @@ void CAsyncResourceGatherer::gather() {
             if (path.empty() || path == "screenshot")
                 continue;
 
-            std::string           id = (c.type == "background" ? std::string{"background:"} : std::string{"image:"}) + path;
-            std::filesystem::path ABSOLUTEPATH(absolutePath(path, ""));
-
-            // determine the file type
-            std::string ext = ABSOLUTEPATH.extension().string();
-            // convert the extension to lower case
-            std::transform(ext.begin(), ext.end(), ext.begin(), [](char c) { return c <= 'Z' && c >= 'A' ? c - ('Z' - 'z') : c; });
-
-            FileType ft = FileType::UNKNOWN;
-            Debug::log(WARN, "Extension: {}", ext);
-            if (ext == ".png")
-                ft = FileType::PNG;
-            else if (ext == ".jpg" || ext == ".jpeg")
-                ft = FileType::JPEG;
-            else if (ext == ".webp")
-                ft = FileType::WEBP;
-            else {
-                // magic is slow, so only use it when no recognized extension is found
-                auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS);
-                magic_load(handle, nullptr);
-
-                const auto type_str   = std::string(magic_file(handle, ABSOLUTEPATH.c_str()));
-                const auto first_word = type_str.substr(0, type_str.find(" "));
-                magic_close(handle);
-
-                if (first_word == "PNG")
-                    ft = FileType::PNG;
-                else if (first_word == "JPEG")
-                    ft = FileType::JPEG;
-                else if (first_word == "RIFF" && type_str.find("Web/P image") != std::string::npos)
-                    ft = FileType::WEBP;
-            }
+            std::string id = (c.type == "background" ? std::string{"background:"} : std::string{"image:"}) + path;
 
-            // preload bg img
-            cairo_surface_t* CAIROISURFACE = nullptr;
-            switch (ft) {
-                case FileType::PNG: CAIROISURFACE = cairo_image_surface_create_from_png(ABSOLUTEPATH.c_str()); break;
-                case FileType::JPEG: CAIROISURFACE = JPEG::createSurfaceFromJPEG(ABSOLUTEPATH); break;
-                case FileType::WEBP: CAIROISURFACE = WEBP::createSurfaceFromWEBP(ABSOLUTEPATH); break;
-                default: Debug::log(ERR, "unrecognized image format of {}", path.c_str()); continue;
-            }
-
-            if (CAIROISURFACE == nullptr)
-                continue;
-
-            const auto CAIRO = cairo_create(CAIROISURFACE);
-            cairo_scale(CAIRO, 1, 1);
-
-            {
-                std::lock_guard lg{preloadTargetsMutex};
-                const auto      TARGET = &preloadTargets.emplace_back(CAsyncResourceGatherer::SPreloadTarget{});
+            // render the image directly, since we are in a seperate thread
+            CAsyncResourceGatherer::SPreloadRequest rq;
+            rq.type  = CAsyncResourceGatherer::TARGET_IMAGE;
+            rq.asset = path;
+            rq.id    = id;
 
-                TARGET->size = {cairo_image_surface_get_width(CAIROISURFACE), cairo_image_surface_get_height(CAIROISURFACE)};
-                TARGET->type = TARGET_IMAGE;
-                TARGET->id   = id;
-
-                const auto DATA      = cairo_image_surface_get_data(CAIROISURFACE);
-                TARGET->cairo        = CAIRO;
-                TARGET->cairosurface = CAIROISURFACE;
-                TARGET->data         = DATA;
-            }
+            renderImage(rq);
         }
     }
 
@@ -243,8 +236,13 @@ void CAsyncResourceGatherer::renderImage(const SPreloadRequest& rq) {
     target.type = TARGET_IMAGE;
     target.id   = rq.id;
 
-    const auto ABSOLUTEPATH  = absolutePath(rq.asset, "");
-    const auto CAIROISURFACE = cairo_image_surface_create_from_png(ABSOLUTEPATH.c_str());
+    std::filesystem::path ABSOLUTEPATH(absolutePath(rq.asset, ""));
+    const auto            CAIROISURFACE = getCairoSurfaceFromImageFile(ABSOLUTEPATH);
+
+    if (!CAIROISURFACE) {
+        Debug::log(ERR, "No cairo surface!");
+        return;
+    }
 
     const auto CAIRO = cairo_create(CAIROISURFACE);
     cairo_scale(CAIRO, 1, 1);

commit 114aa094ed24b973018e0462a1855dccaf636eeb
Author: Vaxry <vaxry@vaxry.net>
Date:   Wed Jul 24 13:58:59 2024 +0200

    core: add --version

diff --git a/CMakeLists.txt b/CMakeLists.txt
index cfab691..402a47d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,6 +32,7 @@ add_compile_options(-Wall -Wextra -Wno-unused-parameter -Wno-unused-value
 
 # position independent build: __FILE__
 add_compile_options(-fmacro-prefix-map=${CMAKE_SOURCE_DIR}/=)
+add_compile_definitions(HYPRLOCK_VERSION="${VERSION}")
 
 # dependencies
 message(STATUS "Checking deps...")
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 2dc881c..fa30c31 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -829,8 +829,7 @@ void CHyprlock::startKeyRepeat(xkb_keysym_t sym) {
     if (m_iKeebRepeatDelay <= 0)
         return;
 
-    m_pKeyRepeatTimer = addTimer(
-        std::chrono::milliseconds(m_iKeebRepeatDelay), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
+    m_pKeyRepeatTimer = addTimer(std::chrono::milliseconds(m_iKeebRepeatDelay), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
 }
 
 void CHyprlock::repeatKey(xkb_keysym_t sym) {
@@ -841,8 +840,7 @@ void CHyprlock::repeatKey(xkb_keysym_t sym) {
 
     // This condition is for backspace and delete keys, but should also be ok for other keysyms since our buffer won't be empty anyways
     if (bool CONTINUE = m_sPasswordState.passBuffer.length() > 0; CONTINUE)
-        m_pKeyRepeatTimer = addTimer(
-            std::chrono::milliseconds(m_iKeebRepeatRate), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
+        m_pKeyRepeatTimer = addTimer(std::chrono::milliseconds(m_iKeebRepeatRate), [sym](std::shared_ptr<CTimer> self, void* data) { g_pHyprlock->repeatKey(sym); }, nullptr);
 
     renderAllOutputs();
 }
@@ -1051,8 +1049,7 @@ std::vector<std::shared_ptr<CTimer>> CHyprlock::getTimers() {
 }
 
 void CHyprlock::enqueueForceUpdateTimers() {
-    addTimer(
-        std::chrono::milliseconds(1), [](std::shared_ptr<CTimer> self, void* data) { forceUpdateTimers(); }, nullptr, false);
+    addTimer(std::chrono::milliseconds(1), [](std::shared_ptr<CTimer> self, void* data) { forceUpdateTimers(); }, nullptr, false);
 }
 
 void CHyprlock::spawnAsync(const std::string& args) {
diff --git a/src/helpers/Log.hpp b/src/helpers/Log.hpp
index d2bf211..863512e 100644
--- a/src/helpers/Log.hpp
+++ b/src/helpers/Log.hpp
@@ -19,7 +19,7 @@ enum eLogLevel {
                    std::format(reason, ##__VA_ARGS__), __LINE__,                                                                                                                   \
                    ([]() constexpr -> std::string { return std::string(__FILE__).substr(std::string(__FILE__).find_last_of('/') + 1); })().c_str());                               \
         printf("Assertion failed! See the log in /tmp/hypr/hyprland.log for more info.");                                                                                          \
-        std::abort();                                                                                                         \
+        std::abort();                                                                                                                                                              \
     }
 
 #define ASSERT(expr) RASSERT(expr, "?")
diff --git a/src/helpers/MiscFunctions.hpp b/src/helpers/MiscFunctions.hpp
index bbac1a0..afab9be 100644
--- a/src/helpers/MiscFunctions.hpp
+++ b/src/helpers/MiscFunctions.hpp
@@ -2,5 +2,4 @@
 
 #include <string>
 
-
 std::string absolutePath(const std::string&, const std::string&);
diff --git a/src/main.cpp b/src/main.cpp
index f97945e..a5270ad 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -41,6 +41,11 @@ int main(int argc, char** argv, char** envp) {
         if (arg == "--verbose" || arg == "-v")
             Debug::verbose = true;
 
+        if (arg == "--version" || arg == "-V") {
+            std::cout << "Hyprlock version " << HYPRLOCK_VERSION << "\n";
+            return 0;
+        }
+
         else if (arg == "--quiet" || arg == "-q")
             Debug::quiet = true;
 

commit 12f5e258a0eafcde563b86593ca98b17019ae8d2
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Jul 24 21:18:11 2024 +0000

    widgets: move asset updates out of the draw function (#442)
    
    * label: move asset updates out of the draw function
    
    This allows us to check if the label has actually updated after the
    callback from the asyncResourceGatherer. If it isn't we can requeue the
    renderUpdate() function.
    
    * image: move asset updates out of the draw function

diff --git a/src/renderer/widgets/Image.cpp b/src/renderer/widgets/Image.cpp
index f5d1412..2e7a1b3 100644
--- a/src/renderer/widgets/Image.cpp
+++ b/src/renderer/widgets/Image.cpp
@@ -20,7 +20,11 @@ static void onTimer(std::shared_ptr<CTimer> self, void* data) {
 
 static void onAssetCallback(void* data) {
     const auto PIMAGE = (CImage*)data;
-    PIMAGE->renderSuper();
+    PIMAGE->renderUpdate();
+}
+
+static void onAssetCallbackTimer(std::shared_ptr<CTimer> self, void* data) {
+    onAssetCallback(data);
 }
 
 void CImage::onTimerUpdate() {
@@ -100,23 +104,6 @@ CImage::CImage(const Vector2D& viewport_, COutput* output_, const std::string& r
 
 bool CImage::draw(const SRenderData& data) {
 
-    if (!pendingResourceID.empty()) {
-        auto newAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(pendingResourceID);
-        if (newAsset) {
-            if (newAsset->texture.m_iType == TEXTURE_INVALID) {
-                g_pRenderer->asyncResourceGatherer->unloadAsset(newAsset);
-            } else if (resourceID != pendingResourceID) {
-                g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
-                imageFB.release();
-
-                asset       = newAsset;
-                resourceID  = pendingResourceID;
-                firstRender = true;
-            }
-            pendingResourceID = "";
-        }
-    }
-
     if (resourceID.empty())
         return false;
 
@@ -190,14 +177,25 @@ bool CImage::draw(const SRenderData& data) {
     return data.opacity < 1.0;
 }
 
-static void onAssetCallbackTimer(std::shared_ptr<CTimer> self, void* data) {
-    const auto PIMAGE = (CImage*)data;
-    PIMAGE->renderSuper();
-}
-
-void CImage::renderSuper() {
-    g_pHyprlock->renderOutput(output->stringPort);
+void CImage::renderUpdate() {
+    auto newAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(pendingResourceID);
+    if (newAsset) {
+        if (newAsset->texture.m_iType == TEXTURE_INVALID) {
+            g_pRenderer->asyncResourceGatherer->unloadAsset(newAsset);
+        } else if (resourceID != pendingResourceID) {
+            g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
+            imageFB.release();
+
+            asset       = newAsset;
+            resourceID  = pendingResourceID;
+            firstRender = true;
+        }
+        pendingResourceID = "";
+    } else if (!pendingResourceID.empty()) {
+        Debug::log(WARN, "Asset {} not available after the asyncResourceGatherer's callback!", pendingResourceID);
 
-    if (!pendingResourceID.empty()) /* did not consume the pending resource */
         g_pHyprlock->addTimer(std::chrono::milliseconds(100), onAssetCallbackTimer, this);
+    }
+
+    g_pHyprlock->renderOutput(output->stringPort);
 }
diff --git a/src/renderer/widgets/Image.hpp b/src/renderer/widgets/Image.hpp
index 8a9906e..81fd374 100644
--- a/src/renderer/widgets/Image.hpp
+++ b/src/renderer/widgets/Image.hpp
@@ -21,7 +21,7 @@ class CImage : public IWidget {
 
     virtual bool draw(const SRenderData& data);
 
-    void         renderSuper();
+    void         renderUpdate();
     void         onTimerUpdate();
     void         plantTimer();
 
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index adc09ed..9559bcb 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -27,7 +27,11 @@ static void onTimer(std::shared_ptr<CTimer> self, void* data) {
 
 static void onAssetCallback(void* data) {
     const auto PLABEL = (CLabel*)data;
-    PLABEL->renderSuper();
+    PLABEL->renderUpdate();
+}
+
+static void onAssetCallbackTimer(std::shared_ptr<CTimer> self, void* data) {
+    onAssetCallback(data);
 }
 
 std::string CLabel::getUniqueResourceId() {
@@ -122,19 +126,6 @@ bool CLabel::draw(const SRenderData& data) {
         shadow.markShadowDirty();
     }
 
-    if (!pendingResourceID.empty()) {
-        // new asset is pending
-        auto newAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(pendingResourceID);
-        if (newAsset) {
-            // new asset is ready :D
-            g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
-            asset             = newAsset;
-            resourceID        = pendingResourceID;
-            pendingResourceID = "";
-            shadow.markShadowDirty();
-        }
-    }
-
     shadow.draw(data);
 
     // calc pos
@@ -147,6 +138,21 @@ bool CLabel::draw(const SRenderData& data) {
     return false;
 }
 
-void CLabel::renderSuper() {
+void CLabel::renderUpdate() {
+    auto newAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(pendingResourceID);
+    if (newAsset) {
+        // new asset is ready :D
+        g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
+        asset             = newAsset;
+        resourceID        = pendingResourceID;
+        pendingResourceID = "";
+        shadow.markShadowDirty();
+    } else {
+        Debug::log(WARN, "Asset {} not available after the asyncResourceGatherer's callback!", pendingResourceID);
+
+        g_pHyprlock->addTimer(std::chrono::milliseconds(100), onAssetCallbackTimer, this);
+        return;
+    }
+
     g_pHyprlock->renderOutput(outputStringPort);
 }
diff --git a/src/renderer/widgets/Label.hpp b/src/renderer/widgets/Label.hpp
index 26b938d..d9bad77 100644
--- a/src/renderer/widgets/Label.hpp
+++ b/src/renderer/widgets/Label.hpp
@@ -19,7 +19,7 @@ class CLabel : public IWidget {
 
     virtual bool draw(const SRenderData& data);
 
-    void         renderSuper();
+    void         renderUpdate();
     void         onTimerUpdate();
     void         plantTimer();
 

commit 8ba7ea69149bd5e6bb7fd8001ccd1f1c0fdecbad
Author: davc0n <dconti.dev@gmail.com>
Date:   Sun Jul 28 20:10:36 2024 +0200

    core: minor refactor of command line options parsing (#441)

diff --git a/src/main.cpp b/src/main.cpp
index a5270ad..fda4f2e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -11,9 +11,10 @@ void help() {
                  "  -v, --verbose            - Enable verbose logging\n"
                  "  -q, --quiet              - Disable logging\n"
                  "  -c FILE, --config FILE   - Specify config file to use\n"
-                 "  --display (display)      - Specify the Wayland display to connect to\n"
+                 "  --display NAME           - Specify the Wayland display to connect to\n"
                  "  --immediate              - Lock immediately, ignoring any configured grace period\n"
                  "  --immediate-render       - Do not wait for resources before drawing the background\n"
+                 "  -V, --version            - Show version information\n"
                  "  -h, --help               - Show this help message\n";
 }
 
@@ -31,21 +32,25 @@ int main(int argc, char** argv, char** envp) {
     std::string              wlDisplay;
     bool                     immediate       = false;
     bool                     immediateRender = false;
-    bool                     showHelp        = false;
 
     std::vector<std::string> args(argv, argv + argc);
 
     for (std::size_t i = 1; i < args.size(); ++i) {
         const std::string arg = argv[i];
 
-        if (arg == "--verbose" || arg == "-v")
-            Debug::verbose = true;
+        if (arg == "--help" || arg == "-h") {
+            help();
+            return 0;
+        }
 
         if (arg == "--version" || arg == "-V") {
             std::cout << "Hyprlock version " << HYPRLOCK_VERSION << "\n";
             return 0;
         }
 
+        if (arg == "--verbose" || arg == "-v")
+            Debug::verbose = true;
+
         else if (arg == "--quiet" || arg == "-q")
             Debug::quiet = true;
 
@@ -67,22 +72,13 @@ int main(int argc, char** argv, char** envp) {
         else if (arg == "--immediate-render")
             immediateRender = true;
 
-        else if (arg == "--help" || arg == "-h") {
-            showHelp = true;
-            break;
-
-        } else {
+        else {
             std::cerr << "Unknown option: " << arg << "\n";
             help();
             return 1;
         }
     }
 
-    if (showHelp) {
-        help();
-        return 0;
-    }
-
     try {
         g_pConfigManager = std::make_unique<CConfigManager>(configPath);
         g_pConfigManager->init();

commit a139f1fbca1ce512decdc09d946cade5377e3e72
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Tue Jul 30 18:52:50 2024 +0200

    auth: use pam_faillock log as $FAIL (#447)
    
    Allows us to show "(x minutes left to unlock)" directly in the
    input-field fail text.

diff --git a/src/core/Auth.cpp b/src/core/Auth.cpp
index eb7dffa..ed4a3fe 100644
--- a/src/core/Auth.cpp
+++ b/src/core/Auth.cpp
@@ -45,7 +45,14 @@ int conv(int num_msg, const struct pam_message** msg, struct pam_response** resp
                 initialPrompt    = false;
             } break;
             case PAM_ERROR_MSG: Debug::log(ERR, "PAM: {}", msg[i]->msg); break;
-            case PAM_TEXT_INFO: Debug::log(LOG, "PAM: {}", msg[i]->msg); break;
+            case PAM_TEXT_INFO:
+                Debug::log(LOG, "PAM: {}", msg[i]->msg);
+                // Targets this log from pam_faillock: https://github.com/linux-pam/linux-pam/blob/fa3295e079dbbc241906f29bde5fb71bc4172771/modules/pam_faillock/pam_faillock.c#L417
+                if (const auto MSG = std::string(msg[i]->msg); MSG.contains("left to unlock")) {
+                    CONVERSATIONSTATE->failText        = std::move(MSG);
+                    CONVERSATIONSTATE->failTextFromPam = true;
+                }
+                break;
         }
     }
 
@@ -110,7 +117,8 @@ bool CAuth::auth() {
     m_sConversationState.waitingForPamAuth = false;
 
     if (ret != PAM_SUCCESS) {
-        m_sConversationState.failText = ret == PAM_AUTH_ERR ? "Authentication failed" : "pam_authenticate failed";
+        if (!m_sConversationState.failTextFromPam)
+            m_sConversationState.failText = ret == PAM_AUTH_ERR ? "Authentication failed" : "pam_authenticate failed";
         Debug::log(ERR, "auth: {} for {}", m_sConversationState.failText, m_sPamModule);
         return false;
     }
@@ -173,4 +181,5 @@ void CAuth::resetConversation() {
     m_sConversationState.input             = "";
     m_sConversationState.waitingForPamAuth = false;
     m_sConversationState.inputRequested    = false;
+    m_sConversationState.failTextFromPam   = false;
 }
diff --git a/src/core/Auth.hpp b/src/core/Auth.hpp
index d480c71..a6f8289 100644
--- a/src/core/Auth.hpp
+++ b/src/core/Auth.hpp
@@ -18,6 +18,7 @@ class CAuth {
 
         bool                    waitingForPamAuth = false;
         bool                    inputRequested    = false;
+        bool                    failTextFromPam   = false;
     };
 
     CAuth();

commit c7fe60eefc0ebb7db9a5b43f55aedc7d911fd617
Author: Aaron Blasko <blaskoazzolaaaron@gmail.com>
Date:   Sat Aug 3 17:34:54 2024 +0200

    renderer: add --no-fade-in (#453)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index fa30c31..b14bede 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -18,7 +18,7 @@
 #include <fstream>
 #include <algorithm>
 
-CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender) {
+CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender, const bool noFadeIn) {
     m_sWaylandState.display = wl_display_connect(wlDisplay.empty() ? nullptr : wlDisplay.c_str());
     if (!m_sWaylandState.display) {
         Debug::log(CRIT, "Couldn't connect to a wayland compositor");
@@ -40,6 +40,9 @@ CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate, const b
 
     const auto PIMMEDIATERENDER = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:immediate_render");
     m_bImmediateRender          = immediateRender || **PIMMEDIATERENDER;
+
+    const auto* const PNOFADEIN   = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_in");
+    m_bNoFadeIn = noFadeIn || **PNOFADEIN;
 }
 
 CHyprlock::~CHyprlock() {
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index c66d61f..7fa7037 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -25,7 +25,7 @@ struct SDMABUFModifier {
 
 class CHyprlock {
   public:
-    CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender);
+    CHyprlock(const std::string& wlDisplay, const bool immediate, const bool immediateRender, const bool noFadeIn);
     ~CHyprlock();
 
     void                            run();
@@ -102,6 +102,9 @@ class CHyprlock {
     bool                            m_bFadeStarted = false;
 
     bool                            m_bImmediateRender = false;
+
+    bool                            m_bNoFadeIn = false;
+
     //
     std::chrono::system_clock::time_point m_tGraceEnds;
     std::chrono::system_clock::time_point m_tFadeEnds;
diff --git a/src/main.cpp b/src/main.cpp
index fda4f2e..e1d4d9b 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -14,6 +14,7 @@ void help() {
                  "  --display NAME           - Specify the Wayland display to connect to\n"
                  "  --immediate              - Lock immediately, ignoring any configured grace period\n"
                  "  --immediate-render       - Do not wait for resources before drawing the background\n"
+                 "  --no-fade-in              - Disable the fade-in animation when the lock screen appears\n"
                  "  -V, --version            - Show version information\n"
                  "  -h, --help               - Show this help message\n";
 }
@@ -32,6 +33,7 @@ int main(int argc, char** argv, char** envp) {
     std::string              wlDisplay;
     bool                     immediate       = false;
     bool                     immediateRender = false;
+    bool                     noFadeIn        = false;
 
     std::vector<std::string> args(argv, argv + argc);
 
@@ -72,6 +74,9 @@ int main(int argc, char** argv, char** envp) {
         else if (arg == "--immediate-render")
             immediateRender = true;
 
+        else if (arg == "--no-fade-in")
+            noFadeIn = true;
+
         else {
             std::cerr << "Unknown option: " << arg << "\n";
             help();
@@ -91,7 +96,7 @@ int main(int argc, char** argv, char** envp) {
     }
 
     try {
-        g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate, immediateRender);
+        g_pHyprlock = std::make_unique<CHyprlock>(wlDisplay, immediate, immediateRender, noFadeIn);
         g_pHyprlock->run();
     } catch (const std::exception& ex) {
         Debug::log(CRIT, "Hyprlock threw: {}", ex.what());
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 776fc76..1ac260f 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -162,7 +162,6 @@ static bool firstFullFrame = false;
 //
 CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf) {
     static auto* const PDISABLEBAR = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:disable_loading_bar");
-    static auto* const PNOFADEIN   = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_in");
     static auto* const PNOFADEOUT  = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
 
     matrixProjection(projection.data(), surf.size.x, surf.size.y, WL_OUTPUT_TRANSFORM_NORMAL);
@@ -200,7 +199,7 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
 
         bga = std::clamp(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - firstFullFrameTime).count() / 500000.0, 0.0, 1.0);
 
-        if (**PNOFADEIN)
+        if (g_pHyprlock->m_bNoFadeIn)
             bga = 1.0;
 
         if (g_pHyprlock->m_bFadeStarted && !**PNOFADEOUT) {

commit c4ba99eb16b01811ce41e2c5c0dafc4ac96993ef
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Mon Aug 5 20:22:01 2024 +0200

    core: add fractional_scaling option (#456)
    
    * config: add fractional_scaling option
    
    0 -> off
    1 -> on
    2 -> auto
    
    * core: default auto option for fractional_scaling
    
    * locksurface: fallback to integer scaling

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 30d7b9f..ada7769 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -58,6 +58,7 @@ void CConfigManager::init() {
     m_config.addConfigValue("general:ignore_empty_input", Hyprlang::INT{0});
     m_config.addConfigValue("general:immediate_render", Hyprlang::INT{0});
     m_config.addConfigValue("general:pam_module", Hyprlang::STRING{"hyprlock"});
+    m_config.addConfigValue("general:fractional_scaling", Hyprlang::INT{2});
 
     m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
     m_config.addSpecialConfigValue("background", "monitor", Hyprlang::STRING{""});
diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 006a2eb..706f844 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -3,6 +3,7 @@
 #include "../helpers/Log.hpp"
 #include "Egl.hpp"
 #include "../renderer/Renderer.hpp"
+#include "src/config/ConfigManager.hpp"
 
 static void handleConfigure(void* data, ext_session_lock_surface_v1* surf, uint32_t serial, uint32_t width, uint32_t height) {
     const auto PSURF = (CSessionLockSurface*)data;
@@ -53,9 +54,13 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
         exit(1);
     }
 
+    const auto PFRACTIONALSCALING = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:fractional_scaling");
+    const auto ENABLE_FSV1        = **PFRACTIONALSCALING == 1 ||
+        /* auto */ (**PFRACTIONALSCALING == 2 && (g_pHyprlock->m_sCurrentDesktop == "Hyprland" || g_pHyprlock->m_sCurrentDesktop == "niri"));
     const auto PFRACTIONALMGR = g_pHyprlock->getFractionalMgr();
     const auto PVIEWPORTER    = g_pHyprlock->getViewporter();
-    if (PFRACTIONALMGR && PVIEWPORTER) {
+
+    if (ENABLE_FSV1 && PFRACTIONALMGR && PVIEWPORTER) {
         fractional = wp_fractional_scale_manager_v1_get_fractional_scale(PFRACTIONALMGR, surface);
         if (fractional) {
             wp_fractional_scale_v1_add_listener(fractional, &fsListener, this);
@@ -63,7 +68,7 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
         }
     }
 
-    if (!PFRACTIONALMGR || !fractional)
+    if (!PFRACTIONALMGR)
         Debug::log(LOG, "No fractional-scale support! Oops, won't be able to scale!");
     if (!PVIEWPORTER)
         Debug::log(LOG, "No viewporter support! Oops, won't be able to scale!");
@@ -81,7 +86,7 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
 void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     Debug::log(LOG, "configure with serial {}", serial_);
 
-    const bool sameSerial = serial == serial_;
+    const bool SAMESERIAL = serial == serial_;
 
     serial      = serial_;
     logicalSize = size_;
@@ -89,16 +94,17 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     if (fractional) {
         size = (size_ * fractionalScale).floor();
         wp_viewport_set_destination(viewport, logicalSize.x, logicalSize.y);
+        wl_surface_set_buffer_scale(surface, 1);
     } else {
-        size = size_;
+        size = size_ * output->scale;
+        wl_surface_set_buffer_scale(surface, output->scale);
     }
 
-    Debug::log(LOG, "Configuring surface for logical {} and pixel {}", logicalSize, size);
-
-    if (!sameSerial)
+    if (!SAMESERIAL)
         ext_session_lock_surface_v1_ack_configure(lockSurface, serial);
 
-    wl_surface_set_buffer_scale(surface, 1);
+    Debug::log(LOG, "Configuring surface for logical {} and pixel {}", logicalSize, size);
+
     wl_surface_damage_buffer(surface, 0, 0, 0xFFFF, 0xFFFF);
 
     if (!eglWindow) {
diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index b14bede..5fe99ca 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -41,8 +41,12 @@ CHyprlock::CHyprlock(const std::string& wlDisplay, const bool immediate, const b
     const auto PIMMEDIATERENDER = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:immediate_render");
     m_bImmediateRender          = immediateRender || **PIMMEDIATERENDER;
 
-    const auto* const PNOFADEIN   = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_in");
-    m_bNoFadeIn = noFadeIn || **PNOFADEIN;
+    const auto* const PNOFADEIN = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_in");
+    m_bNoFadeIn                 = noFadeIn || **PNOFADEIN;
+
+    const auto CURRENTDESKTOP = getenv("XDG_CURRENT_DESKTOP");
+    const auto SZCURRENTD     = std::string{CURRENTDESKTOP ? CURRENTDESKTOP : ""};
+    m_sCurrentDesktop         = SZCURRENTD;
 }
 
 CHyprlock::~CHyprlock() {
@@ -380,15 +384,13 @@ void CHyprlock::run() {
 
     g_pRenderer = std::make_unique<CRenderer>();
 
-    const auto         CURRENTDESKTOP = getenv("XDG_CURRENT_DESKTOP");
-    const auto         SZCURRENTD     = std::string{CURRENTDESKTOP ? CURRENTDESKTOP : ""};
-    static auto* const PNOFADEOUT     = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
-    const bool         NOFADEOUT      = **PNOFADEOUT;
+    static auto* const PNOFADEOUT = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
+    const bool         NOFADEOUT  = **PNOFADEOUT;
 
-    Debug::log(LOG, "Running on {}", SZCURRENTD);
+    Debug::log(LOG, "Running on {}", m_sCurrentDesktop);
 
     // Hyprland violates the protocol a bit to allow for this.
-    if (SZCURRENTD != "Hyprland") {
+    if (m_sCurrentDesktop != "Hyprland") {
         while (!g_pRenderer->asyncResourceGatherer->gathered) {
             wl_display_flush(m_sWaylandState.display);
             if (wl_display_prepare_read(m_sWaylandState.display) == 0) {
@@ -573,11 +575,9 @@ void CHyprlock::run() {
 }
 
 void CHyprlock::unlock() {
-    static auto* const PNOFADEOUT     = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
-    const auto         CURRENTDESKTOP = getenv("XDG_CURRENT_DESKTOP");
-    const auto         SZCURRENTD     = std::string{CURRENTDESKTOP ? CURRENTDESKTOP : ""};
+    static auto* const PNOFADEOUT = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:no_fade_out");
 
-    if (**PNOFADEOUT || SZCURRENTD != "Hyprland") {
+    if (**PNOFADEOUT || m_sCurrentDesktop != "Hyprland") {
         releaseSessionLock();
         return;
     }
diff --git a/src/core/hyprlock.hpp b/src/core/hyprlock.hpp
index 7fa7037..cbc6436 100644
--- a/src/core/hyprlock.hpp
+++ b/src/core/hyprlock.hpp
@@ -105,6 +105,8 @@ class CHyprlock {
 
     bool                            m_bNoFadeIn = false;
 
+    std::string                     m_sCurrentDesktop = "";
+
     //
     std::chrono::system_clock::time_point m_tGraceEnds;
     std::chrono::system_clock::time_point m_tFadeEnds;

commit 817c057a35af2544d7dbb80687777678cc2b5f12
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Sun Aug 18 07:19:56 2024 +0000

    lockSurface: fix dynamic output mode and scale updates (#462)
    
    * lockSurface: reload widgets on output change
    
    * lockSurface: only configure when scale actually changed
    
    * lockSurface: enable fsv1 per default for all compositors

diff --git a/src/core/LockSurface.cpp b/src/core/LockSurface.cpp
index 706f844..755b253 100644
--- a/src/core/LockSurface.cpp
+++ b/src/core/LockSurface.cpp
@@ -16,10 +16,12 @@ static const ext_session_lock_surface_v1_listener lockListener = {
 
 static void handlePreferredScale(void* data, wp_fractional_scale_v1* wp_fractional_scale_v1, uint32_t scale) {
     const auto PSURF       = (CSessionLockSurface*)data;
+    const bool SAMESCALE   = PSURF->fractionalScale == scale / 120.0;
     PSURF->fractionalScale = scale / 120.0;
+
     Debug::log(LOG, "Got fractional scale: {}", PSURF->fractionalScale);
 
-    if (PSURF->readyForFrame)
+    if (!SAMESCALE && PSURF->readyForFrame)
         PSURF->onScaleUpdate();
 }
 
@@ -55,10 +57,9 @@ CSessionLockSurface::CSessionLockSurface(COutput* output) : output(output) {
     }
 
     const auto PFRACTIONALSCALING = (Hyprlang::INT* const*)g_pConfigManager->getValuePtr("general:fractional_scaling");
-    const auto ENABLE_FSV1        = **PFRACTIONALSCALING == 1 ||
-        /* auto */ (**PFRACTIONALSCALING == 2 && (g_pHyprlock->m_sCurrentDesktop == "Hyprland" || g_pHyprlock->m_sCurrentDesktop == "niri"));
-    const auto PFRACTIONALMGR = g_pHyprlock->getFractionalMgr();
-    const auto PVIEWPORTER    = g_pHyprlock->getViewporter();
+    const auto ENABLE_FSV1        = **PFRACTIONALSCALING == 1 || /* auto enable */ (**PFRACTIONALSCALING == 2);
+    const auto PFRACTIONALMGR     = g_pHyprlock->getFractionalMgr();
+    const auto PVIEWPORTER        = g_pHyprlock->getViewporter();
 
     if (ENABLE_FSV1 && PFRACTIONALMGR && PVIEWPORTER) {
         fractional = wp_fractional_scale_manager_v1_get_fractional_scale(PFRACTIONALMGR, surface);
@@ -87,9 +88,12 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
     Debug::log(LOG, "configure with serial {}", serial_);
 
     const bool SAMESERIAL = serial == serial_;
+    const bool SAMESIZE   = logicalSize == size_;
+    const bool SAMESCALE  = appliedScale == fractionalScale;
 
-    serial      = serial_;
-    logicalSize = size_;
+    serial       = serial_;
+    logicalSize  = size_;
+    appliedScale = fractionalScale;
 
     if (fractional) {
         size = (size_ * fractionalScale).floor();
@@ -127,6 +131,11 @@ void CSessionLockSurface::configure(const Vector2D& size_, uint32_t serial_) {
         }
     }
 
+    if (readyForFrame && !(SAMESIZE && SAMESCALE)) {
+        g_pRenderer->removeWidgetsFor(this);
+        Debug::log(LOG, "Reloading widgets");
+    }
+
     readyForFrame = true;
 
     render();
diff --git a/src/core/LockSurface.hpp b/src/core/LockSurface.hpp
index 046b971..16a8294 100644
--- a/src/core/LockSurface.hpp
+++ b/src/core/LockSurface.hpp
@@ -34,6 +34,7 @@ class CSessionLockSurface {
     wl_egl_window*               eglWindow   = nullptr;
     Vector2D                     size;
     Vector2D                     logicalSize;
+    float                        appliedScale;
     EGLSurface                   eglSurface = nullptr;
     wp_fractional_scale_v1*      fractional = nullptr;
     wp_viewport*                 viewport   = nullptr;

commit cb0b0ffb285ff1bcf24d4082c0c4047b39d1acf6
Author: Yang, Ying-chao <yang.yingchao@qq.com>
Date:   Wed Aug 21 18:25:14 2024 +0800

    core: fix crash caused by exiting without joining running thread (#464)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 5fe99ca..0e1b9de 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -405,8 +405,14 @@ void CHyprlock::run() {
 
     acquireSessionLock();
 
-    if (m_bTerminate) // Recieved finished
+    // Recieved finished
+    if (m_bTerminate) {
+        m_sLoopState.timerEvent = true;
+        m_sLoopState.timerCV.notify_all();
+        g_pRenderer->asyncResourceGatherer->notify();
+        g_pRenderer->asyncResourceGatherer->await();
         exit(1);
+    }
 
     g_pAuth = std::make_unique<CAuth>();
     g_pAuth->start();

commit 3f186c5a510212f225362bb6ffa04c1a5c2244ed
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Thu Aug 29 07:53:00 2024 +0000

    input-field: refactor updateColors and other improvements (#469)
    
    * input-field: refactor updateColors
    
    * input-field: fix input-field:invert_numlock
    
    * input-field: use updatePlaceholder to request the initial placeholder asset
    
    * input-field: allow more gradual color animations
    
    * input-field: fix caps and num indicator colors, when borderless and swap_font_color is true

diff --git a/src/renderer/widgets/PasswordInputField.cpp b/src/renderer/widgets/PasswordInputField.cpp
index fab0cab..c38423f 100644
--- a/src/renderer/widgets/PasswordInputField.cpp
+++ b/src/renderer/widgets/PasswordInputField.cpp
@@ -1,7 +1,7 @@
 #include "PasswordInputField.hpp"
 #include "../Renderer.hpp"
 #include "../../core/hyprlock.hpp"
-#include "src/core/Auth.hpp"
+#include "../../core/Auth.hpp"
 #include <algorithm>
 
 static void replaceAll(std::string& str, const std::string& from, const std::string& to) {
@@ -29,17 +29,17 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
     configPlaceholderText    = std::any_cast<Hyprlang::STRING>(props.at("placeholder_text"));
     configFailText           = std::any_cast<Hyprlang::STRING>(props.at("fail_text"));
     configFailTimeoutMs      = std::any_cast<Hyprlang::INT>(props.at("fail_timeout"));
-    col.transitionMs         = std::any_cast<Hyprlang::INT>(props.at("fail_transition"));
-    col.outer                = std::any_cast<Hyprlang::INT>(props.at("outer_color"));
-    col.inner                = std::any_cast<Hyprlang::INT>(props.at("inner_color"));
-    col.font                 = std::any_cast<Hyprlang::INT>(props.at("font_color"));
-    col.fail                 = std::any_cast<Hyprlang::INT>(props.at("fail_color"));
-    col.check                = std::any_cast<Hyprlang::INT>(props.at("check_color"));
-    col.both                 = std::any_cast<Hyprlang::INT>(props.at("bothlock_color"));
-    col.caps                 = std::any_cast<Hyprlang::INT>(props.at("capslock_color"));
-    col.num                  = std::any_cast<Hyprlang::INT>(props.at("numlock_color"));
-    col.invertNum            = std::any_cast<Hyprlang::INT>(props.at("invert_numlock"));
-    col.swapFont             = std::any_cast<Hyprlang::INT>(props.at("swap_font_color"));
+    colorConfig.transitionMs = std::any_cast<Hyprlang::INT>(props.at("fail_transition"));
+    colorConfig.outer        = std::any_cast<Hyprlang::INT>(props.at("outer_color"));
+    colorConfig.inner        = std::any_cast<Hyprlang::INT>(props.at("inner_color"));
+    colorConfig.font         = std::any_cast<Hyprlang::INT>(props.at("font_color"));
+    colorConfig.fail         = std::any_cast<Hyprlang::INT>(props.at("fail_color"));
+    colorConfig.check        = std::any_cast<Hyprlang::INT>(props.at("check_color"));
+    colorConfig.both         = std::any_cast<Hyprlang::INT>(props.at("bothlock_color"));
+    colorConfig.caps         = std::any_cast<Hyprlang::INT>(props.at("capslock_color"));
+    colorConfig.num          = std::any_cast<Hyprlang::INT>(props.at("numlock_color"));
+    colorConfig.invertNum    = std::any_cast<Hyprlang::INT>(props.at("invert_numlock"));
+    colorConfig.swapFont     = std::any_cast<Hyprlang::INT>(props.at("swap_font_color"));
     viewport                 = viewport_;
 
     auto POS__ = std::any_cast<Hyprlang::VEC2>(props.at("position"));
@@ -50,34 +50,21 @@ CPasswordInputField::CPasswordInputField(const Vector2D& viewport_, const std::u
     halign = std::any_cast<Hyprlang::STRING>(props.at("halign"));
     valign = std::any_cast<Hyprlang::STRING>(props.at("valign"));
 
-    pos              = posFromHVAlign(viewport, size, pos, halign, valign);
-    dots.size        = std::clamp(dots.size, 0.2f, 0.8f);
-    dots.spacing     = std::clamp(dots.spacing, 0.f, 1.f);
-    col.transitionMs = std::clamp(col.transitionMs, 0, 1000);
+    pos                      = posFromHVAlign(viewport, size, pos, halign, valign);
+    dots.size                = std::clamp(dots.size, 0.2f, 0.8f);
+    dots.spacing             = std::clamp(dots.spacing, 0.f, 1.f);
+    colorConfig.transitionMs = std::clamp(colorConfig.transitionMs, 0, 1000);
 
-    col.both = col.both == -1 ? col.outer : col.both;
-    col.caps = col.caps == -1 ? col.outer : col.caps;
-    col.num  = col.num == -1 ? col.outer : col.num;
+    colorConfig.both = colorConfig.both == -1 ? colorConfig.outer : colorConfig.both;
+    colorConfig.caps = colorConfig.caps == -1 ? colorConfig.outer : colorConfig.caps;
+    colorConfig.num  = colorConfig.num == -1 ? colorConfig.outer : colorConfig.num;
 
-    g_pHyprlock->m_bNumLock = col.invertNum;
+    colorState.inner = colorConfig.inner;
+    colorState.outer = colorConfig.outer;
+    colorState.font  = colorConfig.font;
 
-    // Render placeholder if either placeholder_text or fail_text are non-empty
-    // as placeholder must be rendered to show fail_text
-    if (!configPlaceholderText.empty() || !configFailText.empty()) {
-        placeholder.currentText = configPlaceholderText;
-
-        replaceAll(placeholder.currentText, "$PROMPT", "");
-
-        placeholder.resourceID = "placeholder:" + placeholder.currentText + std::to_string((uintptr_t)this);
-        CAsyncResourceGatherer::SPreloadRequest request;
-        request.id                   = placeholder.resourceID;
-        request.asset                = placeholder.currentText;
-        request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
-        request.props["font_family"] = std::string{"Sans"};
-        request.props["color"]       = CColor{1.0 - col.font.r, 1.0 - col.font.g, 1.0 - col.font.b, 0.5};
-        request.props["font_size"]   = (int)size.y / 4;
-        g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
-    }
+    // request the inital placeholder asset
+    updatePlaceholder();
 }
 
 static void fadeOutCallback(std::shared_ptr<CTimer> self, void* data) {
@@ -180,11 +167,12 @@ bool CPasswordInputField::draw(const SRenderData& data) {
 
     passwordLength = g_pHyprlock->getPasswordBufferDisplayLen();
     checkWaiting   = g_pAuth->checkWaiting();
+    displayFail    = g_pAuth->m_bDisplayFailText;
 
     updateFade();
     updateDots();
-    updatePlaceholder();
     updateColors();
+    updatePlaceholder();
     updateHiddenInputState();
 
     static auto TIMER = std::chrono::system_clock::now();
@@ -215,11 +203,11 @@ bool CPasswordInputField::draw(const SRenderData& data) {
     shadowData.opacity *= fade.a;
     shadow.draw(shadowData);
 
-    CColor outerCol = col.outer;
+    CColor outerCol = colorState.outer;
     outerCol.a *= fade.a * data.opacity;
-    CColor innerCol = col.inner;
+    CColor innerCol = colorState.inner;
     innerCol.a *= fade.a * data.opacity;
-    CColor fontCol = col.font;
+    CColor fontCol = colorState.font;
     fontCol.a *= fade.a * data.opacity;
 
     if (outThick > 0) {
@@ -302,7 +290,7 @@ bool CPasswordInputField::draw(const SRenderData& data) {
             forceReload = true;
     }
 
-    return dots.currentAmount != passwordLength || fade.animated || col.animated || redrawShadow || data.opacity < 1.0 || forceReload;
+    return dots.currentAmount != passwordLength || fade.animated || colorState.animated || redrawShadow || data.opacity < 1.0 || forceReload;
 }
 
 static void failTimeoutCallback(std::shared_ptr<CTimer> self, void* data) {
@@ -312,7 +300,7 @@ static void failTimeoutCallback(std::shared_ptr<CTimer> self, void* data) {
 
 void CPasswordInputField::updatePlaceholder() {
     if (passwordLength != 0) {
-        if (placeholder.asset && /* keep prompt asset cause it is likely to be used again */ placeholder.isFailText) {
+        if (placeholder.asset && /* keep prompt asset cause it is likely to be used again */ displayFail) {
             std::erase(placeholder.registeredResourceIDs, placeholder.resourceID);
             g_pRenderer->asyncResourceGatherer->unloadAsset(placeholder.asset);
             placeholder.asset      = nullptr;
@@ -322,18 +310,18 @@ void CPasswordInputField::updatePlaceholder() {
         return;
     }
 
-    const auto AUTHFEEDBACK = g_pAuth->m_bDisplayFailText ? g_pAuth->getLastFailText().value_or("Ups, no fail text?") : g_pAuth->getLastPrompt().value_or("Ups, no prompt?");
+    const auto AUTHFEEDBACK   = g_pAuth->m_bDisplayFailText ? g_pAuth->getLastFailText().value_or("Ups, no fail text?") : g_pAuth->getLastPrompt().value_or("Ups, no prompt?");
+    const auto ALLOWCOLORSWAP = outThick == 0 && colorConfig.swapFont;
 
-    if (placeholder.lastAuthFeedback == AUTHFEEDBACK && g_pHyprlock->getPasswordFailedAttempts() == placeholder.failedAttempts)
+    if (!ALLOWCOLORSWAP && placeholder.lastAuthFeedback == AUTHFEEDBACK && g_pHyprlock->getPasswordFailedAttempts() == placeholder.failedAttempts)
         return;
 
     placeholder.failedAttempts   = g_pHyprlock->getPasswordFailedAttempts();
-    placeholder.isFailText       = g_pAuth->m_bDisplayFailText;
     placeholder.lastAuthFeedback = AUTHFEEDBACK;
 
     placeholder.asset = nullptr;
 
-    if (placeholder.isFailText) {
+    if (displayFail) {
         g_pHyprlock->addTimer(std::chrono::milliseconds(configFailTimeoutMs), failTimeoutCallback, nullptr);
         placeholder.currentText = configFailText;
         replaceAll(placeholder.currentText, "$FAIL", AUTHFEEDBACK);
@@ -343,7 +331,9 @@ void CPasswordInputField::updatePlaceholder() {
         replaceAll(placeholder.currentText, "$PROMPT", AUTHFEEDBACK);
     }
 
-    placeholder.resourceID = "placeholder:" + placeholder.currentText + std::to_string((uintptr_t)this);
+    placeholder.resourceID =
+        std::format("placeholder:{}{}{}{}{}{}", placeholder.currentText, (uintptr_t)this, colorState.font.r, colorState.font.g, colorState.font.b, colorState.font.a);
+
     if (std::find(placeholder.registeredResourceIDs.begin(), placeholder.registeredResourceIDs.end(), placeholder.resourceID) != placeholder.registeredResourceIDs.end())
         return;
 
@@ -355,7 +345,7 @@ void CPasswordInputField::updatePlaceholder() {
     request.asset                = placeholder.currentText;
     request.type                 = CAsyncResourceGatherer::eTargetType::TARGET_TEXT;
     request.props["font_family"] = std::string{"Sans"};
-    request.props["color"]       = (placeholder.isFailText) ? col.fail : col.font;
+    request.props["color"]       = colorState.font;
     request.props["font_size"]   = (int)size.y / 4;
     g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
 }
@@ -409,104 +399,60 @@ static void changeColor(const CColor& source, const CColor& target, CColor& subj
 }
 
 void CPasswordInputField::updateColors() {
-    static auto OUTER = col.outer, TARGET = OUTER, SOURCE = OUTER;
-    static auto INNER = col.inner, ITARGET = INNER, ISOURCE = INNER;
-    static auto FONT = col.font, FTARGET = FONT, FSOURCE = FONT;
-
-    const bool  BORDERLESS = outThick == 0;
-
-    if (col.animated) {
-        // some cases when events happen too quick (within transitionMs)
-        // TODO: find more?
-        const bool LOCKCHANGED = col.stateNum != (col.invertNum ? !g_pHyprlock->m_bNumLock : g_pHyprlock->m_bNumLock) || col.stateCaps != g_pHyprlock->m_bCapsLock;
-        const bool ANIMONCHECK = checkWaiting && (TARGET == (BORDERLESS ? INNER : OUTER) || TARGET == col.fail);
-
-        if (LOCKCHANGED || ANIMONCHECK) {
-            const bool EQUALCOLORS = ANIMONCHECK && OUTER == col.check;
-            // to avoid throttle when check_color set to the same as outer.
-            SOURCE  = BORDERLESS ? (EQUALCOLORS ? INNER : col.inner) : col.outer;
-            FSOURCE = EQUALCOLORS ? FONT : col.font;
-            ISOURCE = EQUALCOLORS ? INNER : col.inner;
-        }
-    } else {
-        SOURCE  = BORDERLESS ? col.inner : col.outer;
-        FSOURCE = col.font;
-        ISOURCE = col.inner;
+    const bool BORDERLESS = outThick == 0;
+    const bool NUMLOCK    = g_pHyprlock->m_bNumLock || (colorConfig.invertNum && !g_pHyprlock->m_bNumLock);
+    const auto MULTI      = colorConfig.transitionMs == 0 ?
+             1.0 :
+             std::clamp(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - colorState.lastFrame).count() / (double)colorConfig.transitionMs,
+                        0.0016, 0.5);
+
+    CColor     targetColor;
+
+    if (checkWaiting) {
+        targetColor = colorConfig.check;
+    } else if (displayFail) {
+        targetColor = colorConfig.fail;
     }
 
-    col.stateNum  = col.invertNum ? !g_pHyprlock->m_bNumLock : g_pHyprlock->m_bNumLock;
-    col.stateCaps = g_pHyprlock->m_bCapsLock;
-
-    if (!placeholder.isFailText || passwordLength > 0 || (passwordLength == 0 && checkWaiting)) {
-        if (g_pHyprlock->m_bFadeStarted) {
-            if (TARGET == col.check)
-                SOURCE = BORDERLESS ? col.inner : col.outer;
-            col.transitionMs = 100;
-            TARGET           = BORDERLESS ? INNER : OUTER;
-        } else if (checkWaiting) {
-            FTARGET               = col.swapFont ? INNER : FONT;
-            const float PASSALPHA = FTARGET.a * 0.5;
-            FTARGET.a             = PASSALPHA;
-
-            TARGET  = col.check;
-            ITARGET = col.swapFont ? FONT : INNER;
-        } else if (col.stateCaps && col.stateNum && col.both != OUTER) {
-            TARGET  = col.both;
-            FTARGET = col.swapFont && BORDERLESS ? INNER : FONT;
-        } else if (col.stateCaps && col.caps != OUTER) {
-            TARGET  = col.caps;
-            FTARGET = col.swapFont && BORDERLESS ? INNER : FONT;
-        } else if (col.stateNum && col.num != OUTER) {
-            TARGET  = col.num;
-            FTARGET = col.swapFont && BORDERLESS ? INNER : FONT;
-        } else {
-            // if quickly pressed after failure
-            if (col.animated && TARGET == col.fail)
-                SOURCE = BORDERLESS ? col.inner : col.outer;
+    if (g_pHyprlock->m_bCapsLock && NUMLOCK) {
+        targetColor = colorConfig.both;
+    } else if (g_pHyprlock->m_bCapsLock) {
+        targetColor = colorConfig.caps;
+    } else if (NUMLOCK) {
+        targetColor = colorConfig.num;
+    }
 
-            TARGET  = BORDERLESS ? INNER : OUTER;
-            FTARGET = FONT;
-            ITARGET = INNER;
-        }
-    } else {
-        FSOURCE               = col.swapFont ? INNER : FONT;
-        const float PASSALPHA = FSOURCE.a * 0.5;
-        FSOURCE.a             = PASSALPHA;
-        FTARGET               = FONT;
-
-        SOURCE  = col.check;
-        TARGET  = col.fail;
-        ISOURCE = FONT;
-        ITARGET = FONT;
-
-        if (fade.animated || fade.a < 1.0) {
-            TARGET = BORDERLESS ? INNER : OUTER;
-            SOURCE = col.fail;
+    CColor outerTarget = colorConfig.outer;
+    CColor innerTarget = colorConfig.inner;
+    CColor fontTarget  = (displayFail) ? colorConfig.fail : colorConfig.font;
+
+    if (checkWaiting || displayFail || g_pHyprlock->m_bCapsLock || NUMLOCK) {
+        if (BORDERLESS && colorConfig.swapFont) {
+            fontTarget = targetColor;
+        } else if (BORDERLESS && !colorConfig.swapFont) {
+            innerTarget = targetColor;
+            // When changing the inner color the font cannot be fail_color
+            fontTarget = colorConfig.font;
+        } else {
+            outerTarget = targetColor;
         }
     }
 
-    col.animated = false;
-
-    const bool SWAPDONE = !BORDERLESS && col.swapFont ? col.inner == ITARGET : true;
+    if (targetColor != colorState.currentTarget) {
+        colorState.outerSource = colorState.outer;
+        colorState.innerSource = colorState.inner;
 
-    if ((BORDERLESS ? col.inner : col.outer) == TARGET && col.font == FTARGET && SWAPDONE) {
-        col.shouldStart = true;
-        return;
+        colorState.currentTarget = targetColor;
     }
 
-    if (col.shouldStart) {
-        col.lastFrame   = std::chrono::system_clock::now();
-        col.shouldStart = false;
-    }
+    colorState.animated = false;
 
-    const auto MULTI = col.transitionMs == 0 ?
-        1.0 :
-        std::clamp(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - col.lastFrame).count() / (double)col.transitionMs, 0.016, 0.5);
+    changeColor(colorState.outerSource, outerTarget, colorState.outer, MULTI, colorState.animated);
+    changeColor(colorState.innerSource, innerTarget, colorState.inner, MULTI, colorState.animated);
 
-    changeColor(SOURCE, TARGET, (BORDERLESS ? col.inner : col.outer), MULTI, col.animated);
-    changeColor(FSOURCE, FTARGET, col.font, MULTI, col.animated);
-    if (col.swapFont && !BORDERLESS)
-        changeColor(ISOURCE, ITARGET, col.inner, MULTI, col.animated);
+    // Font color is only chaned, when `swap_font_color` is set to true and no boarder is present.
+    // It is not animated, because that does not look good and we would need to rerender the text for each frame.
+    colorState.font = fontTarget;
 
-    col.lastFrame = std::chrono::system_clock::now();
+    colorState.lastFrame = std::chrono::system_clock::now();
 }
diff --git a/src/renderer/widgets/PasswordInputField.hpp b/src/renderer/widgets/PasswordInputField.hpp
index d1bbb73..9b7f7a2 100644
--- a/src/renderer/widgets/PasswordInputField.hpp
+++ b/src/renderer/widgets/PasswordInputField.hpp
@@ -24,11 +24,13 @@ class CPasswordInputField : public IWidget {
     void        updateFade();
     void        updatePlaceholder();
     void        updateHiddenInputState();
+    void        updateInputState();
     void        updateColors();
 
     bool        firstRender  = true;
     bool        redrawShadow = false;
     bool        checkWaiting = false;
+    bool        displayFail  = false;
 
     size_t      passwordLength = 0;
 
@@ -69,7 +71,6 @@ class CPasswordInputField : public IWidget {
         std::string              currentText    = "";
         size_t                   failedAttempts = 0;
         bool                     canGetNewText  = true;
-        bool                     isFailText     = false;
 
         std::string              lastAuthFeedback;
 
@@ -96,15 +97,24 @@ class CPasswordInputField : public IWidget {
 
         int    transitionMs = 0;
         bool   invertNum    = false;
-        bool   animated     = false;
-        bool   stateNum     = false;
-        bool   stateCaps    = false;
         bool   swapFont     = false;
-        bool   shouldStart;
+    } colorConfig;
+
+    struct {
+        CColor outer;
+        CColor inner;
+        CColor font;
+
+        CColor outerSource;
+        CColor innerSource;
+
+        CColor currentTarget;
+
+        bool   animated = false;
 
         //
         std::chrono::system_clock::time_point lastFrame;
-    } col;
+    } colorState;
 
     bool        fadeOnEmpty;
     uint64_t    fadeTimeoutMs;

commit 519486b5b5f8b55861be934bafad5cd963a55020
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Thu Aug 29 10:36:07 2024 +0000

    core: support desc: prefix for widget monitor options (#470)

diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 1ac260f..971c90f 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -311,7 +311,8 @@ std::vector<std::unique_ptr<IWidget>>* CRenderer::getOrCreateWidgetsFor(const CS
         });
 
         for (auto& c : CWIDGETS) {
-            if (!c.monitor.empty() && c.monitor != surf->output->stringPort && !surf->output->stringDesc.starts_with(c.monitor))
+            if (!c.monitor.empty() && c.monitor != surf->output->stringPort && !surf->output->stringDesc.starts_with(c.monitor) &&
+                !surf->output->stringDesc.starts_with("desc:" + c.monitor))
                 continue;
 
             // by type

commit daa6ed5145cbc77217d6c6ddb9123ffedb923b39
Author: Darko Nikoli <144422643+dqrk0jeste@users.noreply.github.com>
Date:   Sat Aug 31 12:37:47 2024 +0200

    core: fix symlinked images not picking up extension (#473)

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 17627ed..7cc6bba 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -106,7 +106,7 @@ FileType getFileType(const std::filesystem::path& path) {
         ft = FileType::WEBP;
     else {
         // magic is slow, so only use it when no recognized extension is found
-        auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS);
+        auto handle = magic_open(MAGIC_NONE | MAGIC_COMPRESS | MAGIC_SYMLINK);
         magic_load(handle, nullptr);
 
         const auto type_str   = std::string(magic_file(handle, path.c_str()));

commit 7b7fce3fd08a9a06c9e3982e92381ccec3b66dba
Author: Yang, Ying-chao <yang.yingchao@qq.com>
Date:   Thu Sep 5 03:58:38 2024 +0800

    asyncResourceGatherer: do not detach worker threads (#477)
    
    Worker threads become non-joinable once they are detached, and `await()` will not wait for them to
    finish. This can lead to a crash when `asyncResourceGatherer` is destroyed in the main thread while it
    is still being used in worker threads.

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 7cc6bba..1a77f20 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -18,10 +18,7 @@ CAsyncResourceGatherer::CAsyncResourceGatherer() {
         enqueueDMAFrames();
 
     initialGatherThread = std::thread([this]() { this->gather(); });
-    initialGatherThread.detach();
-
-    asyncLoopThread = std::thread([this]() { this->asyncAssetSpinLock(); });
-    asyncLoopThread.detach();
+    asyncLoopThread     = std::thread([this]() { this->asyncAssetSpinLock(); });
 }
 
 void CAsyncResourceGatherer::enqueueDMAFrames() {

commit 52443174129ae4f4ba4726dda870957409e158a9
Author: Yang, Ying-chao <yang.yingchao@qq.com>
Date:   Thu Sep 5 19:27:43 2024 +0800

    asyncResourceGatherer: stop worker threads when application is going to exit (#481)

diff --git a/src/renderer/AsyncResourceGatherer.cpp b/src/renderer/AsyncResourceGatherer.cpp
index 1a77f20..5c6daea 100644
--- a/src/renderer/AsyncResourceGatherer.cpp
+++ b/src/renderer/AsyncResourceGatherer.cpp
@@ -171,7 +171,7 @@ void CAsyncResourceGatherer::gather() {
         }
     }
 
-    while (std::any_of(dmas.begin(), dmas.end(), [](const auto& d) { return !d->asset.ready; })) {
+    while (!g_pHyprlock->m_bTerminate && std::any_of(dmas.begin(), dmas.end(), [](const auto& d) { return !d->asset.ready; })) {
         std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
 

commit a6e15bda2db4c6a22b84e45d025a4906882b5d01
Author: Maximilian Seidler <78690852+PaideiaDilemma@users.noreply.github.com>
Date:   Wed Sep 25 08:56:20 2024 +0000

    core: set capslock and numlock states on startup (#496)

diff --git a/src/core/hyprlock.cpp b/src/core/hyprlock.cpp
index 0e1b9de..87bbe79 100644
--- a/src/core/hyprlock.cpp
+++ b/src/core/hyprlock.cpp
@@ -728,6 +728,8 @@ static void handleKeyboardModifiers(void* data, wl_keyboard* wl_keyboard, uint s
     }
 
     xkb_state_update_mask(g_pHyprlock->m_pXKBState, mods_depressed, mods_latched, mods_locked, 0, 0, group);
+    g_pHyprlock->m_bCapsLock = xkb_state_mod_name_is_active(g_pHyprlock->m_pXKBState, XKB_MOD_NAME_CAPS, XKB_STATE_MODS_LOCKED);
+    g_pHyprlock->m_bNumLock  = xkb_state_mod_name_is_active(g_pHyprlock->m_pXKBState, XKB_MOD_NAME_NUM, XKB_STATE_MODS_LOCKED);
 }
 
 static void handleRepeatInfo(void* data, struct wl_keyboard* wl_keyboard, int32_t rate, int32_t delay) {
